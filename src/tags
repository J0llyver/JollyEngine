!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
APIENTRY	vendor/imgui/imgui_impl_glfw.cpp	43;"	d	file:
AcceptDragDropPayload	vendor/imgui/imgui.cpp	/^const ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)$/;"	f	class:ImGui
ActivateItem	vendor/imgui/imgui.cpp	/^void ImGui::ActivateItem(ImGuiID id)$/;"	f	class:ImGui
Active	vendor/imgui/imgui_internal.h	/^    bool                    Active;                             \/\/ Set to true on Begin(), unless Collapsed$/;"	m	struct:ImGuiWindow
ActiveId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 ActiveId;                           \/\/ Active widget$/;"	m	struct:ImGuiContext
ActiveIdAllowNavDirFlags	vendor/imgui/imgui_internal.h	/^    int                     ActiveIdAllowNavDirFlags;           \/\/ Active widget allows using directional navigation (e.g. can activate a button and move away from it)$/;"	m	struct:ImGuiContext
ActiveIdAllowOverlap	vendor/imgui/imgui_internal.h	/^    bool                    ActiveIdAllowOverlap;               \/\/ Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)$/;"	m	struct:ImGuiContext
ActiveIdBlockNavInputFlags	vendor/imgui/imgui_internal.h	/^    int                     ActiveIdBlockNavInputFlags;$/;"	m	struct:ImGuiContext
ActiveIdClickOffset	vendor/imgui/imgui_internal.h	/^    ImVec2                  ActiveIdClickOffset;                \/\/ Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)$/;"	m	struct:ImGuiContext
ActiveIdHasBeenEditedBefore	vendor/imgui/imgui_internal.h	/^    bool                    ActiveIdHasBeenEditedBefore;        \/\/ Was the value associated to the widget Edited over the course of the Active state.$/;"	m	struct:ImGuiContext
ActiveIdHasBeenEditedThisFrame	vendor/imgui/imgui_internal.h	/^    bool                    ActiveIdHasBeenEditedThisFrame;$/;"	m	struct:ImGuiContext
ActiveIdHasBeenPressedBefore	vendor/imgui/imgui_internal.h	/^    bool                    ActiveIdHasBeenPressedBefore;       \/\/ Track whether the active id led to a press (this is to allow changing between PressOnClick and PressOnRelease without pressing twice). Used by range_select branch.$/;"	m	struct:ImGuiContext
ActiveIdIsAlive	vendor/imgui/imgui_internal.h	/^    ImGuiID                 ActiveIdIsAlive;                    \/\/ Active widget has been seen this frame (we can't use a bool as the ActiveId may change within the frame)$/;"	m	struct:ImGuiContext
ActiveIdIsJustActivated	vendor/imgui/imgui_internal.h	/^    bool                    ActiveIdIsJustActivated;            \/\/ Set at the time of activation for one frame$/;"	m	struct:ImGuiContext
ActiveIdPreviousFrame	vendor/imgui/imgui_internal.h	/^    ImGuiID                 ActiveIdPreviousFrame;$/;"	m	struct:ImGuiContext
ActiveIdPreviousFrameHasBeenEditedBefore	vendor/imgui/imgui_internal.h	/^    bool                    ActiveIdPreviousFrameHasBeenEditedBefore;$/;"	m	struct:ImGuiContext
ActiveIdPreviousFrameIsAlive	vendor/imgui/imgui_internal.h	/^    bool                    ActiveIdPreviousFrameIsAlive;$/;"	m	struct:ImGuiContext
ActiveIdPreviousFrameWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            ActiveIdPreviousFrameWindow;$/;"	m	struct:ImGuiContext
ActiveIdSource	vendor/imgui/imgui_internal.h	/^    ImGuiInputSource        ActiveIdSource;                     \/\/ Activating with mouse or nav (gamepad\/keyboard)$/;"	m	struct:ImGuiContext
ActiveIdTimer	vendor/imgui/imgui_internal.h	/^    float                   ActiveIdTimer;$/;"	m	struct:ImGuiContext
ActiveIdWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            ActiveIdWindow;$/;"	m	struct:ImGuiContext
Add	vendor/imgui/imgui_internal.h	/^    T*          Add()                               { int idx = FreeIdx; if (idx == Data.Size) { Data.resize(Data.Size + 1); FreeIdx++; } else { FreeIdx = *(int*)&Data[idx]; } IM_PLACEMENT_NEW(&Data[idx]) T(); return &Data[idx]; }$/;"	f	struct:ImPool
Add	vendor/imgui/imgui_internal.h	/^    void        Add(const ImRect& r)                { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }$/;"	f	struct:ImRect
Add	vendor/imgui/imgui_internal.h	/^    void        Add(const ImVec2& p)                { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }$/;"	f	struct:ImRect
AddBezierCurve	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)$/;"	f	class:ImDrawList
AddBuffer	VertexArray/VertexArray.cpp	/^void VertexArray::AddBuffer(const VertexBuffer& vb, const VertexBufferLayout& layout){$/;"	f	class:VertexArray
AddCallback	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)$/;"	f	class:ImDrawList
AddChar	vendor/imgui/imgui.h	/^    inline void     AddChar(ImWchar c)  { SetBit(c); }                          \/\/ Add character$/;"	f	struct:ImFontGlyphRangesBuilder
AddCircle	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)$/;"	f	class:ImDrawList
AddCircleFilled	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)$/;"	f	class:ImDrawList
AddConvexPolyFilled	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)$/;"	f	class:ImDrawList
AddCustomRectFontGlyph	vendor/imgui/imgui_draw.cpp	/^int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)$/;"	f	class:ImFontAtlas
AddCustomRectRegular	vendor/imgui/imgui_draw.cpp	/^int ImFontAtlas::AddCustomRectRegular(unsigned int id, int width, int height)$/;"	f	class:ImFontAtlas
AddDrawCmd	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddDrawCmd()$/;"	f	class:ImDrawList
AddDrawListToDrawData	vendor/imgui/imgui.cpp	/^static void AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list)$/;"	f	file:
AddFont	vendor/imgui/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)$/;"	f	class:ImFontAtlas
AddFontDefault	vendor/imgui/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)$/;"	f	class:ImFontAtlas
AddFontFromFileTTF	vendor/imgui/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddFontFromMemoryCompressedBase85TTF	vendor/imgui/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddFontFromMemoryCompressedTTF	vendor/imgui/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddFontFromMemoryTTF	vendor/imgui/imgui_draw.cpp	/^ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)$/;"	f	class:ImFontAtlas
AddGlyph	vendor/imgui/imgui_draw.cpp	/^void ImFont::AddGlyph(ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)$/;"	f	class:ImFont
AddImage	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)$/;"	f	class:ImDrawList
AddImageQuad	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)$/;"	f	class:ImDrawList
AddImageRounded	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, ImDrawCornerFlags rounding_corners)$/;"	f	class:ImDrawList
AddInputCharacter	vendor/imgui/imgui.cpp	/^void ImGuiIO::AddInputCharacter(unsigned int c)$/;"	f	class:ImGuiIO
AddInputCharactersUTF8	vendor/imgui/imgui.cpp	/^void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)$/;"	f	class:ImGuiIO
AddLine	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)$/;"	f	class:ImDrawList
AddPolyline	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness)$/;"	f	class:ImDrawList
AddQuad	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)$/;"	f	class:ImDrawList
AddQuadFilled	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)$/;"	f	class:ImDrawList
AddRanges	vendor/imgui/imgui_draw.cpp	/^void ImFontGlyphRangesBuilder::AddRanges(const ImWchar* ranges)$/;"	f	class:ImFontGlyphRangesBuilder
AddRect	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, ImDrawCornerFlags rounding_corners, float thickness)$/;"	f	class:ImDrawList
AddRectFilled	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, ImDrawCornerFlags rounding_corners)$/;"	f	class:ImDrawList
AddRectFilledMultiColor	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)$/;"	f	class:ImDrawList
AddRemapChar	vendor/imgui/imgui_draw.cpp	/^void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)$/;"	f	class:ImFont
AddRootWindowToDrawData	vendor/imgui/imgui.cpp	/^static void AddRootWindowToDrawData(ImGuiWindow* window)$/;"	f	file:
AddText	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)$/;"	f	class:ImDrawList
AddText	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)$/;"	f	class:ImDrawList
AddText	vendor/imgui/imgui_draw.cpp	/^void ImFontGlyphRangesBuilder::AddText(const char* text, const char* text_end)$/;"	f	class:ImFontGlyphRangesBuilder
AddTriangle	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)$/;"	f	class:ImDrawList
AddTriangleFilled	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList
AddWindowToDrawData	vendor/imgui/imgui.cpp	/^static void AddWindowToDrawData(ImVector<ImDrawList*>* out_render_list, ImGuiWindow* window)$/;"	f	file:
AddWindowToSortBuffer	vendor/imgui/imgui.cpp	/^static void AddWindowToSortBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)$/;"	f	file:
AdvanceX	vendor/imgui/imgui.h	/^    float           AdvanceX;           \/\/ Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)$/;"	m	struct:ImFontGlyph
AlignFirstTextHeightToWidgets	vendor/imgui/imgui.h	/^    static inline void  AlignFirstTextHeightToWidgets()       { AlignTextToFramePadding(); }$/;"	f	namespace:ImGui
AlignTextToFramePadding	vendor/imgui/imgui_widgets.cpp	/^void ImGui::AlignTextToFramePadding()$/;"	f	class:ImGui
Alpha	vendor/imgui/imgui.h	/^    float       Alpha;                      \/\/ Global alpha applies to everything in Dear ImGui.$/;"	m	struct:ImGuiStyle
AngleMax12	vendor/imgui/imgui.cpp	/^    int     AngleMin12, AngleMax12;$/;"	m	struct:ImGuiResizeGripDef	file:
AngleMin12	vendor/imgui/imgui.cpp	/^    int     AngleMin12, AngleMax12;$/;"	m	struct:ImGuiResizeGripDef	file:
AntiAliasedFill	vendor/imgui/imgui.h	/^    bool        AntiAliasedFill;            \/\/ Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)$/;"	m	struct:ImGuiStyle
AntiAliasedLines	vendor/imgui/imgui.h	/^    bool        AntiAliasedLines;           \/\/ Enable anti-aliasing on lines\/borders. Disable if you are really tight on CPU\/GPU.$/;"	m	struct:ImGuiStyle
Appearing	vendor/imgui/imgui_internal.h	/^    bool                    Appearing;                          \/\/ Set during the frame where the window is appearing (or re-appearing)$/;"	m	struct:ImGuiWindow
ArrowButton	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)$/;"	f	class:ImGui
ArrowButtonEx	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ArrowButtonEx(const char* str_id, ImGuiDir dir, ImVec2 size, ImGuiButtonFlags flags)$/;"	f	class:ImGui
Ascent	vendor/imgui/imgui.h	/^    float                       Ascent, Descent;    \/\/ 4+4   \/\/ out \/\/            \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont
AutoFitChildAxises	vendor/imgui/imgui_internal.h	/^    int                     AutoFitChildAxises;$/;"	m	struct:ImGuiWindow
AutoFitFramesX	vendor/imgui/imgui_internal.h	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow
AutoFitFramesY	vendor/imgui/imgui_internal.h	/^    int                     AutoFitFramesX, AutoFitFramesY;$/;"	m	struct:ImGuiWindow
AutoFitOnlyGrows	vendor/imgui/imgui_internal.h	/^    bool                    AutoFitOnlyGrows;$/;"	m	struct:ImGuiWindow
AutoPosLastDirection	vendor/imgui/imgui_internal.h	/^    ImGuiDir                AutoPosLastDirection;$/;"	m	struct:ImGuiWindow
AutoScroll	vendor/imgui/imgui_demo.cpp	/^    bool                  AutoScroll;$/;"	m	struct:ExampleAppConsole	file:
AutoScroll	vendor/imgui/imgui_demo.cpp	/^    bool                AutoScroll;     \/\/ Keep scrolling if already at the bottom$/;"	m	struct:ExampleAppLog	file:
BackendFlags	vendor/imgui/imgui.h	/^    ImGuiBackendFlags  BackendFlags;            \/\/ = 0              \/\/ See ImGuiBackendFlags_ enum. Set by back-end (imgui_impl_xxx files or custom back-end) to communicate features supported by the back-end.$/;"	m	struct:ImGuiIO
BackendLanguageUserData	vendor/imgui/imgui.h	/^    void*       BackendLanguageUserData;        \/\/ = NULL$/;"	m	struct:ImGuiIO
BackendPlatformName	vendor/imgui/imgui.h	/^    const char* BackendPlatformName;            \/\/ = NULL$/;"	m	struct:ImGuiIO
BackendPlatformUserData	vendor/imgui/imgui.h	/^    void*       BackendPlatformUserData;        \/\/ = NULL$/;"	m	struct:ImGuiIO
BackendRendererName	vendor/imgui/imgui.h	/^    const char* BackendRendererName;            \/\/ = NULL$/;"	m	struct:ImGuiIO
BackendRendererUserData	vendor/imgui/imgui.h	/^    void*       BackendRendererUserData;        \/\/ = NULL$/;"	m	struct:ImGuiIO
BackgroundDrawList	vendor/imgui/imgui_internal.h	/^    ImDrawList              BackgroundDrawList;                 \/\/ First draw list to be rendered.$/;"	m	struct:ImGuiContext
Backup	vendor/imgui/imgui_internal.h	/^    void Backup()           { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }$/;"	f	struct:ImGuiItemHoveredDataBackup
BackupActiveIdIsAlive	vendor/imgui/imgui_internal.h	/^    ImGuiID     BackupActiveIdIsAlive;$/;"	m	struct:ImGuiGroupData
BackupActiveIdPreviousFrameIsAlive	vendor/imgui/imgui_internal.h	/^    bool        BackupActiveIdPreviousFrameIsAlive;$/;"	m	struct:ImGuiGroupData
BackupCurrLineSize	vendor/imgui/imgui_internal.h	/^    ImVec2      BackupCurrLineSize;$/;"	m	struct:ImGuiGroupData
BackupCurrLineTextBaseOffset	vendor/imgui/imgui_internal.h	/^    float       BackupCurrLineTextBaseOffset;$/;"	m	struct:ImGuiGroupData
BackupCursorMaxPos	vendor/imgui/imgui_internal.h	/^    ImVec2      BackupCursorMaxPos;$/;"	m	struct:ImGuiGroupData
BackupCursorPos	vendor/imgui/imgui_internal.h	/^    ImVec2      BackupCursorPos;$/;"	m	struct:ImGuiGroupData
BackupFloat	vendor/imgui/imgui_internal.h	/^    union           { int BackupInt[2]; float BackupFloat[2]; };$/;"	m	union:ImGuiStyleMod::__anon53
BackupGroupOffset	vendor/imgui/imgui_internal.h	/^    ImVec1      BackupGroupOffset;$/;"	m	struct:ImGuiGroupData
BackupIndent	vendor/imgui/imgui_internal.h	/^    ImVec1      BackupIndent;$/;"	m	struct:ImGuiGroupData
BackupInt	vendor/imgui/imgui_internal.h	/^    union           { int BackupInt[2]; float BackupFloat[2]; };$/;"	m	union:ImGuiStyleMod::__anon53
BackupValue	vendor/imgui/imgui_internal.h	/^    ImVec4      BackupValue;$/;"	m	struct:ImGuiColorMod
BarRect	vendor/imgui/imgui_internal.h	/^    ImRect              BarRect;$/;"	m	struct:ImGuiTabBar
Begin	vendor/imgui/imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)$/;"	f	class:ImGui
Begin	vendor/imgui/imgui.cpp	/^bool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_first_use, float bg_alpha_override, ImGuiWindowFlags flags)$/;"	f	class:ImGui
Begin	vendor/imgui/imgui.cpp	/^void ImGuiListClipper::Begin(int count, float items_height)$/;"	f	class:ImGuiListClipper
BeginChild	vendor/imgui/imgui.cpp	/^bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginChild	vendor/imgui/imgui.cpp	/^bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginChildEx	vendor/imgui/imgui.cpp	/^static bool ImGui::BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags flags)$/;"	f	class:ImGui
BeginChildFrame	vendor/imgui/imgui.cpp	/^bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginColumns	vendor/imgui/imgui_widgets.cpp	/^void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiColumnsFlags flags)$/;"	f	class:ImGui
BeginCombo	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)$/;"	f	class:ImGui
BeginCount	vendor/imgui/imgui_internal.h	/^    short                   BeginCount;                         \/\/ Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin\/End pairs)$/;"	m	struct:ImGuiWindow
BeginDragDropSource	vendor/imgui/imgui.cpp	/^bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)$/;"	f	class:ImGui
BeginDragDropTarget	vendor/imgui/imgui.cpp	/^bool ImGui::BeginDragDropTarget()$/;"	f	class:ImGui
BeginDragDropTargetCustom	vendor/imgui/imgui.cpp	/^bool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)$/;"	f	class:ImGui
BeginGroup	vendor/imgui/imgui.cpp	/^void ImGui::BeginGroup()$/;"	f	class:ImGui
BeginMainMenuBar	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::BeginMainMenuBar()$/;"	f	class:ImGui
BeginMenu	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::BeginMenu(const char* label, bool enabled)$/;"	f	class:ImGui
BeginMenuBar	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::BeginMenuBar()$/;"	f	class:ImGui
BeginOrderWithinContext	vendor/imgui/imgui_internal.h	/^    short                   BeginOrderWithinContext;            \/\/ Order within entire imgui context. This is mostly used for debugging submission order related issues.$/;"	m	struct:ImGuiWindow
BeginOrderWithinParent	vendor/imgui/imgui_internal.h	/^    short                   BeginOrderWithinParent;             \/\/ Order within immediate parent window, if we are a child window. Otherwise 0.$/;"	m	struct:ImGuiWindow
BeginPopup	vendor/imgui/imgui.cpp	/^bool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)$/;"	f	class:ImGui
BeginPopupContextItem	vendor/imgui/imgui.cpp	/^bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)$/;"	f	class:ImGui
BeginPopupContextVoid	vendor/imgui/imgui.cpp	/^bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)$/;"	f	class:ImGui
BeginPopupContextWindow	vendor/imgui/imgui.cpp	/^bool ImGui::BeginPopupContextWindow(const char* str_id, int mouse_button, bool also_over_items)$/;"	f	class:ImGui
BeginPopupEx	vendor/imgui/imgui.cpp	/^bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags)$/;"	f	class:ImGui
BeginPopupModal	vendor/imgui/imgui.cpp	/^bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)$/;"	f	class:ImGui
BeginPopupStack	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiPopupData>BeginPopupStack;                    \/\/ Which level of BeginPopup() we are in (reset every frame)$/;"	m	struct:ImGuiContext
BeginTabBar	vendor/imgui/imgui_widgets.cpp	/^bool    ImGui::BeginTabBar(const char* str_id, ImGuiTabBarFlags flags)$/;"	f	class:ImGui
BeginTabBarEx	vendor/imgui/imgui_widgets.cpp	/^bool    ImGui::BeginTabBarEx(ImGuiTabBar* tab_bar, const ImRect& tab_bar_bb, ImGuiTabBarFlags flags)$/;"	f	class:ImGui
BeginTabItem	vendor/imgui/imgui_widgets.cpp	/^bool    ImGui::BeginTabItem(const char* label, bool* p_open, ImGuiTabItemFlags flags)$/;"	f	class:ImGui
BeginTooltip	vendor/imgui/imgui.cpp	/^void ImGui::BeginTooltip()$/;"	f	class:ImGui
BeginTooltipEx	vendor/imgui/imgui.cpp	/^void ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip)$/;"	f	class:ImGui
BgAlphaVal	vendor/imgui/imgui_internal.h	/^    float                       BgAlphaVal;$/;"	m	struct:ImGuiNextWindowData
Bind	IndexBuffer/IndexBuffer.cpp	/^void IndexBuffer::Bind() const {$/;"	f	class:IndexBuffer
Bind	Shader/Shader.cpp	/^void Shader::Bind() const {$/;"	f	class:Shader
Bind	Texture/Texture.cpp	/^void Texture::Bind(unsigned int slot) const {$/;"	f	class:Texture
Bind	VertexArray/VertexArray.cpp	/^void VertexArray::Bind() const {$/;"	f	class:VertexArray
Bind	VertexBuffer/VertexBuffer.cpp	/^void VertexBuffer::Bind() const {$/;"	f	class:VertexBuffer
BringWindowToDisplayBack	vendor/imgui/imgui.cpp	/^void ImGui::BringWindowToDisplayBack(ImGuiWindow* window)$/;"	f	class:ImGui
BringWindowToDisplayFront	vendor/imgui/imgui.cpp	/^void ImGui::BringWindowToDisplayFront(ImGuiWindow* window)$/;"	f	class:ImGui
BringWindowToFocusFront	vendor/imgui/imgui.cpp	/^void ImGui::BringWindowToFocusFront(ImGuiWindow* window)$/;"	f	class:ImGui
Buf	vendor/imgui/imgui.h	/^    ImVector<char>      Buf;$/;"	m	struct:ImGuiTextBuffer
Buf	vendor/imgui/imgui.h	/^    char*               Buf;            \/\/ Text buffer                          \/\/ Read-write   \/\/ [Resize] Can replace pointer \/ [Completion,History,Always] Only write to pointed data, don't replace the actual pointer!$/;"	m	struct:ImGuiInputTextCallbackData
Buf	vendor/imgui/imgui_demo.cpp	/^    ImGuiTextBuffer     Buf;$/;"	m	struct:ExampleAppLog	file:
BufCapacityA	vendor/imgui/imgui_internal.h	/^    int                     BufCapacityA;           \/\/ end-user buffer capacity$/;"	m	struct:ImGuiInputTextState
BufDirty	vendor/imgui/imgui.h	/^    bool                BufDirty;       \/\/ Set if you modify Buf\/BufTextLen!    \/\/ Write        \/\/ [Completion,History,Always]$/;"	m	struct:ImGuiInputTextCallbackData
BufSize	vendor/imgui/imgui.h	/^    int                 BufSize;        \/\/ Buffer size (in bytes) = capacity+1  \/\/ Read-only    \/\/ [Resize,Completion,History,Always] Include zero-terminator storage. In C land == ARRAYSIZE(my_char_array), in C++ land: string.capacity()+1$/;"	m	struct:ImGuiInputTextCallbackData
BufTextLen	vendor/imgui/imgui.h	/^    int                 BufTextLen;     \/\/ Text length (in bytes)               \/\/ Read-write   \/\/ [Resize,Completion,History,Always] Exclude zero-terminator storage. In C land: == strlen(some_text), in C++ land: string.length()$/;"	m	struct:ImGuiInputTextCallbackData
Build	vendor/imgui/imgui.cpp	/^void ImGuiTextFilter::Build()$/;"	f	class:ImGuiTextFilter
Build	vendor/imgui/imgui_draw.cpp	/^bool    ImFontAtlas::Build()$/;"	f	class:ImFontAtlas
BuildLookupTable	vendor/imgui/imgui_draw.cpp	/^void ImFont::BuildLookupTable()$/;"	f	class:ImFont
BuildRanges	vendor/imgui/imgui_draw.cpp	/^void ImFontGlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)$/;"	f	class:ImFontGlyphRangesBuilder
BuildSortByKey	vendor/imgui/imgui.cpp	/^void ImGuiStorage::BuildSortByKey()$/;"	f	class:ImGuiStorage
Bullet	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Bullet()$/;"	f	class:ImGui
BulletText	vendor/imgui/imgui_widgets.cpp	/^void ImGui::BulletText(const char* fmt, ...)$/;"	f	class:ImGui
BulletTextV	vendor/imgui/imgui_widgets.cpp	/^void ImGui::BulletTextV(const char* fmt, va_list args)$/;"	f	class:ImGui
Button	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::Button(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui
ButtonBehavior	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)$/;"	f	class:ImGui
ButtonEx	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)$/;"	f	class:ImGui
ButtonTextAlign	vendor/imgui/imgui.h	/^    ImVec2      ButtonTextAlign;            \/\/ Alignment of button text when button is larger than text. Defaults to (0.5f, 0.5f) (centered).$/;"	m	struct:ImGuiStyle
COLUMNS_HIT_RECT_HALF_WIDTH	vendor/imgui/imgui_widgets.cpp	/^static const float COLUMNS_HIT_RECT_HALF_WIDTH = 4.0f;$/;"	v	file:
CalcContentSize	vendor/imgui/imgui.cpp	/^static ImVec2 CalcContentSize(ImGuiWindow* window)$/;"	f	file:
CalcCustomRectUV	vendor/imgui/imgui_draw.cpp	/^void ImFontAtlas::CalcCustomRectUV(const ImFontAtlasCustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max)$/;"	f	class:ImFontAtlas
CalcExtraSpace	vendor/imgui/imgui_widgets.cpp	/^float ImGuiMenuColumns::CalcExtraSpace(float avail_w)$/;"	f	class:ImGuiMenuColumns
CalcFontSize	vendor/imgui/imgui_internal.h	/^    float       CalcFontSize() const        { ImGuiContext& g = *GImGui; float scale = g.FontBaseSize * FontWindowScale; if (ParentWindow) scale *= ParentWindow->FontWindowScale; return scale; }$/;"	f	struct:ImGuiWindow
CalcItemRectClosestPoint	vendor/imgui/imgui.h	/^    static inline ImVec2 CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = 0.f) { IM_UNUSED(on_edge); IM_UNUSED(outward); IM_ASSERT(0); return pos; }$/;"	f	namespace:ImGui
CalcItemSize	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_w, float default_h)$/;"	f	class:ImGui
CalcItemWidth	vendor/imgui/imgui.cpp	/^float ImGui::CalcItemWidth()$/;"	f	class:ImGui
CalcListClipping	vendor/imgui/imgui.cpp	/^void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)$/;"	f	class:ImGui
CalcMaxPopupHeightFromItemCount	vendor/imgui/imgui_widgets.cpp	/^static float CalcMaxPopupHeightFromItemCount(int items_count)$/;"	f	file:
CalcNextScrollFromScrollTargetAndClamp	vendor/imgui/imgui.cpp	/^static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window, bool snap_on_edges)$/;"	f	file:
CalcResizePosSizeFromAnyCorner	vendor/imgui/imgui.cpp	/^static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)$/;"	f	file:
CalcSizeAfterConstraint	vendor/imgui/imgui.cpp	/^static ImVec2 CalcSizeAfterConstraint(ImGuiWindow* window, ImVec2 new_size)$/;"	f	file:
CalcSizeAutoFit	vendor/imgui/imgui.cpp	/^static ImVec2 CalcSizeAutoFit(ImGuiWindow* window, const ImVec2& size_contents)$/;"	f	file:
CalcTextSize	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)$/;"	f	class:ImGui
CalcTextSizeA	vendor/imgui/imgui_draw.cpp	/^ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const$/;"	f	class:ImFont
CalcTypematicPressedRepeatAmount	vendor/imgui/imgui.cpp	/^int ImGui::CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate)$/;"	f	class:ImGui
CalcWindowExpectedSize	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::CalcWindowExpectedSize(ImGuiWindow* window)$/;"	f	class:ImGui
CalcWordWrapPositionA	vendor/imgui/imgui_draw.cpp	/^const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const$/;"	f	class:ImFont
CalcWrapWidthForPos	vendor/imgui/imgui.cpp	/^float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)$/;"	f	class:ImGui
CanMergeDrawCommands	vendor/imgui/imgui_draw.cpp	/^static inline bool CanMergeDrawCommands(ImDrawCmd* a, ImDrawCmd* b)$/;"	f	file:
Capacity	vendor/imgui/imgui.h	/^    int                 Capacity;$/;"	m	struct:ImVector
CaptureKeyboardFromApp	vendor/imgui/imgui.cpp	/^void ImGui::CaptureKeyboardFromApp(bool capture)$/;"	f	class:ImGui
CaptureMouseFromApp	vendor/imgui/imgui.cpp	/^void ImGui::CaptureMouseFromApp(bool capture)$/;"	f	class:ImGui
ChannelsMerge	vendor/imgui/imgui.h	/^    inline void     ChannelsMerge()             { _Splitter.Merge(this); }$/;"	f	struct:ImDrawList
ChannelsSetCurrent	vendor/imgui/imgui.h	/^    inline void     ChannelsSetCurrent(int n)   { _Splitter.SetCurrentChannel(this, n); }$/;"	f	struct:ImDrawList
ChannelsSplit	vendor/imgui/imgui.h	/^    inline void     ChannelsSplit(int count)    { _Splitter.Split(this, count); }$/;"	f	struct:ImDrawList
CheckProgram	vendor/imgui/imgui_impl_opengl3.cpp	/^static bool CheckProgram(GLuint handle, const char* desc)$/;"	f	file:
CheckShader	vendor/imgui/imgui_impl_opengl3.cpp	/^static bool CheckShader(GLuint handle, const char* desc)$/;"	f	file:
CheckStacksSize	vendor/imgui/imgui.cpp	/^static void CheckStacksSize(ImGuiWindow* window, bool write)$/;"	f	file:
Checkbox	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::Checkbox(const char* label, bool* v)$/;"	f	class:ImGui
CheckboxFlags	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)$/;"	f	class:ImGui
ChildBorderSize	vendor/imgui/imgui.h	/^    float       ChildBorderSize;            \/\/ Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU\/GPU costly).$/;"	m	struct:ImGuiStyle
ChildId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 ChildId;                            \/\/ ID of corresponding item in parent window (for navigation to return from child window to parent window)$/;"	m	struct:ImGuiWindow
ChildRounding	vendor/imgui/imgui.h	/^    float       ChildRounding;              \/\/ Radius of child window corners rounding. Set to 0.0f to have rectangular windows.$/;"	m	struct:ImGuiStyle
ChildWindowComparer	vendor/imgui/imgui.cpp	/^static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)$/;"	f	file:
ChildWindows	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiWindow*>  ChildWindows;$/;"	m	struct:ImGuiWindowTempData
CircleVtx12	vendor/imgui/imgui_internal.h	/^    ImVec2          CircleVtx12[12];$/;"	m	struct:ImDrawListSharedData
ClampWindowRect	vendor/imgui/imgui.cpp	/^static inline void ClampWindowRect(ImGuiWindow* window, const ImRect& rect, const ImVec2& padding)$/;"	f	file:
Clear	Renderer/Renderer.cpp	/^void Renderer::Clear() const {$/;"	f	class:Renderer
Clear	vendor/imgui/imgui.h	/^    inline void                 Clear() { _Current = 0; _Count = 1; } \/\/ Do not clear Channels[] so our allocations are reused next frame$/;"	f	struct:ImDrawListSplitter
Clear	vendor/imgui/imgui.h	/^    inline void     Clear()             { int size_in_bytes = 0x10000 \/ 8; UsedChars.resize(size_in_bytes \/ (int)sizeof(ImU32)); memset(UsedChars.Data, 0, (size_t)size_in_bytes); }$/;"	f	struct:ImFontGlyphRangesBuilder
Clear	vendor/imgui/imgui.h	/^    void                Clear()          { InputBuf[0] = 0; Build(); }$/;"	f	struct:ImGuiTextFilter
Clear	vendor/imgui/imgui.h	/^    void                Clear() { Data.clear(); }$/;"	f	struct:ImGuiStorage
Clear	vendor/imgui/imgui.h	/^    void Clear()    { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }$/;"	f	struct:ImGuiPayload
Clear	vendor/imgui/imgui.h	/^    void Clear()    { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; DisplayPos = DisplaySize = FramebufferScale = ImVec2(0.f, 0.f); } \/\/ The ImDrawList are owned by ImGuiContext!$/;"	f	struct:ImDrawData
Clear	vendor/imgui/imgui_demo.cpp	/^    void    Clear()$/;"	f	struct:ExampleAppLog
Clear	vendor/imgui/imgui_draw.cpp	/^void    ImFontAtlas::Clear()$/;"	f	class:ImFontAtlas
Clear	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::Clear()$/;"	f	class:ImDrawList
Clear	vendor/imgui/imgui_internal.h	/^    void            Clear()                 { Storage.clear(); }$/;"	f	struct:ImBoolVector
Clear	vendor/imgui/imgui_internal.h	/^    void        Clear()                             { for (int n = 0; n < Map.Data.Size; n++) { int idx = Map.Data[n].val_i; if (idx != -1) Data[idx].~T(); } Map.Clear(); Data.clear(); FreeIdx = 0; }$/;"	f	struct:ImPool
Clear	vendor/imgui/imgui_internal.h	/^    void Clear()            { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }$/;"	f	struct:ImDrawDataBuilder
Clear	vendor/imgui/imgui_internal.h	/^    void Clear()         { ID = SelectScopeId = 0; Window = NULL; DistBox = DistCenter = DistAxial = FLT_MAX; RectRel = ImRect(); }$/;"	f	struct:ImGuiNavMoveResult
Clear	vendor/imgui/imgui_internal.h	/^    void Clear()$/;"	f	struct:ImGuiColumns
ClearActiveID	vendor/imgui/imgui.cpp	/^void ImGui::ClearActiveID()$/;"	f	class:ImGui
ClearDragDrop	vendor/imgui/imgui.cpp	/^void ImGui::ClearDragDrop()$/;"	f	class:ImGui
ClearFlags	vendor/imgui/imgui_internal.h	/^    inline void ClearFlags()    { Flags = ImGuiNextItemDataFlags_None; }$/;"	f	struct:ImGuiNextItemData
ClearFlags	vendor/imgui/imgui_internal.h	/^    inline void ClearFlags()    { Flags = ImGuiNextWindowDataFlags_None; }$/;"	f	struct:ImGuiNextWindowData
ClearFonts	vendor/imgui/imgui_draw.cpp	/^void    ImFontAtlas::ClearFonts()$/;"	f	class:ImFontAtlas
ClearFreeMemory	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::ClearFreeMemory()$/;"	f	class:ImDrawList
ClearFreeMemory	vendor/imgui/imgui_draw.cpp	/^void ImDrawListSplitter::ClearFreeMemory()$/;"	f	class:ImDrawListSplitter
ClearFreeMemory	vendor/imgui/imgui_internal.h	/^    void        ClearFreeMemory()           { TextW.clear(); TextA.clear(); InitialTextA.clear(); }$/;"	f	struct:ImGuiInputTextState
ClearFreeMemory	vendor/imgui/imgui_internal.h	/^    void ClearFreeMemory()  { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }$/;"	f	struct:ImDrawDataBuilder
ClearInputCharacters	vendor/imgui/imgui.cpp	/^void ImGuiIO::ClearInputCharacters()$/;"	f	class:ImGuiIO
ClearInputData	vendor/imgui/imgui_draw.cpp	/^void    ImFontAtlas::ClearInputData()$/;"	f	class:ImFontAtlas
ClearLog	vendor/imgui/imgui_demo.cpp	/^    void    ClearLog()$/;"	f	struct:ExampleAppConsole
ClearOutputData	vendor/imgui/imgui_draw.cpp	/^void    ImFont::ClearOutputData()$/;"	f	class:ImFont
ClearSelection	vendor/imgui/imgui_internal.h	/^    void        ClearSelection()            { Stb.select_start = Stb.select_end = Stb.cursor; }$/;"	f	struct:ImGuiInputTextState
ClearTexData	vendor/imgui/imgui_draw.cpp	/^void    ImFontAtlas::ClearTexData()$/;"	f	class:ImFontAtlas
ClearText	vendor/imgui/imgui_internal.h	/^    void        ClearText()                 { CurLenW = CurLenA = 0; TextW[0] = 0; TextA[0] = 0; CursorClamp(); }$/;"	f	struct:ImGuiInputTextState
ClipRect	vendor/imgui/imgui.h	/^    ImVec4          ClipRect;               \/\/ Clipping rectangle (x1, y1, x2, y2). Subtract ImDrawData->DisplayPos to get clipping rectangle in "viewport" coordinates$/;"	m	struct:ImDrawCmd
ClipRect	vendor/imgui/imgui_internal.h	/^    ImRect                  ClipRect;                           \/\/ Current clipping\/scissoring rectangle, evolve as we are using PushClipRect(), etc. == DrawList->clip_rect_stack.back().$/;"	m	struct:ImGuiWindow
ClipRect	vendor/imgui/imgui_internal.h	/^    ImRect              ClipRect;$/;"	m	struct:ImGuiColumnData
ClipRectFullscreen	vendor/imgui/imgui_internal.h	/^    ImVec4          ClipRectFullscreen;         \/\/ Value for PushClipRectFullscreen()$/;"	m	struct:ImDrawListSharedData
ClipWith	vendor/imgui/imgui_internal.h	/^    void        ClipWith(const ImRect& r)           { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   \/\/ Simple version, may lead to an inverted rectangle, which is fine for Contains\/Overlaps test but not for display.$/;"	f	struct:ImRect
ClipWithFull	vendor/imgui/imgui_internal.h	/^    void        ClipWithFull(const ImRect& r)       { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } \/\/ Full version, ensure both points are fully clipped.$/;"	f	struct:ImRect
ClipboardUserData	vendor/imgui/imgui.h	/^    void*       ClipboardUserData;$/;"	m	struct:ImGuiIO
CloneOutput	vendor/imgui/imgui_draw.cpp	/^ImDrawList* ImDrawList::CloneOutput() const$/;"	f	class:ImDrawList
CloseButton	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos)\/\/, float size)$/;"	f	class:ImGui
CloseCurrentPopup	vendor/imgui/imgui.cpp	/^void ImGui::CloseCurrentPopup()$/;"	f	class:ImGui
ClosePopupToLevel	vendor/imgui/imgui.cpp	/^void ImGui::ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)$/;"	f	class:ImGui
ClosePopupsOverWindow	vendor/imgui/imgui.cpp	/^void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window, bool restore_focus_to_window_under_popup)$/;"	f	class:ImGui
CmdBuffer	vendor/imgui/imgui.h	/^    ImVector<ImDrawCmd>     CmdBuffer;          \/\/ Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.$/;"	m	struct:ImDrawList
CmdLists	vendor/imgui/imgui.h	/^    ImDrawList**    CmdLists;               \/\/ Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.$/;"	m	struct:ImDrawData
CmdListsCount	vendor/imgui/imgui.h	/^    int             CmdListsCount;          \/\/ Number of ImDrawList* to render$/;"	m	struct:ImDrawData
Codepoint	vendor/imgui/imgui.h	/^    ImWchar         Codepoint;          \/\/ 0x0000..0xFFFF$/;"	m	struct:ImFontGlyph
Col	vendor/imgui/imgui_internal.h	/^    ImGuiCol    Col;$/;"	m	struct:ImGuiColorMod
CollapseButton	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::CollapseButton(ImGuiID id, const ImVec2& pos)$/;"	f	class:ImGui
Collapsed	vendor/imgui/imgui_internal.h	/^    bool                    Collapsed;                          \/\/ Set when collapsing window to become only title-bar$/;"	m	struct:ImGuiWindow
Collapsed	vendor/imgui/imgui_internal.h	/^    bool        Collapsed;$/;"	m	struct:ImGuiWindowSettings
CollapsedCond	vendor/imgui/imgui_internal.h	/^    ImGuiCond                   CollapsedCond;$/;"	m	struct:ImGuiNextWindowData
CollapsedVal	vendor/imgui/imgui_internal.h	/^    bool                        CollapsedVal;$/;"	m	struct:ImGuiNextWindowData
CollapsingHeader	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui
CollapsingHeader	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui
Color	vendor/imgui/imgui_demo.cpp	/^    ImVec4      Color;          \/\/ An arbitrary variable associated to the document$/;"	m	struct:MyDocument	file:
ColorButton	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)$/;"	f	class:ImGui
ColorButtonPosition	vendor/imgui/imgui.h	/^    ImGuiDir    ColorButtonPosition;        \/\/ Side of the color button in the ColorEdit4 widget (left\/right). Defaults to ImGuiDir_Right.$/;"	m	struct:ImGuiStyle
ColorConvertFloat4ToU32	vendor/imgui/imgui.cpp	/^ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)$/;"	f	class:ImGui
ColorConvertHSVtoRGB	vendor/imgui/imgui.cpp	/^void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)$/;"	f	class:ImGui
ColorConvertRGBtoHSV	vendor/imgui/imgui.cpp	/^void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)$/;"	f	class:ImGui
ColorConvertU32ToFloat4	vendor/imgui/imgui.cpp	/^ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)$/;"	f	class:ImGui
ColorEdit3	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)$/;"	f	class:ImGui
ColorEdit4	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)$/;"	f	class:ImGui
ColorEditOptions	vendor/imgui/imgui_internal.h	/^    ImGuiColorEditFlags     ColorEditOptions;                   \/\/ Store user options for color edit widgets$/;"	m	struct:ImGuiContext
ColorEditOptionsPopup	vendor/imgui/imgui_widgets.cpp	/^void ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)$/;"	f	class:ImGui
ColorModifiers	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiColorMod> ColorModifiers;                     \/\/ Stack for PushStyleColor()\/PopStyleColor()$/;"	m	struct:ImGuiContext
ColorPicker3	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)$/;"	f	class:ImGui
ColorPicker4	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)$/;"	f	class:ImGui
ColorPickerOptionsPopup	vendor/imgui/imgui_widgets.cpp	/^void ImGui::ColorPickerOptionsPopup(const float* ref_col, ImGuiColorEditFlags flags)$/;"	f	class:ImGui
ColorPickerRef	vendor/imgui/imgui_internal.h	/^    ImVec4                  ColorPickerRef;$/;"	m	struct:ImGuiContext
ColorTooltip	vendor/imgui/imgui_widgets.cpp	/^void ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)$/;"	f	class:ImGui
Colors	vendor/imgui/imgui.h	/^    ImVec4      Colors[ImGuiCol_COUNT];$/;"	m	struct:ImGuiStyle
Columns	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiColumnData> Columns;$/;"	m	struct:ImGuiColumns
Columns	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Columns(int columns_count, const char* id, bool border)$/;"	f	class:ImGui
ColumnsMinSpacing	vendor/imgui/imgui.h	/^    float       ColumnsMinSpacing;          \/\/ Minimum horizontal spacing between two columns. Preferably > (FramePadding.x + 1).$/;"	m	struct:ImGuiStyle
ColumnsOffset	vendor/imgui/imgui_internal.h	/^    ImVec1                  ColumnsOffset;          \/\/ Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.$/;"	m	struct:ImGuiWindowTempData
ColumnsStorage	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiColumns>  ColumnsStorage;$/;"	m	struct:ImGuiWindow
Combo	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::Combo(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)$/;"	f	class:ImGui
Combo	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)$/;"	f	class:ImGui
Combo	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)$/;"	f	class:ImGui
Commands	vendor/imgui/imgui_demo.cpp	/^    ImVector<const char*> Commands;$/;"	m	struct:ExampleAppConsole	file:
CompileShader	Shader/Shader.cpp	/^unsigned int Shader::CompileShader(unsigned int type, const std::string & source){$/;"	f	class:Shader
ConfigData	vendor/imgui/imgui.h	/^    ImVector<ImFontConfig>      ConfigData;         \/\/ Internal data$/;"	m	struct:ImFontAtlas
ConfigData	vendor/imgui/imgui.h	/^    const ImFontConfig*         ConfigData;         \/\/ 4-8   \/\/ in  \/\/            \/\/ Pointer within ContainerAtlas->ConfigData$/;"	m	struct:ImFont
ConfigDataCount	vendor/imgui/imgui.h	/^    short                       ConfigDataCount;    \/\/ 2     \/\/ in  \/\/ ~ 1        \/\/ Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.$/;"	m	struct:ImFont
ConfigFlags	vendor/imgui/imgui.h	/^    ImGuiConfigFlags   ConfigFlags;             \/\/ = 0              \/\/ See ImGuiConfigFlags_ enum. Set by user\/application. Gamepad\/keyboard navigation options, etc.$/;"	m	struct:ImGuiIO
ConfigInputTextCursorBlink	vendor/imgui/imgui.h	/^    bool        ConfigInputTextCursorBlink;     \/\/ = true           \/\/ Set to false to disable blinking cursor, for users who consider it distracting. (was called: io.OptCursorBlink prior to 1.63)$/;"	m	struct:ImGuiIO
ConfigMacOSXBehaviors	vendor/imgui/imgui.h	/^    bool        ConfigMacOSXBehaviors;          \/\/ = defined(__APPLE__) \/\/ OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd\/Super instead of Ctrl, Line\/Text Start and End using Cmd+Arrows instead of Home\/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd\/Super instead of Ctrl (was called io.OptMacOSXBehaviors prior to 1.63)$/;"	m	struct:ImGuiIO
ConfigWindowsMoveFromTitleBarOnly	vendor/imgui/imgui.h	/^    bool        ConfigWindowsMoveFromTitleBarOnly; \/\/ = false       \/\/ [BETA] Set to true to only allow moving windows when clicked+dragged from the title bar. Windows without a title bar are not affected.$/;"	m	struct:ImGuiIO
ConfigWindowsResizeFromEdges	vendor/imgui/imgui.h	/^    bool        ConfigWindowsResizeFromEdges;   \/\/ = true           \/\/ Enable resizing of windows from their edges and from the lower-left corner. This requires (io.BackendFlags & ImGuiBackendFlags_HasMouseCursors) because it needs mouse cursor feedback. (This used to be a per-window ImGuiWindowFlags_ResizeFromAnySide flag)$/;"	m	struct:ImGuiIO
ContainerAtlas	vendor/imgui/imgui.h	/^    ImFontAtlas*                ContainerAtlas;     \/\/ 4-8   \/\/ out \/\/            \/\/ What we has been loaded into$/;"	m	struct:ImFont
Contains	vendor/imgui/imgui_internal.h	/^    bool        Contains(const ImRect& r) const     { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }$/;"	f	struct:ImRect
Contains	vendor/imgui/imgui_internal.h	/^    bool        Contains(const ImVec2& p) const     { return p.x     >= Min.x && p.y     >= Min.y && p.x     <  Max.x && p.y     <  Max.y; }$/;"	f	struct:ImRect
Contains	vendor/imgui/imgui_internal.h	/^    bool        Contains(const T* p) const          { return (p >= Data.Data && p < Data.Data + Data.Size); }$/;"	f	struct:ImPool
ContentSize	vendor/imgui/imgui_internal.h	/^    ImVec2                  ContentSize;                        \/\/ Size of contents\/scrollable client area (calculated from the extents reach of the cursor) from previous frame. Does not include window decoration or window padding.$/;"	m	struct:ImGuiWindow
ContentSizeExplicit	vendor/imgui/imgui_internal.h	/^    ImVec2                  ContentSizeExplicit;                \/\/ Size of contents\/scrollable client area explicitly request by the user via SetNextWindowContentSize().$/;"	m	struct:ImGuiWindow
ContentSizeVal	vendor/imgui/imgui_internal.h	/^    ImVec2                      ContentSizeVal;$/;"	m	struct:ImGuiNextWindowData
ContentsHeight	vendor/imgui/imgui_internal.h	/^    float               ContentsHeight;$/;"	m	struct:ImGuiTabBar
ContentsRegionRect	vendor/imgui/imgui_internal.h	/^    ImRect                  ContentsRegionRect;                 \/\/ FIXME: This is currently confusing\/misleading. It is essentially WorkRect but not handling of scrolling. We currently rely on it as right\/bottom aligned sizing operation need some size to rely on.$/;"	m	struct:ImGuiWindow
CornerPosN	vendor/imgui/imgui.cpp	/^    ImVec2  CornerPosN;$/;"	m	struct:ImGuiResizeGripDef	file:
Count	vendor/imgui/imgui.cpp	/^    ImU32           Count;$/;"	m	struct:ImGuiStyleVarInfo	file:
Count	vendor/imgui/imgui_internal.h	/^    int                 Count;$/;"	m	struct:ImGuiColumns
CountGrep	vendor/imgui/imgui.h	/^    int                     CountGrep;$/;"	m	struct:ImGuiTextFilter
CreateContext	vendor/imgui/imgui.cpp	/^ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)$/;"	f	class:ImGui
CreateNewWindow	vendor/imgui/imgui.cpp	/^static ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)$/;"	f	file:
CreateNewWindowSettings	vendor/imgui/imgui.cpp	/^ImGuiWindowSettings* ImGui::CreateNewWindowSettings(const char* name)$/;"	f	class:ImGui
CreateShader	Shader/Shader.cpp	/^unsigned int Shader::CreateShader(const std::string& vertexShader, const std::string& fragmentShader){$/;"	f	class:Shader
CurLenA	vendor/imgui/imgui_internal.h	/^    int                     CurLenW, CurLenA;       \/\/ we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 len is valid even if TextA is not.$/;"	m	struct:ImGuiInputTextState
CurLenW	vendor/imgui/imgui_internal.h	/^    int                     CurLenW, CurLenA;       \/\/ we need to maintain our buffer length in both UTF-8 and wchar format. UTF-8 len is valid even if TextA is not.$/;"	m	struct:ImGuiInputTextState
CurrFrameVisible	vendor/imgui/imgui_internal.h	/^    int                 CurrFrameVisible;$/;"	m	struct:ImGuiTabBar
CurrLineSize	vendor/imgui/imgui_internal.h	/^    ImVec2                  CurrLineSize;$/;"	m	struct:ImGuiWindowTempData
CurrLineTextBaseOffset	vendor/imgui/imgui_internal.h	/^    float                   CurrLineTextBaseOffset;$/;"	m	struct:ImGuiWindowTempData
Current	vendor/imgui/imgui_internal.h	/^    int                 Current;$/;"	m	struct:ImGuiColumns
CurrentColumns	vendor/imgui/imgui_internal.h	/^    ImGuiColumns*           CurrentColumns;         \/\/ Current columns set$/;"	m	struct:ImGuiWindowTempData
CurrentSize	vendor/imgui/imgui.h	/^    ImVec2  CurrentSize;    \/\/ Read-only.   Current window size.$/;"	m	struct:ImGuiSizeCallbackData
CurrentTabBar	vendor/imgui/imgui_internal.h	/^    ImGuiTabBar*                    CurrentTabBar;$/;"	m	struct:ImGuiContext
CurrentTabBarStack	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiPtrOrIndex>       CurrentTabBarStack;$/;"	m	struct:ImGuiContext
CurrentWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            CurrentWindow;                      \/\/ Being drawn into$/;"	m	struct:ImGuiContext
CurrentWindowStack	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiWindow*>  CurrentWindowStack;$/;"	m	struct:ImGuiContext
CursorAnim	vendor/imgui/imgui_internal.h	/^    float                   CursorAnim;             \/\/ timer for cursor blink, reset on every user action so the cursor reappears immediately$/;"	m	struct:ImGuiInputTextState
CursorAnimReset	vendor/imgui/imgui_internal.h	/^    void        CursorAnimReset()           { CursorAnim = -0.30f; }                                   \/\/ After a user-input the cursor stays on for a while without blinking$/;"	f	struct:ImGuiInputTextState
CursorClamp	vendor/imgui/imgui_internal.h	/^    void        CursorClamp()               { Stb.cursor = ImMin(Stb.cursor, CurLenW); Stb.select_start = ImMin(Stb.select_start, CurLenW); Stb.select_end = ImMin(Stb.select_end, CurLenW); }$/;"	f	struct:ImGuiInputTextState
CursorFollow	vendor/imgui/imgui_internal.h	/^    bool                    CursorFollow;           \/\/ set when we want scrolling to follow the current cursor position (not always!)$/;"	m	struct:ImGuiInputTextState
CursorMaxPos	vendor/imgui/imgui_internal.h	/^    ImVec2                  CursorMaxPos;           \/\/ Used to implicitly calculate the size of our contents, always growing during the frame. Used to calculate window->ContentSize at the beginning of next frame$/;"	m	struct:ImGuiWindowTempData
CursorPos	vendor/imgui/imgui.h	/^    int                 CursorPos;      \/\/                                      \/\/ Read-write   \/\/ [Completion,History,Always]$/;"	m	struct:ImGuiInputTextCallbackData
CursorPos	vendor/imgui/imgui_internal.h	/^    ImVec2                  CursorPos;$/;"	m	struct:ImGuiWindowTempData
CursorPosPrevLine	vendor/imgui/imgui_internal.h	/^    ImVec2                  CursorPosPrevLine;$/;"	m	struct:ImGuiWindowTempData
CursorStartPos	vendor/imgui/imgui_internal.h	/^    ImVec2                  CursorStartPos;         \/\/ Initial position in client area with padding$/;"	m	struct:ImGuiWindowTempData
CurveTessellationTol	vendor/imgui/imgui.h	/^    float       CurveTessellationTol;       \/\/ Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.$/;"	m	struct:ImGuiStyle
CurveTessellationTol	vendor/imgui/imgui_internal.h	/^    float           CurveTessellationTol;$/;"	m	struct:ImDrawListSharedData
CustomRect	vendor/imgui/imgui.h	/^    typedef ImFontAtlasCustomRect    CustomRect;         \/\/ OBSOLETED in 1.72+$/;"	t	struct:ImFontAtlas
CustomRectIds	vendor/imgui/imgui.h	/^    int                         CustomRectIds[1];   \/\/ Identifiers of custom texture rectangle used by ImFontAtlas\/ImDrawList$/;"	m	struct:ImFontAtlas
CustomRects	vendor/imgui/imgui.h	/^    ImVector<ImFontAtlasCustomRect> CustomRects;    \/\/ Rectangles for packing custom texture data into the atlas.$/;"	m	struct:ImFontAtlas
DC	vendor/imgui/imgui_internal.h	/^    ImGuiWindowTempData     DC;                                 \/\/ Temporary per-window data, reset at the beginning of the frame. This used to be called ImGuiDrawContext, hence the "DC" variable name.$/;"	m	struct:ImGuiWindow
Data	vendor/imgui/imgui.h	/^    ImVector<ImGuiStoragePair>      Data;$/;"	m	struct:ImGuiStorage
Data	vendor/imgui/imgui.h	/^    T*                  Data;$/;"	m	struct:ImVector
Data	vendor/imgui/imgui.h	/^    void*           Data;               \/\/ Data (copied and owned by dear imgui)$/;"	m	struct:ImGuiPayload
Data	vendor/imgui/imgui_internal.h	/^    ImVector<T>     Data;       \/\/ Contiguous data$/;"	m	struct:ImPool
DataFrameCount	vendor/imgui/imgui.h	/^    int             DataFrameCount;     \/\/ Data timestamp$/;"	m	struct:ImGuiPayload
DataSize	vendor/imgui/imgui.h	/^    int             DataSize;           \/\/ Data size$/;"	m	struct:ImGuiPayload
DataType	vendor/imgui/imgui.h	/^    char            DataType[32+1];     \/\/ Data type tag (short user-supplied string, 32 characters max)$/;"	m	struct:ImGuiPayload
DataTypeApplyOp	vendor/imgui/imgui_widgets.cpp	/^void ImGui::DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg1, const void* arg2)$/;"	f	class:ImGui
DataTypeApplyOpFromText	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* format)$/;"	f	class:ImGui
DataTypeFormatString	vendor/imgui/imgui_widgets.cpp	/^int ImGui::DataTypeFormatString(char* buf, int buf_size, ImGuiDataType data_type, const void* data_ptr, const char* format)$/;"	f	class:ImGui
DataTypeGetInfo	vendor/imgui/imgui_widgets.cpp	/^const ImGuiDataTypeInfo* ImGui::DataTypeGetInfo(ImGuiDataType data_type)$/;"	f	class:ImGui
DeIndexAllBuffers	vendor/imgui/imgui_draw.cpp	/^void ImDrawData::DeIndexAllBuffers()$/;"	f	class:ImDrawData
DebugCheckVersionAndDataLayout	vendor/imgui/imgui.cpp	/^bool ImGui::DebugCheckVersionAndDataLayout(const char* version, size_t sz_io, size_t sz_style, size_t sz_vec2, size_t sz_vec4, size_t sz_vert, size_t sz_idx)$/;"	f	class:ImGui
DebugItemPickerActive	vendor/imgui/imgui_internal.h	/^    bool                    DebugItemPickerActive;$/;"	m	struct:ImGuiContext
DebugItemPickerBreakID	vendor/imgui/imgui_internal.h	/^    ImGuiID                 DebugItemPickerBreakID;             \/\/ Will call IM_DEBUG_BREAK() when encountering this id$/;"	m	struct:ImGuiContext
DebugStartItemPicker	vendor/imgui/imgui_internal.h	/^    inline void             DebugStartItemPicker() { GImGui->DebugItemPickerActive = true; }$/;"	f	namespace:ImGui
DeclColumns	vendor/imgui/imgui_widgets.cpp	/^float ImGuiMenuColumns::DeclColumns(float w0, float w1, float w2) \/\/ not using va_arg because they promote float to double$/;"	f	class:ImGuiMenuColumns
Decode85	vendor/imgui/imgui_draw.cpp	/^static void         Decode85(const unsigned char* src, unsigned char* dst)$/;"	f	file:
Decode85Byte	vendor/imgui/imgui_draw.cpp	/^static unsigned int Decode85Byte(char c)                                    { return c >= '\\\\' ? c-36 : c-35; }$/;"	f	file:
DeleteChars	vendor/imgui/imgui_widgets.cpp	/^void ImGuiInputTextCallbackData::DeleteChars(int pos, int bytes_count)$/;"	f	class:ImGuiInputTextCallbackData
Delivery	vendor/imgui/imgui.h	/^    bool            Delivery;           \/\/ Set when AcceptDragDropPayload() was called and mouse button is released over the target item.$/;"	m	struct:ImGuiPayload
DeltaTime	vendor/imgui/imgui.h	/^    float       DeltaTime;                      \/\/ = 1.0f\/60.0f     \/\/ Time elapsed since last frame, in seconds.$/;"	m	struct:ImGuiIO
Descent	vendor/imgui/imgui.h	/^    float                       Ascent, Descent;    \/\/ 4+4   \/\/ out \/\/            \/\/ Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]$/;"	m	struct:ImFont
DesiredSize	vendor/imgui/imgui.h	/^    ImVec2  DesiredSize;    \/\/ Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.$/;"	m	struct:ImGuiSizeCallbackData
DestroyContext	vendor/imgui/imgui.cpp	/^void ImGui::DestroyContext(ImGuiContext* ctx)$/;"	f	class:ImGui
DimBgRatio	vendor/imgui/imgui_internal.h	/^    float                   DimBgRatio;                         \/\/ 0.0..1.0 animation when fading in a dimming background (for modal window and CTRL+TAB list)$/;"	m	struct:ImGuiContext
Dirty	vendor/imgui/imgui_demo.cpp	/^    bool        Dirty;          \/\/ Set when the document has been modified$/;"	m	struct:MyDocument	file:
DirtyLookupTables	vendor/imgui/imgui.h	/^    bool                        DirtyLookupTables;  \/\/ 1     \/\/ out \/\/$/;"	m	struct:ImFont
DisplayContents	vendor/imgui/imgui_demo.cpp	/^    static void DisplayContents(MyDocument* doc)$/;"	f	struct:MyDocument
DisplayContextMenu	vendor/imgui/imgui_demo.cpp	/^    static void DisplayContextMenu(MyDocument* doc)$/;"	f	struct:MyDocument
DisplayEnd	vendor/imgui/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper
DisplayFramebufferScale	vendor/imgui/imgui.h	/^    ImVec2      DisplayFramebufferScale;        \/\/ = (1, 1)         \/\/ For retina display or other situations where window coordinates are different from framebuffer coordinates. This generally ends up in ImDrawData::FramebufferScale.$/;"	m	struct:ImGuiIO
DisplayOffset	vendor/imgui/imgui.h	/^    ImVec2                      DisplayOffset;      \/\/ 8     \/\/ in  \/\/ = (0,0)    \/\/ Offset font rendering by xx pixels$/;"	m	struct:ImFont
DisplayPos	vendor/imgui/imgui.h	/^    ImVec2          DisplayPos;             \/\/ Upper-left position of the viewport to render (== upper-left of the orthogonal projection matrix to use)$/;"	m	struct:ImDrawData
DisplaySafeAreaPadding	vendor/imgui/imgui.h	/^    ImVec2      DisplaySafeAreaPadding;     \/\/ If you cannot see the edges of your screen (e.g. on a TV) increase the safe area padding. Apply to popups\/tooltips as well regular windows. NB: Prefer configuring your TV sets correctly!$/;"	m	struct:ImGuiStyle
DisplaySize	vendor/imgui/imgui.h	/^    ImVec2          DisplaySize;            \/\/ Size of the viewport to render (== io.DisplaySize for the main viewport) (DisplayPos + DisplaySize == lower-right of the orthogonal projection matrix to use)$/;"	m	struct:ImDrawData
DisplaySize	vendor/imgui/imgui.h	/^    ImVec2      DisplaySize;                    \/\/ <unset>          \/\/ Main display size, in pixels.$/;"	m	struct:ImGuiIO
DisplayStart	vendor/imgui/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper
DisplayWindowPadding	vendor/imgui/imgui.h	/^    ImVec2      DisplayWindowPadding;       \/\/ Window position are clamped to be visible within the display area by at least this amount. Only applies to regular windows.$/;"	m	struct:ImGuiStyle
DistAxial	vendor/imgui/imgui_internal.h	/^    float         DistAxial;$/;"	m	struct:ImGuiNavMoveResult
DistBox	vendor/imgui/imgui_internal.h	/^    float         DistBox;      \/\/ Best candidate box distance to current NavId$/;"	m	struct:ImGuiNavMoveResult
DistCenter	vendor/imgui/imgui_internal.h	/^    float         DistCenter;   \/\/ Best candidate center distance to current NavId$/;"	m	struct:ImGuiNavMoveResult
DoForceClose	vendor/imgui/imgui_demo.cpp	/^    void DoForceClose() { Open = false; Dirty = false; }$/;"	f	struct:MyDocument
DoOpen	vendor/imgui/imgui_demo.cpp	/^    void DoOpen()       { Open = true; }$/;"	f	struct:MyDocument
DoQueueClose	vendor/imgui/imgui_demo.cpp	/^    void DoQueueClose() { WantClose = true; }$/;"	f	struct:MyDocument
DoSave	vendor/imgui/imgui_demo.cpp	/^    void DoSave()       { Dirty = false; }$/;"	f	struct:MyDocument
Documents	vendor/imgui/imgui_demo.cpp	/^    ImVector<MyDocument> Documents;$/;"	m	struct:ExampleAppDocuments	file:
DragBehavior	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragBehavior(ImGuiID id, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power, ImGuiDragFlags flags)$/;"	f	class:ImGui
DragBehaviorT	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragBehaviorT(ImGuiDataType data_type, TYPE* v, float v_speed, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiDragFlags flags)$/;"	f	class:ImGui
DragCurrentAccum	vendor/imgui/imgui_internal.h	/^    float                   DragCurrentAccum;                   \/\/ Accumulator for dragging modification. Always high-precision, not rounded by end-user precision settings$/;"	m	struct:ImGuiContext
DragCurrentAccumDirty	vendor/imgui/imgui_internal.h	/^    bool                    DragCurrentAccumDirty;$/;"	m	struct:ImGuiContext
DragDropAcceptFlags	vendor/imgui/imgui_internal.h	/^    ImGuiDragDropFlags      DragDropAcceptFlags;$/;"	m	struct:ImGuiContext
DragDropAcceptFrameCount	vendor/imgui/imgui_internal.h	/^    int                     DragDropAcceptFrameCount;           \/\/ Last time a target expressed a desire to accept the source$/;"	m	struct:ImGuiContext
DragDropAcceptIdCurr	vendor/imgui/imgui_internal.h	/^    ImGuiID                 DragDropAcceptIdCurr;               \/\/ Target item id (set at the time of accepting the payload)$/;"	m	struct:ImGuiContext
DragDropAcceptIdCurrRectSurface	vendor/imgui/imgui_internal.h	/^    float                   DragDropAcceptIdCurrRectSurface;    \/\/ Target item surface (we resolve overlapping targets by prioritizing the smaller surface)$/;"	m	struct:ImGuiContext
DragDropAcceptIdPrev	vendor/imgui/imgui_internal.h	/^    ImGuiID                 DragDropAcceptIdPrev;               \/\/ Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)$/;"	m	struct:ImGuiContext
DragDropActive	vendor/imgui/imgui_internal.h	/^    bool                    DragDropActive;$/;"	m	struct:ImGuiContext
DragDropMouseButton	vendor/imgui/imgui_internal.h	/^    int                     DragDropMouseButton;$/;"	m	struct:ImGuiContext
DragDropPayload	vendor/imgui/imgui_internal.h	/^    ImGuiPayload            DragDropPayload;$/;"	m	struct:ImGuiContext
DragDropPayloadBufHeap	vendor/imgui/imgui_internal.h	/^    ImVector<unsigned char> DragDropPayloadBufHeap;             \/\/ We don't expose the ImVector<> directly$/;"	m	struct:ImGuiContext
DragDropPayloadBufLocal	vendor/imgui/imgui_internal.h	/^    unsigned char           DragDropPayloadBufLocal[8];         \/\/ Local buffer for small payloads$/;"	m	struct:ImGuiContext
DragDropSourceFlags	vendor/imgui/imgui_internal.h	/^    ImGuiDragDropFlags      DragDropSourceFlags;$/;"	m	struct:ImGuiContext
DragDropSourceFrameCount	vendor/imgui/imgui_internal.h	/^    int                     DragDropSourceFrameCount;$/;"	m	struct:ImGuiContext
DragDropTargetId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 DragDropTargetId;$/;"	m	struct:ImGuiContext
DragDropTargetRect	vendor/imgui/imgui_internal.h	/^    ImRect                  DragDropTargetRect;$/;"	m	struct:ImGuiContext
DragDropWithinSourceOrTarget	vendor/imgui/imgui_internal.h	/^    bool                    DragDropWithinSourceOrTarget;$/;"	m	struct:ImGuiContext
DragFloat	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* format, float power)$/;"	f	class:ImGui
DragFloat2	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* format, float power)$/;"	f	class:ImGui
DragFloat3	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* format, float power)$/;"	f	class:ImGui
DragFloat4	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* format, float power)$/;"	f	class:ImGui
DragFloatRange2	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* format, const char* format_max, float power)$/;"	f	class:ImGui
DragInt	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* format)$/;"	f	class:ImGui
DragInt2	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* format)$/;"	f	class:ImGui
DragInt3	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* format)$/;"	f	class:ImGui
DragInt4	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* format)$/;"	f	class:ImGui
DragIntRange2	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* format, const char* format_max)$/;"	f	class:ImGui
DragScalar	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragScalar(const char* label, ImGuiDataType data_type, void* v, float v_speed, const void* v_min, const void* v_max, const char* format, float power)$/;"	f	class:ImGui
DragScalarN	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::DragScalarN(const char* label, ImGuiDataType data_type, void* v, int components, float v_speed, const void* v_min, const void* v_max, const char* format, float power)$/;"	f	class:ImGui
DragSpeedDefaultRatio	vendor/imgui/imgui_internal.h	/^    float                   DragSpeedDefaultRatio;              \/\/ If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio$/;"	m	struct:ImGuiContext
Draw	Renderer/Renderer.cpp	/^void Renderer::Draw(const VertexArray& vertexArray, const IndexBuffer&  indexBuffer, const Shader& shader) const {$/;"	f	class:Renderer
Draw	vendor/imgui/imgui.cpp	/^bool ImGuiTextFilter::Draw(const char* label, float width)$/;"	f	class:ImGuiTextFilter
Draw	vendor/imgui/imgui_demo.cpp	/^    void    Draw(const char* title, bool* p_open = NULL)$/;"	f	struct:ExampleAppLog
Draw	vendor/imgui/imgui_demo.cpp	/^    void    Draw(const char* title, bool* p_open)$/;"	f	struct:ExampleAppConsole
DrawData	vendor/imgui/imgui_internal.h	/^    ImDrawData              DrawData;                           \/\/ Main ImDrawData instance to pass render information to the user$/;"	m	struct:ImGuiContext
DrawDataBuilder	vendor/imgui/imgui_internal.h	/^    ImDrawDataBuilder       DrawDataBuilder;$/;"	m	struct:ImGuiContext
DrawList	vendor/imgui/imgui_internal.h	/^    ImDrawList*             DrawList;                           \/\/ == &DrawListInst (for backward compatibility reason with code using imgui_internal.h we keep this a pointer)$/;"	m	struct:ImGuiWindow
DrawListInst	vendor/imgui/imgui_internal.h	/^    ImDrawList              DrawListInst;$/;"	m	struct:ImGuiWindow
DrawListSharedData	vendor/imgui/imgui_internal.h	/^    ImDrawListSharedData    DrawListSharedData;$/;"	m	struct:ImGuiContext
DstFont	vendor/imgui/imgui.h	/^    ImFont*         DstFont;$/;"	m	struct:ImFontConfig
DstIndex	vendor/imgui/imgui_draw.cpp	/^    int                 DstIndex;           \/\/ Index into atlas->Fonts[] and dst_tmp_array[]$/;"	m	struct:ImFontBuildSrcData	file:
Dummy	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Dummy(const ImVec2& size)$/;"	f	class:ImGui
ElemCount	vendor/imgui/imgui.h	/^    unsigned int    ElemCount;              \/\/ Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].$/;"	m	struct:ImDrawCmd
EmitItem	vendor/imgui/imgui_internal.h	/^    bool        EmitItem;$/;"	m	struct:ImGuiGroupData
EmptyString	vendor/imgui/imgui.cpp	/^char ImGuiTextBuffer::EmptyString[1] = { 0 };$/;"	m	class:ImGuiTextBuffer	file:
EmptyString	vendor/imgui/imgui.h	/^    IMGUI_API static char EmptyString[1];$/;"	m	struct:ImGuiTextBuffer
End	vendor/imgui/imgui.cpp	/^void ImGui::End()$/;"	f	class:ImGui
End	vendor/imgui/imgui.cpp	/^void ImGuiListClipper::End()$/;"	f	class:ImGuiListClipper
EndChild	vendor/imgui/imgui.cpp	/^void ImGui::EndChild()$/;"	f	class:ImGui
EndChildFrame	vendor/imgui/imgui.cpp	/^void ImGui::EndChildFrame()$/;"	f	class:ImGui
EndColumns	vendor/imgui/imgui_widgets.cpp	/^void ImGui::EndColumns()$/;"	f	class:ImGui
EndCombo	vendor/imgui/imgui_widgets.cpp	/^void ImGui::EndCombo()$/;"	f	class:ImGui
EndDragDropSource	vendor/imgui/imgui.cpp	/^void ImGui::EndDragDropSource()$/;"	f	class:ImGui
EndDragDropTarget	vendor/imgui/imgui.cpp	/^void ImGui::EndDragDropTarget()$/;"	f	class:ImGui
EndFrame	vendor/imgui/imgui.cpp	/^void ImGui::EndFrame()$/;"	f	class:ImGui
EndGroup	vendor/imgui/imgui.cpp	/^void ImGui::EndGroup()$/;"	f	class:ImGui
EndMainMenuBar	vendor/imgui/imgui_widgets.cpp	/^void ImGui::EndMainMenuBar()$/;"	f	class:ImGui
EndMenu	vendor/imgui/imgui_widgets.cpp	/^void ImGui::EndMenu()$/;"	f	class:ImGui
EndMenuBar	vendor/imgui/imgui_widgets.cpp	/^void ImGui::EndMenuBar()$/;"	f	class:ImGui
EndPopup	vendor/imgui/imgui.cpp	/^void ImGui::EndPopup()$/;"	f	class:ImGui
EndTabBar	vendor/imgui/imgui_widgets.cpp	/^void    ImGui::EndTabBar()$/;"	f	class:ImGui
EndTabItem	vendor/imgui/imgui_widgets.cpp	/^void    ImGui::EndTabItem()$/;"	f	class:ImGui
EndTooltip	vendor/imgui/imgui.cpp	/^void ImGui::EndTooltip()$/;"	f	class:ImGui
EventChar	vendor/imgui/imgui.h	/^    ImWchar             EventChar;      \/\/ Character input                      \/\/ Read-write   \/\/ [CharFilter] Replace character with another one, or set to zero to drop. return 1 is equivalent to setting EventChar=0;$/;"	m	struct:ImGuiInputTextCallbackData
EventFlag	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags EventFlag;      \/\/ One ImGuiInputTextFlags_Callback*    \/\/ Read-only$/;"	m	struct:ImGuiInputTextCallbackData
EventKey	vendor/imgui/imgui.h	/^    ImGuiKey            EventKey;       \/\/ Key pressed (Up\/Down\/TAB)            \/\/ Read-only    \/\/ [Completion,History]$/;"	m	struct:ImGuiInputTextCallbackData
ExampleAppConsole	vendor/imgui/imgui_demo.cpp	/^    ExampleAppConsole()$/;"	f	struct:ExampleAppConsole
ExampleAppConsole	vendor/imgui/imgui_demo.cpp	/^struct ExampleAppConsole$/;"	s	file:
ExampleAppDocuments	vendor/imgui/imgui_demo.cpp	/^    ExampleAppDocuments()$/;"	f	struct:ExampleAppDocuments
ExampleAppDocuments	vendor/imgui/imgui_demo.cpp	/^struct ExampleAppDocuments$/;"	s	file:
ExampleAppLog	vendor/imgui/imgui_demo.cpp	/^    ExampleAppLog()$/;"	f	struct:ExampleAppLog
ExampleAppLog	vendor/imgui/imgui_demo.cpp	/^struct ExampleAppLog$/;"	s	file:
ExecCommand	vendor/imgui/imgui_demo.cpp	/^    void    ExecCommand(const char* command_line)$/;"	f	struct:ExampleAppConsole
Expand	vendor/imgui/imgui_internal.h	/^    void        Expand(const ImVec2& amount)        { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }$/;"	f	struct:ImRect
Expand	vendor/imgui/imgui_internal.h	/^    void        Expand(const float amount)          { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }$/;"	f	struct:ImRect
FAST_BITS	vendor/stb_image/stb_image.h	1753;"	d
FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA	vendor/imgui/imgui_draw.cpp	/^static const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =$/;"	v	file:
FONT_ATLAS_DEFAULT_TEX_DATA_H	vendor/imgui/imgui_draw.cpp	/^const int FONT_ATLAS_DEFAULT_TEX_DATA_H      = 27;$/;"	v
FONT_ATLAS_DEFAULT_TEX_DATA_ID	vendor/imgui/imgui_draw.cpp	/^const unsigned int FONT_ATLAS_DEFAULT_TEX_DATA_ID = 0x80000000;$/;"	v
FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS	vendor/imgui/imgui_draw.cpp	/^static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =$/;"	v	file:
FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF	vendor/imgui/imgui_draw.cpp	/^const int FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF = 108;$/;"	v
FallbackAdvanceX	vendor/imgui/imgui.h	/^    float                       FallbackAdvanceX;   \/\/ 4     \/\/ out \/\/ = FallbackGlyph->AdvanceX$/;"	m	struct:ImFont
FallbackChar	vendor/imgui/imgui.h	/^    ImWchar                     FallbackChar;       \/\/ 2     \/\/ in  \/\/ = '?'      \/\/ Replacement glyph if one isn't found. Only set via SetFallbackChar()$/;"	m	struct:ImFont
FallbackGlyph	vendor/imgui/imgui.h	/^    const ImFontGlyph*          FallbackGlyph;      \/\/ 4-8   \/\/ out \/\/ = FindGlyph(FontFallbackChar)$/;"	m	struct:ImFont
Filter	vendor/imgui/imgui_demo.cpp	/^    ImGuiTextFilter       Filter;$/;"	m	struct:ExampleAppConsole	file:
Filter	vendor/imgui/imgui_demo.cpp	/^    ImGuiTextFilter     Filter;$/;"	m	struct:ExampleAppLog	file:
Filters	vendor/imgui/imgui.h	/^    ImVector<ImGuiTextRange>Filters;$/;"	m	struct:ImGuiTextFilter
FindBestWindowPosForPopup	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::FindBestWindowPosForPopup(ImGuiWindow* window)$/;"	f	class:ImGui
FindBestWindowPosForPopupEx	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::FindBestWindowPosForPopupEx(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_outer, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy)$/;"	f	class:ImGui
FindGlyph	vendor/imgui/imgui_draw.cpp	/^const ImFontGlyph* ImFont::FindGlyph(ImWchar c) const$/;"	f	class:ImFont
FindGlyphNoFallback	vendor/imgui/imgui_draw.cpp	/^const ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const$/;"	f	class:ImFont
FindHoveredWindow	vendor/imgui/imgui.cpp	/^static void FindHoveredWindow()$/;"	f	file:
FindOrCreateColumns	vendor/imgui/imgui_widgets.cpp	/^ImGuiColumns* ImGui::FindOrCreateColumns(ImGuiWindow* window, ImGuiID id)$/;"	f	class:ImGui
FindOrCreateWindowSettings	vendor/imgui/imgui.cpp	/^ImGuiWindowSettings* ImGui::FindOrCreateWindowSettings(const char* name)$/;"	f	class:ImGui
FindRenderedTextEnd	vendor/imgui/imgui.cpp	/^const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)$/;"	f	class:ImGui
FindSettingsHandler	vendor/imgui/imgui.cpp	/^ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)$/;"	f	class:ImGui
FindWindowByID	vendor/imgui/imgui.cpp	/^ImGuiWindow* ImGui::FindWindowByID(ImGuiID id)$/;"	f	class:ImGui
FindWindowByName	vendor/imgui/imgui.cpp	/^ImGuiWindow* ImGui::FindWindowByName(const char* name)$/;"	f	class:ImGui
FindWindowFocusIndex	vendor/imgui/imgui.cpp	/^static int ImGui::FindWindowFocusIndex(ImGuiWindow* window) \/\/ FIXME-OPT O(N)$/;"	f	class:ImGui
FindWindowNavFocusable	vendor/imgui/imgui.cpp	/^static ImGuiWindow* FindWindowNavFocusable(int i_start, int i_stop, int dir) \/\/ FIXME-OPT O(N)$/;"	f	file:
FindWindowSettings	vendor/imgui/imgui.cpp	/^ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)$/;"	f	class:ImGui
Flags	vendor/imgui/imgui.h	/^    ImDrawListFlags         Flags;              \/\/ Flags, you may poke into these to adjust anti-aliasing settings per-primitive.$/;"	m	struct:ImDrawList
Flags	vendor/imgui/imgui.h	/^    ImFontAtlasFlags            Flags;              \/\/ Build flags (see ImFontAtlasFlags_)$/;"	m	struct:ImFontAtlas
Flags	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags Flags;          \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiInputTextCallbackData
Flags	vendor/imgui/imgui_internal.h	/^    ImGuiColumnsFlags   Flags;              \/\/ Not exposed$/;"	m	struct:ImGuiColumnData
Flags	vendor/imgui/imgui_internal.h	/^    ImGuiColumnsFlags   Flags;$/;"	m	struct:ImGuiColumns
Flags	vendor/imgui/imgui_internal.h	/^    ImGuiNextItemDataFlags      Flags;$/;"	m	struct:ImGuiNextItemData
Flags	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowDataFlags    Flags;$/;"	m	struct:ImGuiNextWindowData
Flags	vendor/imgui/imgui_internal.h	/^    ImGuiTabBarFlags    Flags;$/;"	m	struct:ImGuiTabBar
Flags	vendor/imgui/imgui_internal.h	/^    ImGuiTabItemFlags   Flags;$/;"	m	struct:ImGuiTabItem
Flags	vendor/imgui/imgui_internal.h	/^    ImGuiWindowFlags        Flags;                              \/\/ See enum ImGuiWindowFlags_$/;"	m	struct:ImGuiWindow
FlattenIntoSingleLayer	vendor/imgui/imgui.cpp	/^void ImDrawDataBuilder::FlattenIntoSingleLayer()$/;"	f	class:ImDrawDataBuilder
Floor	vendor/imgui/imgui_internal.h	/^    void        Floor()                             { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }$/;"	f	struct:ImRect
FocusCounterAll	vendor/imgui/imgui_internal.h	/^    int                     FocusCounterAll;        \/\/ Counter for focus\/tabbing system. Start at -1 and increase as assigned via FocusableItemRegister() (FIXME-NAV: Needs redesign)$/;"	m	struct:ImGuiWindowTempData
FocusCounterTab	vendor/imgui/imgui_internal.h	/^    int                     FocusCounterTab;        \/\/ (same, but only count widgets which you can Tab through)$/;"	m	struct:ImGuiWindowTempData
FocusRequestCurrCounterAll	vendor/imgui/imgui_internal.h	/^    int                     FocusRequestCurrCounterAll;         \/\/ Any item being requested for focus, stored as an index (we on layout to be stable between the frame pressing TAB and the next frame, semi-ouch)$/;"	m	struct:ImGuiContext
FocusRequestCurrCounterTab	vendor/imgui/imgui_internal.h	/^    int                     FocusRequestCurrCounterTab;         \/\/ Tab item being requested for focus, stored as an index$/;"	m	struct:ImGuiContext
FocusRequestCurrWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            FocusRequestCurrWindow;             \/\/$/;"	m	struct:ImGuiContext
FocusRequestNextCounterAll	vendor/imgui/imgui_internal.h	/^    int                     FocusRequestNextCounterAll;         \/\/ Stored for next frame$/;"	m	struct:ImGuiContext
FocusRequestNextCounterTab	vendor/imgui/imgui_internal.h	/^    int                     FocusRequestNextCounterTab;         \/\/ "$/;"	m	struct:ImGuiContext
FocusRequestNextWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            FocusRequestNextWindow;             \/\/$/;"	m	struct:ImGuiContext
FocusTabPressed	vendor/imgui/imgui_internal.h	/^    bool                    FocusTabPressed;                    \/\/$/;"	m	struct:ImGuiContext
FocusTopMostWindowUnderOne	vendor/imgui/imgui.cpp	/^void ImGui::FocusTopMostWindowUnderOne(ImGuiWindow* under_this_window, ImGuiWindow* ignore_window)$/;"	f	class:ImGui
FocusWindow	vendor/imgui/imgui.cpp	/^void ImGui::FocusWindow(ImGuiWindow* window)$/;"	f	class:ImGui
FocusableItemRegister	vendor/imgui/imgui.cpp	/^bool ImGui::FocusableItemRegister(ImGuiWindow* window, ImGuiID id)$/;"	f	class:ImGui
FocusableItemUnregister	vendor/imgui/imgui.cpp	/^void ImGui::FocusableItemUnregister(ImGuiWindow* window)$/;"	f	class:ImGui
Font	vendor/imgui/imgui.h	/^    ImFont*         Font;           \/\/ Input    \/\/ For custom font glyphs only (ID<0x10000): target font$/;"	m	struct:ImFontAtlasCustomRect
Font	vendor/imgui/imgui_internal.h	/^    ImFont*                 Font;                               \/\/ (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()$/;"	m	struct:ImGuiContext
Font	vendor/imgui/imgui_internal.h	/^    ImFont*         Font;                       \/\/ Current\/default font (optional, for simplified AddText overload)$/;"	m	struct:ImDrawListSharedData
FontAllowUserScaling	vendor/imgui/imgui.h	/^    bool        FontAllowUserScaling;           \/\/ = false          \/\/ Allow user scaling text of individual window with CTRL+Wheel.$/;"	m	struct:ImGuiIO
FontAtlasOwnedByContext	vendor/imgui/imgui_internal.h	/^    bool                    FontAtlasOwnedByContext;            \/\/ Io.Fonts-> is owned by the ImGuiContext and will be destructed along with it.$/;"	m	struct:ImGuiContext
FontBaseSize	vendor/imgui/imgui_internal.h	/^    float                   FontBaseSize;                       \/\/ (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.$/;"	m	struct:ImGuiContext
FontData	vendor/imgui/imgui.h	/^    void*           FontData;               \/\/          \/\/ TTF\/OTF data$/;"	m	struct:ImFontConfig
FontDataOwnedByAtlas	vendor/imgui/imgui.h	/^    bool            FontDataOwnedByAtlas;   \/\/ true     \/\/ TTF\/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).$/;"	m	struct:ImFontConfig
FontDataSize	vendor/imgui/imgui.h	/^    int             FontDataSize;           \/\/          \/\/ TTF\/OTF data size$/;"	m	struct:ImFontConfig
FontDefault	vendor/imgui/imgui.h	/^    ImFont*     FontDefault;                    \/\/ = NULL           \/\/ Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].$/;"	m	struct:ImGuiIO
FontGlobalScale	vendor/imgui/imgui.h	/^    float       FontGlobalScale;                \/\/ = 1.0f           \/\/ Global scale all fonts$/;"	m	struct:ImGuiIO
FontInfo	vendor/imgui/imgui_draw.cpp	/^    stbtt_fontinfo      FontInfo;$/;"	m	struct:ImFontBuildSrcData	file:
FontNo	vendor/imgui/imgui.h	/^    int             FontNo;                 \/\/ 0        \/\/ Index of font within TTF\/OTF file$/;"	m	struct:ImFontConfig
FontSize	vendor/imgui/imgui.h	/^    float                       FontSize;           \/\/ 4     \/\/ in  \/\/            \/\/ Height of characters\/line, set during loading (don't change after loading)$/;"	m	struct:ImFont
FontSize	vendor/imgui/imgui_internal.h	/^    float                   FontSize;                           \/\/ (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.$/;"	m	struct:ImGuiContext
FontSize	vendor/imgui/imgui_internal.h	/^    float           FontSize;                   \/\/ Current\/default font size (optional, for simplified AddText overload)$/;"	m	struct:ImDrawListSharedData
FontStack	vendor/imgui/imgui_internal.h	/^    ImVector<ImFont*>       FontStack;                          \/\/ Stack for PushFont()\/PopFont()$/;"	m	struct:ImGuiContext
FontWindowScale	vendor/imgui/imgui_internal.h	/^    float                   FontWindowScale;                    \/\/ User scale multiplier per-window, via SetWindowFontScale()$/;"	m	struct:ImGuiWindow
Fonts	vendor/imgui/imgui.h	/^    ImFontAtlas*Fonts;                          \/\/ <auto>           \/\/ Font atlas: load, rasterize and pack one or more fonts into a single texture.$/;"	m	struct:ImGuiIO
Fonts	vendor/imgui/imgui.h	/^    ImVector<ImFont*>           Fonts;              \/\/ Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()\/PopFont() to change the current font.$/;"	m	struct:ImFontAtlas
ForegroundDrawList	vendor/imgui/imgui_internal.h	/^    ImDrawList              ForegroundDrawList;                 \/\/ Last draw list to be rendered. This is where we the render software mouse cursor (if io.MouseDrawCursor is set) and most debug overlays.$/;"	m	struct:ImGuiContext
FragmentSource	Shader/Shader.h	/^	std::string FragmentSource;$/;"	m	struct:ShaderProgramSource
FrameBorderSize	vendor/imgui/imgui.h	/^    float       FrameBorderSize;            \/\/ Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU\/GPU costly).$/;"	m	struct:ImGuiStyle
FrameCount	vendor/imgui/imgui_internal.h	/^    int                     FrameCount;$/;"	m	struct:ImGuiContext
FrameCountEnded	vendor/imgui/imgui_internal.h	/^    int                     FrameCountEnded;$/;"	m	struct:ImGuiContext
FrameCountRendered	vendor/imgui/imgui_internal.h	/^    int                     FrameCountRendered;$/;"	m	struct:ImGuiContext
FramePadding	vendor/imgui/imgui.h	/^    ImVec2      FramePadding;               \/\/ Padding within a framed rectangle (used by most widgets).$/;"	m	struct:ImGuiStyle
FramePadding	vendor/imgui/imgui_internal.h	/^    ImVec2              FramePadding;           \/\/ style.FramePadding locked at the time of BeginTabBar()$/;"	m	struct:ImGuiTabBar
FrameRounding	vendor/imgui/imgui.h	/^    float       FrameRounding;              \/\/ Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).$/;"	m	struct:ImGuiStyle
FrameScopeActive	vendor/imgui/imgui_internal.h	/^    bool                    FrameScopeActive;                   \/\/ Set by NewFrame(), cleared by EndFrame()$/;"	m	struct:ImGuiContext
FrameScopePushedImplicitWindow	vendor/imgui/imgui_internal.h	/^    bool                    FrameScopePushedImplicitWindow;     \/\/ Set by NewFrame(), cleared by EndFrame()$/;"	m	struct:ImGuiContext
FramebufferScale	vendor/imgui/imgui.h	/^    ImVec2          FramebufferScale;       \/\/ Amount of pixels for each unit of DisplaySize. Based on io.DisplayFramebufferScale. Generally (1,1) on normal display, (2,2) on OSX with Retina display.$/;"	m	struct:ImDrawData
Framerate	vendor/imgui/imgui.h	/^    float       Framerate;                      \/\/ Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames$/;"	m	struct:ImGuiIO
FramerateSecPerFrame	vendor/imgui/imgui_internal.h	/^    float                   FramerateSecPerFrame[120];          \/\/ Calculate estimate of framerate for user over the last 2 seconds.$/;"	m	struct:ImGuiContext
FramerateSecPerFrameAccum	vendor/imgui/imgui_internal.h	/^    float                   FramerateSecPerFrameAccum;$/;"	m	struct:ImGuiContext
FramerateSecPerFrameIdx	vendor/imgui/imgui_internal.h	/^    int                     FramerateSecPerFrameIdx;$/;"	m	struct:ImGuiContext
FreeIdx	vendor/imgui/imgui_internal.h	/^    ImPoolIdx       FreeIdx;    \/\/ Next free idx to use$/;"	m	struct:ImPool
FreeWrapper	vendor/imgui/imgui.cpp	/^static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); IM_UNUSED(ptr); IM_ASSERT(0); }$/;"	f	file:
FreeWrapper	vendor/imgui/imgui.cpp	/^static void    FreeWrapper(void* ptr, void* user_data)        { IM_UNUSED(user_data); free(ptr); }$/;"	f	file:
GCrc32LookupTable	vendor/imgui/imgui.cpp	/^static const ImU32 GCrc32LookupTable[256] =$/;"	v	file:
GDataTypeInfo	vendor/imgui/imgui_widgets.cpp	/^static const ImGuiDataTypeInfo GDataTypeInfo[] =$/;"	v	file:
GENTYPE	vendor/glm/detail/qualifier.hpp	/^		static const genTypeEnum GENTYPE = GENTYPE_MAT;$/;"	m	struct:glm::detail::genTypeTrait
GENTYPE_MAT	vendor/glm/detail/qualifier.hpp	/^		GENTYPE_MAT,$/;"	e	enum:glm::detail::genTypeEnum
GENTYPE_QUAT	vendor/glm/detail/qualifier.hpp	/^		GENTYPE_QUAT$/;"	e	enum:glm::detail::genTypeEnum
GENTYPE_VEC	vendor/glm/detail/qualifier.hpp	/^		GENTYPE_VEC,$/;"	e	enum:glm::detail::genTypeEnum
GImAllocatorAllocFunc	vendor/imgui/imgui.cpp	/^static void*  (*GImAllocatorAllocFunc)(size_t size, void* user_data) = MallocWrapper;$/;"	v	file:
GImAllocatorFreeFunc	vendor/imgui/imgui.cpp	/^static void   (*GImAllocatorFreeFunc)(void* ptr, void* user_data) = FreeWrapper;$/;"	v	file:
GImAllocatorUserData	vendor/imgui/imgui.cpp	/^static void*    GImAllocatorUserData = NULL;$/;"	v	file:
GLFW_EXPOSE_NATIVE_WIN32	vendor/imgui/imgui_impl_glfw.cpp	44;"	d	file:
GLFW_HAS_PER_MONITOR_DPI	vendor/imgui/imgui_impl_glfw.cpp	50;"	d	file:
GLFW_HAS_VULKAN	vendor/imgui/imgui_impl_glfw.cpp	51;"	d	file:
GLFW_HAS_WINDOW_ALPHA	vendor/imgui/imgui_impl_glfw.cpp	49;"	d	file:
GLFW_HAS_WINDOW_HOVERED	vendor/imgui/imgui_impl_glfw.cpp	48;"	d	file:
GLFW_HAS_WINDOW_TOPMOST	vendor/imgui/imgui_impl_glfw.cpp	47;"	d	file:
GLM_ALIGNED_TYPEDEF	vendor/glm/detail/setup.hpp	512;"	d
GLM_ALIGNED_TYPEDEF	vendor/glm/detail/setup.hpp	515;"	d
GLM_ALIGNED_TYPEDEF	vendor/glm/detail/setup.hpp	518;"	d
GLM_ALIGNED_TYPEDEF	vendor/glm/detail/setup.hpp	521;"	d
GLM_ARCH	vendor/glm/simd/platform.h	255;"	d
GLM_ARCH	vendor/glm/simd/platform.h	257;"	d
GLM_ARCH	vendor/glm/simd/platform.h	260;"	d
GLM_ARCH	vendor/glm/simd/platform.h	263;"	d
GLM_ARCH	vendor/glm/simd/platform.h	266;"	d
GLM_ARCH	vendor/glm/simd/platform.h	269;"	d
GLM_ARCH	vendor/glm/simd/platform.h	272;"	d
GLM_ARCH	vendor/glm/simd/platform.h	275;"	d
GLM_ARCH	vendor/glm/simd/platform.h	278;"	d
GLM_ARCH	vendor/glm/simd/platform.h	281;"	d
GLM_ARCH	vendor/glm/simd/platform.h	285;"	d
GLM_ARCH	vendor/glm/simd/platform.h	287;"	d
GLM_ARCH	vendor/glm/simd/platform.h	289;"	d
GLM_ARCH	vendor/glm/simd/platform.h	291;"	d
GLM_ARCH	vendor/glm/simd/platform.h	293;"	d
GLM_ARCH	vendor/glm/simd/platform.h	295;"	d
GLM_ARCH	vendor/glm/simd/platform.h	297;"	d
GLM_ARCH	vendor/glm/simd/platform.h	299;"	d
GLM_ARCH	vendor/glm/simd/platform.h	301;"	d
GLM_ARCH	vendor/glm/simd/platform.h	303;"	d
GLM_ARCH	vendor/glm/simd/platform.h	305;"	d
GLM_ARCH	vendor/glm/simd/platform.h	307;"	d
GLM_ARCH	vendor/glm/simd/platform.h	309;"	d
GLM_ARCH	vendor/glm/simd/platform.h	313;"	d
GLM_ARCH	vendor/glm/simd/platform.h	315;"	d
GLM_ARCH	vendor/glm/simd/platform.h	317;"	d
GLM_ARCH	vendor/glm/simd/platform.h	319;"	d
GLM_ARCH	vendor/glm/simd/platform.h	321;"	d
GLM_ARCH_ARM	vendor/glm/simd/platform.h	249;"	d
GLM_ARCH_ARM_BIT	vendor/glm/simd/platform.h	224;"	d
GLM_ARCH_AVX	vendor/glm/simd/platform.h	247;"	d
GLM_ARCH_AVX2	vendor/glm/simd/platform.h	248;"	d
GLM_ARCH_AVX2_BIT	vendor/glm/simd/platform.h	237;"	d
GLM_ARCH_AVX_BIT	vendor/glm/simd/platform.h	236;"	d
GLM_ARCH_MIPS	vendor/glm/simd/platform.h	251;"	d
GLM_ARCH_MIPS_BIT	vendor/glm/simd/platform.h	222;"	d
GLM_ARCH_NEON	vendor/glm/simd/platform.h	250;"	d
GLM_ARCH_NEON_BIT	vendor/glm/simd/platform.h	229;"	d
GLM_ARCH_PPC	vendor/glm/simd/platform.h	252;"	d
GLM_ARCH_PPC_BIT	vendor/glm/simd/platform.h	223;"	d
GLM_ARCH_SIMD_BIT	vendor/glm/simd/platform.h	227;"	d
GLM_ARCH_SSE	vendor/glm/simd/platform.h	241;"	d
GLM_ARCH_SSE2	vendor/glm/simd/platform.h	242;"	d
GLM_ARCH_SSE2_BIT	vendor/glm/simd/platform.h	231;"	d
GLM_ARCH_SSE3	vendor/glm/simd/platform.h	243;"	d
GLM_ARCH_SSE3_BIT	vendor/glm/simd/platform.h	232;"	d
GLM_ARCH_SSE41	vendor/glm/simd/platform.h	245;"	d
GLM_ARCH_SSE41_BIT	vendor/glm/simd/platform.h	234;"	d
GLM_ARCH_SSE42	vendor/glm/simd/platform.h	246;"	d
GLM_ARCH_SSE42_BIT	vendor/glm/simd/platform.h	235;"	d
GLM_ARCH_SSE_BIT	vendor/glm/simd/platform.h	230;"	d
GLM_ARCH_SSSE3	vendor/glm/simd/platform.h	244;"	d
GLM_ARCH_SSSE3_BIT	vendor/glm/simd/platform.h	233;"	d
GLM_ARCH_UNKNOWN	vendor/glm/simd/platform.h	239;"	d
GLM_ARCH_X86	vendor/glm/simd/platform.h	240;"	d
GLM_ARCH_X86_BIT	vendor/glm/simd/platform.h	225;"	d
GLM_CLIP_CONTROL_LH_BIT	vendor/glm/detail/setup.hpp	485;"	d
GLM_CLIP_CONTROL_LH_NO	vendor/glm/detail/setup.hpp	489;"	d
GLM_CLIP_CONTROL_LH_ZO	vendor/glm/detail/setup.hpp	488;"	d
GLM_CLIP_CONTROL_NO_BIT	vendor/glm/detail/setup.hpp	484;"	d
GLM_CLIP_CONTROL_RH_BIT	vendor/glm/detail/setup.hpp	486;"	d
GLM_CLIP_CONTROL_RH_NO	vendor/glm/detail/setup.hpp	491;"	d
GLM_CLIP_CONTROL_RH_ZO	vendor/glm/detail/setup.hpp	490;"	d
GLM_CLIP_CONTROL_ZO_BIT	vendor/glm/detail/setup.hpp	483;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	105;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	107;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	109;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	111;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	122;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	124;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	126;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	135;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	137;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	139;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	145;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	147;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	149;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	151;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	153;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	155;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	157;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	159;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	161;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	163;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	172;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	174;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	176;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	178;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	180;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	182;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	184;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	192;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	194;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	196;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	198;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	200;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	202;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	204;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	206;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	210;"	d
GLM_COMPILER	vendor/glm/simd/platform.h	99;"	d
GLM_COMPILER_CLANG	vendor/glm/simd/platform.h	82;"	d
GLM_COMPILER_CLANG34	vendor/glm/simd/platform.h	83;"	d
GLM_COMPILER_CLANG35	vendor/glm/simd/platform.h	84;"	d
GLM_COMPILER_CLANG36	vendor/glm/simd/platform.h	85;"	d
GLM_COMPILER_CLANG37	vendor/glm/simd/platform.h	86;"	d
GLM_COMPILER_CLANG38	vendor/glm/simd/platform.h	87;"	d
GLM_COMPILER_CLANG39	vendor/glm/simd/platform.h	88;"	d
GLM_COMPILER_CLANG40	vendor/glm/simd/platform.h	89;"	d
GLM_COMPILER_CLANG41	vendor/glm/simd/platform.h	90;"	d
GLM_COMPILER_CLANG42	vendor/glm/simd/platform.h	91;"	d
GLM_COMPILER_CUDA	vendor/glm/simd/platform.h	76;"	d
GLM_COMPILER_CUDA70	vendor/glm/simd/platform.h	77;"	d
GLM_COMPILER_CUDA75	vendor/glm/simd/platform.h	78;"	d
GLM_COMPILER_CUDA80	vendor/glm/simd/platform.h	79;"	d
GLM_COMPILER_GCC	vendor/glm/simd/platform.h	65;"	d
GLM_COMPILER_GCC46	vendor/glm/simd/platform.h	66;"	d
GLM_COMPILER_GCC47	vendor/glm/simd/platform.h	67;"	d
GLM_COMPILER_GCC48	vendor/glm/simd/platform.h	68;"	d
GLM_COMPILER_GCC49	vendor/glm/simd/platform.h	69;"	d
GLM_COMPILER_GCC5	vendor/glm/simd/platform.h	70;"	d
GLM_COMPILER_GCC6	vendor/glm/simd/platform.h	71;"	d
GLM_COMPILER_GCC7	vendor/glm/simd/platform.h	72;"	d
GLM_COMPILER_GCC8	vendor/glm/simd/platform.h	73;"	d
GLM_COMPILER_INTEL	vendor/glm/simd/platform.h	48;"	d
GLM_COMPILER_INTEL14	vendor/glm/simd/platform.h	49;"	d
GLM_COMPILER_INTEL15	vendor/glm/simd/platform.h	50;"	d
GLM_COMPILER_INTEL16	vendor/glm/simd/platform.h	51;"	d
GLM_COMPILER_INTEL17	vendor/glm/simd/platform.h	52;"	d
GLM_COMPILER_UNKNOWN	vendor/glm/simd/platform.h	45;"	d
GLM_COMPILER_VC	vendor/glm/simd/platform.h	55;"	d
GLM_COMPILER_VC12	vendor/glm/simd/platform.h	56;"	d
GLM_COMPILER_VC14	vendor/glm/simd/platform.h	57;"	d
GLM_COMPILER_VC15	vendor/glm/simd/platform.h	58;"	d
GLM_COMPILER_VC15_3	vendor/glm/simd/platform.h	59;"	d
GLM_COMPILER_VC15_5	vendor/glm/simd/platform.h	60;"	d
GLM_COMPILER_VC15_6	vendor/glm/simd/platform.h	61;"	d
GLM_COMPILER_VC15_7	vendor/glm/simd/platform.h	62;"	d
GLM_CONFIG_ALIGNED_GENTYPES	vendor/glm/detail/setup.hpp	784;"	d
GLM_CONFIG_ANONYMOUS_STRUCT	vendor/glm/detail/setup.hpp	793;"	d
GLM_CONFIG_CLIP_CONTROL	vendor/glm/detail/setup.hpp	495;"	d
GLM_CONFIG_CLIP_CONTROL	vendor/glm/detail/setup.hpp	497;"	d
GLM_CONFIG_CLIP_CONTROL	vendor/glm/detail/setup.hpp	501;"	d
GLM_CONFIG_CLIP_CONTROL	vendor/glm/detail/setup.hpp	503;"	d
GLM_CONFIG_CONSTEXP	vendor/glm/detail/setup.hpp	560;"	d
GLM_CONFIG_CTOR_INIT	vendor/glm/detail/setup.hpp	745;"	d
GLM_CONFIG_DEFAULTED_FUNCTIONS	vendor/glm/detail/setup.hpp	765;"	d
GLM_CONFIG_LENGTH_TYPE	vendor/glm/detail/setup.hpp	541;"	d
GLM_CONFIG_LENGTH_TYPE	vendor/glm/detail/setup.hpp	543;"	d
GLM_CONFIG_NULLPTR	vendor/glm/detail/setup.hpp	385;"	d
GLM_CONFIG_NULLPTR	vendor/glm/detail/setup.hpp	387;"	d
GLM_CONFIG_PRECISION_BOOL	vendor/glm/detail/setup.hpp	815;"	d
GLM_CONFIG_PRECISION_DOUBLE	vendor/glm/detail/setup.hpp	855;"	d
GLM_CONFIG_PRECISION_FLOAT	vendor/glm/detail/setup.hpp	845;"	d
GLM_CONFIG_PRECISION_INT	vendor/glm/detail/setup.hpp	825;"	d
GLM_CONFIG_PRECISION_UINT	vendor/glm/detail/setup.hpp	835;"	d
GLM_CONFIG_SIMD	vendor/glm/detail/setup.hpp	756;"	d
GLM_CONFIG_SWIZZLE	vendor/glm/detail/setup.hpp	459;"	d
GLM_CONFIG_SWIZZLE	vendor/glm/detail/setup.hpp	461;"	d
GLM_CONFIG_SWIZZLE	vendor/glm/detail/setup.hpp	463;"	d
GLM_CONFIG_UNRESTRICTED_GENTYPE	vendor/glm/detail/setup.hpp	472;"	d
GLM_CONFIG_UNRESTRICTED_GENTYPE	vendor/glm/detail/setup.hpp	474;"	d
GLM_CONFIG_XYZW_ONLY	vendor/glm/detail/setup.hpp	732;"	d
GLM_CONSTEXPR	vendor/glm/detail/setup.hpp	291;"	d
GLM_CONSTEXPR	vendor/glm/detail/setup.hpp	293;"	d
GLM_COUNTOF	vendor/glm/detail/setup.hpp	570;"	d
GLM_CTOR_INITIALISATION	vendor/glm/detail/setup.hpp	742;"	d
GLM_CTOR_INITIALIZER_LIST	vendor/glm/detail/setup.hpp	741;"	d
GLM_CTOR_INIT_DISABLE	vendor/glm/detail/setup.hpp	740;"	d
GLM_CUDA_FUNC_DECL	vendor/glm/detail/setup.hpp	412;"	d
GLM_CUDA_FUNC_DECL	vendor/glm/detail/setup.hpp	415;"	d
GLM_CUDA_FUNC_DEF	vendor/glm/detail/setup.hpp	411;"	d
GLM_CUDA_FUNC_DEF	vendor/glm/detail/setup.hpp	414;"	d
GLM_CXX11_ACCESS_CONTROL_SFINAE	vendor/glm/detail/_features.hpp	263;"	d
GLM_CXX11_ALIAS_TEMPLATE	vendor/glm/detail/_features.hpp	267;"	d
GLM_CXX11_ALIGNAS	vendor/glm/detail/_features.hpp	271;"	d
GLM_CXX11_ATTRIBUTES	vendor/glm/detail/_features.hpp	275;"	d
GLM_CXX11_AUTO_TYPE	vendor/glm/detail/_features.hpp	367;"	d
GLM_CXX11_CONSTEXPR	vendor/glm/detail/_features.hpp	279;"	d
GLM_CXX11_DECLTYPE	vendor/glm/detail/_features.hpp	283;"	d
GLM_CXX11_DEFAULTED_FUNCTIONS	vendor/glm/detail/_features.hpp	291;"	d
GLM_CXX11_DEFAULT_FUNCTION_TEMPLATE_ARGS	vendor/glm/detail/_features.hpp	287;"	d
GLM_CXX11_DELEGATING_CONSTRUCTORS	vendor/glm/detail/_features.hpp	295;"	d
GLM_CXX11_DELETED_FUNCTIONS	vendor/glm/detail/_features.hpp	299;"	d
GLM_CXX11_EXPLICIT_CONVERSIONS	vendor/glm/detail/_features.hpp	303;"	d
GLM_CXX11_GENERALIZED_INITIALIZERS	vendor/glm/detail/_features.hpp	307;"	d
GLM_CXX11_IMPLICIT_MOVES	vendor/glm/detail/_features.hpp	311;"	d
GLM_CXX11_INHERITING_CONSTRUCTORS	vendor/glm/detail/_features.hpp	315;"	d
GLM_CXX11_INLINE_NAMESPACES	vendor/glm/detail/_features.hpp	319;"	d
GLM_CXX11_LAMBDAS	vendor/glm/detail/_features.hpp	323;"	d
GLM_CXX11_LOCAL_TYPE_TEMPLATE_ARGS	vendor/glm/detail/_features.hpp	327;"	d
GLM_CXX11_NOEXCEPT	vendor/glm/detail/_features.hpp	331;"	d
GLM_CXX11_NONSTATIC_MEMBER_INIT	vendor/glm/detail/_features.hpp	335;"	d
GLM_CXX11_NULLPTR	vendor/glm/detail/_features.hpp	339;"	d
GLM_CXX11_OVERRIDE_CONTROL	vendor/glm/detail/_features.hpp	343;"	d
GLM_CXX11_RANGE_FOR	vendor/glm/detail/_features.hpp	351;"	d
GLM_CXX11_RAW_STRING_LITERALS	vendor/glm/detail/_features.hpp	355;"	d
GLM_CXX11_REFERENCE_QUALIFIED_FUNCTIONS	vendor/glm/detail/_features.hpp	347;"	d
GLM_CXX11_RVALUE_REFERENCES	vendor/glm/detail/_features.hpp	359;"	d
GLM_CXX11_STATIC_ASSERT	vendor/glm/detail/_features.hpp	251;"	d
GLM_CXX11_STATIC_ASSERT	vendor/glm/detail/_features.hpp	363;"	d
GLM_CXX11_STRONG_ENUMS	vendor/glm/detail/_features.hpp	371;"	d
GLM_CXX11_TRAILING_RETURN	vendor/glm/detail/_features.hpp	375;"	d
GLM_CXX11_UNICODE_LITERALS	vendor/glm/detail/_features.hpp	379;"	d
GLM_CXX11_UNRESTRICTED_UNIONS	vendor/glm/detail/_features.hpp	383;"	d
GLM_CXX11_USER_LITERALS	vendor/glm/detail/_features.hpp	387;"	d
GLM_CXX11_VARIADIC_TEMPLATES	vendor/glm/detail/_features.hpp	391;"	d
GLM_CXX98_EXCEPTIONS	vendor/glm/detail/_features.hpp	255;"	d
GLM_CXX98_RTTI	vendor/glm/detail/_features.hpp	259;"	d
GLM_DEFAULT	vendor/glm/detail/setup.hpp	766;"	d
GLM_DEFAULT	vendor/glm/detail/type_mat2x2.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;$/;"	m	struct:glm::mat
GLM_DEFAULT	vendor/glm/detail/type_mat2x3.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;$/;"	m	struct:glm::mat
GLM_DEFAULT	vendor/glm/detail/type_mat2x4.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;$/;"	m	struct:glm::mat
GLM_DEFAULT	vendor/glm/detail/type_mat3x2.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;$/;"	m	struct:glm::mat
GLM_DEFAULT	vendor/glm/detail/type_mat3x3.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;$/;"	m	struct:glm::mat
GLM_DEFAULT	vendor/glm/detail/type_mat3x4.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;$/;"	m	struct:glm::mat
GLM_DEFAULT	vendor/glm/detail/type_mat4x2.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;$/;"	m	struct:glm::mat
GLM_DEFAULT	vendor/glm/detail/type_mat4x3.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;$/;"	m	struct:glm::mat
GLM_DEFAULT	vendor/glm/detail/type_mat4x4.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR mat() GLM_DEFAULT;$/;"	m	struct:glm::mat
GLM_DEFAULT	vendor/glm/detail/type_quat.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR qua() GLM_DEFAULT;$/;"	m	struct:glm::qua
GLM_DEFAULT	vendor/glm/detail/type_quat.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR qua(qua<T, Q> const& q) GLM_DEFAULT;$/;"	m	struct:glm::qua
GLM_DEFAULT	vendor/glm/detail/type_quat.hpp	/^		GLM_FUNC_DECL qua<T, Q>& operator=(qua<T, Q> const& q) GLM_DEFAULT;$/;"	m	struct:glm::qua
GLM_DEFAULT	vendor/glm/detail/type_vec1.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec() GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec1.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec(vec const& v) GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec1.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec<1, T, Q> & operator=(vec const& v) GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec2.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec() GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec2.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec(vec const& v) GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec2.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec<2, T, Q> & operator=(vec const& v) GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec3.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec() GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec3.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec(vec const& v) GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec3.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec<3, T, Q>& operator=(vec<3, T, Q> const& v) GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec4.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec() GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec4.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec(vec<4, T, Q> const& v) GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/detail/type_vec4.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR vec<4, T, Q>& operator=(vec<4, T, Q> const& v) GLM_DEFAULT;$/;"	m	struct:glm::vec
GLM_DEFAULT	vendor/glm/gtx/dual_quaternion.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR tdualquat() GLM_DEFAULT;$/;"	m	struct:glm::tdualquat
GLM_DEFAULT	vendor/glm/gtx/dual_quaternion.hpp	/^		GLM_FUNC_DECL GLM_CONSTEXPR tdualquat(tdualquat<T, Q> const& d) GLM_DEFAULT;$/;"	m	struct:glm::tdualquat
GLM_DEFAULT	vendor/glm/gtx/dual_quaternion.hpp	/^		GLM_FUNC_DECL tdualquat<T, Q> & operator=(tdualquat<T, Q> const& m) GLM_DEFAULT;$/;"	m	struct:glm::tdualquat
GLM_DEPRECATED	vendor/glm/detail/setup.hpp	511;"	d
GLM_DEPRECATED	vendor/glm/detail/setup.hpp	514;"	d
GLM_DEPRECATED	vendor/glm/detail/setup.hpp	517;"	d
GLM_DEPRECATED	vendor/glm/detail/setup.hpp	520;"	d
GLM_DISABLE	vendor/glm/detail/setup.hpp	18;"	d
GLM_ENABLE	vendor/glm/detail/setup.hpp	19;"	d
GLM_ENABLE_EXPERIMENTAL	vendor/glm/detail/glm.cpp	5;"	d	file:
GLM_EXPLICIT	vendor/glm/detail/setup.hpp	527;"	d
GLM_EXPLICIT	vendor/glm/detail/setup.hpp	529;"	d
GLM_FORCE_ALIGNED_GENTYPES	vendor/glm/detail/setup.hpp	780;"	d
GLM_FORCE_DEFAULT_ALIGNED_GENTYPES	vendor/glm/detail/setup.hpp	776;"	d
GLM_FORCE_INTRINSICS	vendor/glm/simd/platform.h	258;"	d
GLM_FORCE_INTRINSICS	vendor/glm/simd/platform.h	261;"	d
GLM_FORCE_INTRINSICS	vendor/glm/simd/platform.h	264;"	d
GLM_FORCE_INTRINSICS	vendor/glm/simd/platform.h	267;"	d
GLM_FORCE_INTRINSICS	vendor/glm/simd/platform.h	270;"	d
GLM_FORCE_INTRINSICS	vendor/glm/simd/platform.h	273;"	d
GLM_FORCE_INTRINSICS	vendor/glm/simd/platform.h	276;"	d
GLM_FORCE_INTRINSICS	vendor/glm/simd/platform.h	279;"	d
GLM_FORCE_INTRINSICS	vendor/glm/simd/platform.h	282;"	d
GLM_FORCE_SWIZZLE	vendor/glm/detail/setup.hpp	450;"	d
GLM_FORCE_SWIZZLE	vendor/glm/detail/setup.hpp	455;"	d
GLM_FUNC_DECL	vendor/glm/detail/setup.hpp	437;"	d
GLM_FUNC_QUALIFIER	vendor/glm/detail/setup.hpp	438;"	d
GLM_HAS_ALIGNOF	vendor/glm/detail/setup.hpp	266;"	d
GLM_HAS_ALIGNOF	vendor/glm/detail/setup.hpp	268;"	d
GLM_HAS_ALIGNOF	vendor/glm/detail/setup.hpp	270;"	d
GLM_HAS_ASSIGNABLE	vendor/glm/detail/setup.hpp	319;"	d
GLM_HAS_ASSIGNABLE	vendor/glm/detail/setup.hpp	321;"	d
GLM_HAS_BITSCAN_WINDOWS	vendor/glm/detail/setup.hpp	340;"	d
GLM_HAS_BITSCAN_WINDOWS	vendor/glm/detail/setup.hpp	344;"	d
GLM_HAS_CONSTEXPR	vendor/glm/detail/setup.hpp	279;"	d
GLM_HAS_CONSTEXPR	vendor/glm/detail/setup.hpp	281;"	d
GLM_HAS_CONSTEXPR	vendor/glm/detail/setup.hpp	283;"	d
GLM_HAS_CONSTEXPR	vendor/glm/detail/setup.hpp	285;"	d
GLM_HAS_CXX11_STL	vendor/glm/detail/setup.hpp	144;"	d
GLM_HAS_CXX11_STL	vendor/glm/detail/setup.hpp	148;"	d
GLM_HAS_CXX11_STL	vendor/glm/detail/setup.hpp	150;"	d
GLM_HAS_CXX11_STL	vendor/glm/detail/setup.hpp	153;"	d
GLM_HAS_CXX11_STL	vendor/glm/detail/setup.hpp	155;"	d
GLM_HAS_DEFAULTED_FUNCTIONS	vendor/glm/detail/setup.hpp	207;"	d
GLM_HAS_DEFAULTED_FUNCTIONS	vendor/glm/detail/setup.hpp	209;"	d
GLM_HAS_DEFAULTED_FUNCTIONS	vendor/glm/detail/setup.hpp	211;"	d
GLM_HAS_EXPLICIT_CONVERSION_OPERATORS	vendor/glm/detail/setup.hpp	230;"	d
GLM_HAS_EXPLICIT_CONVERSION_OPERATORS	vendor/glm/detail/setup.hpp	232;"	d
GLM_HAS_EXPLICIT_CONVERSION_OPERATORS	vendor/glm/detail/setup.hpp	234;"	d
GLM_HAS_EXTENDED_INTEGER_TYPE	vendor/glm/detail/setup.hpp	174;"	d
GLM_HAS_EXTENDED_INTEGER_TYPE	vendor/glm/detail/setup.hpp	176;"	d
GLM_HAS_IF_CONSTEXPR	vendor/glm/detail/setup.hpp	299;"	d
GLM_HAS_IF_CONSTEXPR	vendor/glm/detail/setup.hpp	301;"	d
GLM_HAS_IF_CONSTEXPR	vendor/glm/detail/setup.hpp	303;"	d
GLM_HAS_IF_CONSTEXPR	vendor/glm/detail/setup.hpp	305;"	d
GLM_HAS_IF_CONSTEXPR	vendor/glm/detail/setup.hpp	308;"	d
GLM_HAS_INITIALIZER_LISTS	vendor/glm/detail/setup.hpp	184;"	d
GLM_HAS_INITIALIZER_LISTS	vendor/glm/detail/setup.hpp	186;"	d
GLM_HAS_INITIALIZER_LISTS	vendor/glm/detail/setup.hpp	188;"	d
GLM_HAS_MAKE_SIGNED	vendor/glm/detail/setup.hpp	331;"	d
GLM_HAS_MAKE_SIGNED	vendor/glm/detail/setup.hpp	333;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	352;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	354;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	356;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	358;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	362;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	364;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	367;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	370;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	372;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	375;"	d
GLM_HAS_OPENMP	vendor/glm/detail/setup.hpp	378;"	d
GLM_HAS_RANGE_FOR	vendor/glm/detail/setup.hpp	254;"	d
GLM_HAS_RANGE_FOR	vendor/glm/detail/setup.hpp	256;"	d
GLM_HAS_RANGE_FOR	vendor/glm/detail/setup.hpp	258;"	d
GLM_HAS_RVALUE_REFERENCES	vendor/glm/detail/setup.hpp	219;"	d
GLM_HAS_RVALUE_REFERENCES	vendor/glm/detail/setup.hpp	221;"	d
GLM_HAS_RVALUE_REFERENCES	vendor/glm/detail/setup.hpp	223;"	d
GLM_HAS_STATIC_ASSERT	vendor/glm/detail/setup.hpp	163;"	d
GLM_HAS_STATIC_ASSERT	vendor/glm/detail/setup.hpp	165;"	d
GLM_HAS_STATIC_ASSERT	vendor/glm/detail/setup.hpp	167;"	d
GLM_HAS_TEMPLATE_ALIASES	vendor/glm/detail/setup.hpp	242;"	d
GLM_HAS_TEMPLATE_ALIASES	vendor/glm/detail/setup.hpp	244;"	d
GLM_HAS_TEMPLATE_ALIASES	vendor/glm/detail/setup.hpp	246;"	d
GLM_HAS_TRIVIAL_QUERIES	vendor/glm/detail/setup.hpp	327;"	d
GLM_HAS_UNRESTRICTED_UNIONS	vendor/glm/detail/setup.hpp	196;"	d
GLM_HAS_UNRESTRICTED_UNIONS	vendor/glm/detail/setup.hpp	198;"	d
GLM_HAS_UNRESTRICTED_UNIONS	vendor/glm/detail/setup.hpp	200;"	d
GLM_HIGHP	vendor/glm/detail/setup.hpp	810;"	d
GLM_IF_CONSTEXPR	vendor/glm/detail/setup.hpp	312;"	d
GLM_IF_CONSTEXPR	vendor/glm/detail/setup.hpp	314;"	d
GLM_IMPLEMENT_SCAL_MULT	vendor/glm/gtx/scalar_multiplication.hpp	41;"	d
GLM_IMPLEMENT_SCAL_MULT	vendor/glm/gtx/scalar_multiplication.hpp	74;"	d
GLM_INLINE	vendor/glm/detail/setup.hpp	420;"	d
GLM_INLINE	vendor/glm/detail/setup.hpp	423;"	d
GLM_INLINE	vendor/glm/detail/setup.hpp	426;"	d
GLM_INLINE	vendor/glm/detail/setup.hpp	429;"	d
GLM_INLINE	vendor/glm/detail/setup.hpp	433;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	100;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	119;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	121;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	123;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	125;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	127;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	129;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	131;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	84;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	86;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	89;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	92;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	95;"	d
GLM_LANG	vendor/glm/detail/setup.hpp	98;"	d
GLM_LANG_CXX03	vendor/glm/detail/setup.hpp	66;"	d
GLM_LANG_CXX03_FLAG	vendor/glm/detail/setup.hpp	56;"	d
GLM_LANG_CXX0X	vendor/glm/detail/setup.hpp	67;"	d
GLM_LANG_CXX0X_FLAG	vendor/glm/detail/setup.hpp	57;"	d
GLM_LANG_CXX11	vendor/glm/detail/setup.hpp	68;"	d
GLM_LANG_CXX11_FLAG	vendor/glm/detail/setup.hpp	58;"	d
GLM_LANG_CXX14	vendor/glm/detail/setup.hpp	69;"	d
GLM_LANG_CXX14_FLAG	vendor/glm/detail/setup.hpp	59;"	d
GLM_LANG_CXX17	vendor/glm/detail/setup.hpp	70;"	d
GLM_LANG_CXX17_FLAG	vendor/glm/detail/setup.hpp	60;"	d
GLM_LANG_CXX2A	vendor/glm/detail/setup.hpp	71;"	d
GLM_LANG_CXX2A_FLAG	vendor/glm/detail/setup.hpp	61;"	d
GLM_LANG_CXX98	vendor/glm/detail/setup.hpp	65;"	d
GLM_LANG_CXX98_FLAG	vendor/glm/detail/setup.hpp	55;"	d
GLM_LANG_CXXGNU	vendor/glm/detail/setup.hpp	73;"	d
GLM_LANG_CXXGNU_FLAG	vendor/glm/detail/setup.hpp	63;"	d
GLM_LANG_CXXMS	vendor/glm/detail/setup.hpp	72;"	d
GLM_LANG_CXXMS_FLAG	vendor/glm/detail/setup.hpp	62;"	d
GLM_LANG_EXT	vendor/glm/detail/setup.hpp	76;"	d
GLM_LANG_EXT	vendor/glm/detail/setup.hpp	78;"	d
GLM_LANG_EXT	vendor/glm/detail/setup.hpp	80;"	d
GLM_LANG_PLATFORM	vendor/glm/detail/setup.hpp	104;"	d
GLM_LANG_PLATFORM	vendor/glm/detail/setup.hpp	107;"	d
GLM_LANG_PLATFORM	vendor/glm/detail/setup.hpp	109;"	d
GLM_LANG_PLATFORM	vendor/glm/detail/setup.hpp	112;"	d
GLM_LANG_PLATFORM	vendor/glm/detail/setup.hpp	115;"	d
GLM_LANG_STL11_FORCED	vendor/glm/detail/setup.hpp	87;"	d
GLM_LANG_STL11_FORCED	vendor/glm/detail/setup.hpp	90;"	d
GLM_LANG_STL11_FORCED	vendor/glm/detail/setup.hpp	93;"	d
GLM_LANG_STL11_FORCED	vendor/glm/detail/setup.hpp	96;"	d
GLM_LENGTH_INT	vendor/glm/detail/setup.hpp	537;"	d
GLM_LENGTH_SIZE_T	vendor/glm/detail/setup.hpp	538;"	d
GLM_LOWP	vendor/glm/detail/setup.hpp	812;"	d
GLM_MEDIUMP	vendor/glm/detail/setup.hpp	811;"	d
GLM_MESSAGES	vendor/glm/detail/setup.hpp	25;"	d
GLM_MESSAGES	vendor/glm/detail/setup.hpp	27;"	d
GLM_MESSAGE_EXT_INCLUDED_DISPLAYED	vendor/glm/ext.hpp	12;"	d
GLM_MODEL	vendor/glm/detail/setup.hpp	39;"	d
GLM_MODEL	vendor/glm/detail/setup.hpp	41;"	d
GLM_MODEL	vendor/glm/detail/setup.hpp	43;"	d
GLM_MODEL_32	vendor/glm/simd/platform.h	94;"	d
GLM_MODEL_64	vendor/glm/simd/platform.h	95;"	d
GLM_MUTABLE	vendor/glm/detail/_swizzle_func.hpp	42;"	d
GLM_NEVER_INLINE	vendor/glm/detail/setup.hpp	421;"	d
GLM_NEVER_INLINE	vendor/glm/detail/setup.hpp	424;"	d
GLM_NEVER_INLINE	vendor/glm/detail/setup.hpp	427;"	d
GLM_NEVER_INLINE	vendor/glm/detail/setup.hpp	430;"	d
GLM_NEVER_INLINE	vendor/glm/detail/setup.hpp	434;"	d
GLM_NULLPTR	vendor/glm/detail/setup.hpp	391;"	d
GLM_NULLPTR	vendor/glm/detail/setup.hpp	393;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	19;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	21;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	23;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	25;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	27;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	29;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	31;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	33;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	35;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	37;"	d
GLM_PLATFORM	vendor/glm/simd/platform.h	39;"	d
GLM_PLATFORM_ANDROID	vendor/glm/simd/platform.h	11;"	d
GLM_PLATFORM_APPLE	vendor/glm/simd/platform.h	9;"	d
GLM_PLATFORM_CHROME_NACL	vendor/glm/simd/platform.h	12;"	d
GLM_PLATFORM_CYGWIN	vendor/glm/simd/platform.h	16;"	d
GLM_PLATFORM_LINUX	vendor/glm/simd/platform.h	8;"	d
GLM_PLATFORM_QNXNTO	vendor/glm/simd/platform.h	14;"	d
GLM_PLATFORM_UNIX	vendor/glm/simd/platform.h	13;"	d
GLM_PLATFORM_UNKNOWN	vendor/glm/simd/platform.h	6;"	d
GLM_PLATFORM_WINCE	vendor/glm/simd/platform.h	15;"	d
GLM_PLATFORM_WINDOWS	vendor/glm/simd/platform.h	7;"	d
GLM_SETUP_INCLUDED	vendor/glm/detail/setup.hpp	13;"	d
GLM_SILENT_WARNINGS	vendor/glm/detail/setup.hpp	802;"	d
GLM_STATIC_ASSERT	vendor/glm/detail/setup.hpp	400;"	d
GLM_STATIC_ASSERT	vendor/glm/detail/setup.hpp	402;"	d
GLM_STATIC_ASSERT	vendor/glm/detail/setup.hpp	404;"	d
GLM_SWIZZLE2_2_MEMBERS	vendor/glm/detail/_swizzle.hpp	307;"	d
GLM_SWIZZLE2_3_MEMBERS	vendor/glm/detail/_swizzle.hpp	313;"	d
GLM_SWIZZLE2_4_MEMBERS	vendor/glm/detail/_swizzle.hpp	323;"	d
GLM_SWIZZLE3_2_MEMBERS	vendor/glm/detail/_swizzle.hpp	341;"	d
GLM_SWIZZLE3_3_MEMBERS	vendor/glm/detail/_swizzle.hpp	352;"	d
GLM_SWIZZLE3_4_MEMBERS	vendor/glm/detail/_swizzle.hpp	381;"	d
GLM_SWIZZLE4_2_MEMBERS	vendor/glm/detail/_swizzle.hpp	464;"	d
GLM_SWIZZLE4_3_MEMBERS	vendor/glm/detail/_swizzle.hpp	482;"	d
GLM_SWIZZLE4_4_MEMBERS	vendor/glm/detail/_swizzle.hpp	548;"	d
GLM_SWIZZLE_DISABLED	vendor/glm/detail/setup.hpp	445;"	d
GLM_SWIZZLE_FUNCTION	vendor/glm/detail/setup.hpp	447;"	d
GLM_SWIZZLE_FUNCTION_1_ARGS	vendor/glm/detail/_swizzle.hpp	213;"	d
GLM_SWIZZLE_FUNCTION_2_ARGS	vendor/glm/detail/_swizzle.hpp	223;"	d
GLM_SWIZZLE_FUNCTION_2_ARGS_SCALAR	vendor/glm/detail/_swizzle.hpp	248;"	d
GLM_SWIZZLE_GEN_REF2_FROM_VEC2_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	44;"	d
GLM_SWIZZLE_GEN_REF2_FROM_VEC3_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	53;"	d
GLM_SWIZZLE_GEN_REF2_FROM_VEC4_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	78;"	d
GLM_SWIZZLE_GEN_REF3_FROM_VEC3_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	61;"	d
GLM_SWIZZLE_GEN_REF3_FROM_VEC4_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	92;"	d
GLM_SWIZZLE_GEN_REF4_FROM_VEC4_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	118;"	d
GLM_SWIZZLE_GEN_REF_FROM_VEC2	vendor/glm/detail/_swizzle_func.hpp	48;"	d
GLM_SWIZZLE_GEN_REF_FROM_VEC3	vendor/glm/detail/_swizzle_func.hpp	73;"	d
GLM_SWIZZLE_GEN_REF_FROM_VEC3_COMP	vendor/glm/detail/_swizzle_func.hpp	69;"	d
GLM_SWIZZLE_GEN_REF_FROM_VEC4	vendor/glm/detail/_swizzle_func.hpp	149;"	d
GLM_SWIZZLE_GEN_REF_FROM_VEC4_COMP	vendor/glm/detail/_swizzle_func.hpp	144;"	d
GLM_SWIZZLE_GEN_VEC2_ENTRY	vendor/glm/detail/_swizzle_func.hpp	3;"	d
GLM_SWIZZLE_GEN_VEC2_ENTRY_DEF	vendor/glm/detail/_swizzle_func.hpp	21;"	d
GLM_SWIZZLE_GEN_VEC2_FROM_VEC2_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	154;"	d
GLM_SWIZZLE_GEN_VEC2_FROM_VEC3_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	198;"	d
GLM_SWIZZLE_GEN_VEC2_FROM_VEC4_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	331;"	d
GLM_SWIZZLE_GEN_VEC3_ENTRY	vendor/glm/detail/_swizzle_func.hpp	9;"	d
GLM_SWIZZLE_GEN_VEC3_ENTRY_DEF	vendor/glm/detail/_swizzle_func.hpp	28;"	d
GLM_SWIZZLE_GEN_VEC3_FROM_VEC2_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	160;"	d
GLM_SWIZZLE_GEN_VEC3_FROM_VEC3_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	209;"	d
GLM_SWIZZLE_GEN_VEC3_FROM_VEC4_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	349;"	d
GLM_SWIZZLE_GEN_VEC4_ENTRY	vendor/glm/detail/_swizzle_func.hpp	15;"	d
GLM_SWIZZLE_GEN_VEC4_ENTRY_DEF	vendor/glm/detail/_swizzle_func.hpp	35;"	d
GLM_SWIZZLE_GEN_VEC4_FROM_VEC2_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	170;"	d
GLM_SWIZZLE_GEN_VEC4_FROM_VEC3_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	238;"	d
GLM_SWIZZLE_GEN_VEC4_FROM_VEC4_SWIZZLE	vendor/glm/detail/_swizzle_func.hpp	415;"	d
GLM_SWIZZLE_GEN_VEC_FROM_VEC2	vendor/glm/detail/_swizzle_func.hpp	193;"	d
GLM_SWIZZLE_GEN_VEC_FROM_VEC2_COMP	vendor/glm/detail/_swizzle_func.hpp	188;"	d
GLM_SWIZZLE_GEN_VEC_FROM_VEC3	vendor/glm/detail/_swizzle_func.hpp	326;"	d
GLM_SWIZZLE_GEN_VEC_FROM_VEC3_COMP	vendor/glm/detail/_swizzle_func.hpp	321;"	d
GLM_SWIZZLE_GEN_VEC_FROM_VEC4	vendor/glm/detail/_swizzle_func.hpp	678;"	d
GLM_SWIZZLE_GEN_VEC_FROM_VEC4_COMP	vendor/glm/detail/_swizzle_func.hpp	673;"	d
GLM_SWIZZLE_OPERATOR	vendor/glm/detail/setup.hpp	446;"	d
GLM_SWIZZLE_SCALAR_BINARY_OPERATOR_IMPLEMENTATION	vendor/glm/detail/_swizzle.hpp	198;"	d
GLM_SWIZZLE_TEMPLATE1	vendor/glm/detail/_swizzle.hpp	170;"	d
GLM_SWIZZLE_TEMPLATE2	vendor/glm/detail/_swizzle.hpp	171;"	d
GLM_SWIZZLE_TYPE1	vendor/glm/detail/_swizzle.hpp	172;"	d
GLM_SWIZZLE_TYPE2	vendor/glm/detail/_swizzle.hpp	173;"	d
GLM_SWIZZLE_VECTOR_BINARY_OPERATOR_IMPLEMENTATION	vendor/glm/detail/_swizzle.hpp	178;"	d
GLM_VERSION	vendor/glm/detail/setup.hpp	10;"	d
GLM_VERSION_MAJOR	vendor/glm/detail/setup.hpp	6;"	d
GLM_VERSION_MESSAGE	vendor/glm/detail/setup.hpp	11;"	d
GLM_VERSION_MINOR	vendor/glm/detail/setup.hpp	7;"	d
GLM_VERSION_PATCH	vendor/glm/detail/setup.hpp	8;"	d
GLM_VERSION_REVISION	vendor/glm/detail/setup.hpp	9;"	d
GStyleVarInfo	vendor/imgui/imgui.cpp	/^static const ImGuiStyleVarInfo GStyleVarInfo[] =$/;"	v	file:
GetActiveID	vendor/imgui/imgui_internal.h	/^    inline ImGuiID          GetActiveID()   { ImGuiContext& g = *GImGui; return g.ActiveId; }$/;"	f	namespace:ImGui
GetBL	vendor/imgui/imgui_internal.h	/^    ImVec2      GetBL() const                       { return ImVec2(Min.x, Max.y); }  \/\/ Bottom-left$/;"	f	struct:ImRect
GetBR	vendor/imgui/imgui_internal.h	/^    ImVec2      GetBR() const                       { return Max; }                   \/\/ Bottom-right$/;"	f	struct:ImRect
GetBackgroundDrawList	vendor/imgui/imgui.cpp	/^ImDrawList* ImGui::GetBackgroundDrawList()$/;"	f	class:ImGui
GetBit	vendor/imgui/imgui.h	/^    inline bool     GetBit(int n) const { int off = (n >> 5); ImU32 mask = 1u << (n & 31); return (UsedChars[off] & mask) != 0; }  \/\/ Get bit n in the array$/;"	f	struct:ImFontGlyphRangesBuilder
GetBit	vendor/imgui/imgui_internal.h	/^    bool            GetBit(int n) const     { int off = (n >> 5); int mask = 1 << (n & 31); return (Storage[off] & mask) != 0; }$/;"	f	struct:ImBoolVector
GetBool	vendor/imgui/imgui.cpp	/^bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const$/;"	f	class:ImGuiStorage
GetBoolRef	vendor/imgui/imgui.cpp	/^bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)$/;"	f	class:ImGuiStorage
GetByIndex	vendor/imgui/imgui_internal.h	/^    T*          GetByIndex(ImPoolIdx n)             { return &Data[n]; }$/;"	f	struct:ImPool
GetByKey	vendor/imgui/imgui_internal.h	/^    T*          GetByKey(ImGuiID key)               { int idx = Map.GetInt(key, -1); return (idx != -1) ? &Data[idx] : NULL; }$/;"	f	struct:ImPool
GetCenter	vendor/imgui/imgui_internal.h	/^    ImVec2      GetCenter() const                   { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }$/;"	f	struct:ImRect
GetCharAdvance	vendor/imgui/imgui.h	/^    float                       GetCharAdvance(ImWchar c) const     { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }$/;"	f	struct:ImFont
GetClipRectMax	vendor/imgui/imgui.h	/^    inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }$/;"	f	struct:ImDrawList
GetClipRectMin	vendor/imgui/imgui.h	/^    inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }$/;"	f	struct:ImDrawList
GetClipboardText	vendor/imgui/imgui.cpp	/^const char* ImGui::GetClipboardText()$/;"	f	class:ImGui
GetClipboardTextFn	vendor/imgui/imgui.h	/^    const char* (*GetClipboardTextFn)(void* user_data);$/;"	m	struct:ImGuiIO
GetClipboardTextFn_DefaultImpl	vendor/imgui/imgui.cpp	/^static const char* GetClipboardTextFn_DefaultImpl(void*)$/;"	f	file:
GetColorU32	vendor/imgui/imgui.cpp	/^ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)$/;"	f	class:ImGui
GetColorU32	vendor/imgui/imgui.cpp	/^ImU32 ImGui::GetColorU32(ImU32 col)$/;"	f	class:ImGui
GetColorU32	vendor/imgui/imgui.cpp	/^ImU32 ImGui::GetColorU32(const ImVec4& col)$/;"	f	class:ImGui
GetColumnIndex	vendor/imgui/imgui_widgets.cpp	/^int ImGui::GetColumnIndex()$/;"	f	class:ImGui
GetColumnNormFromOffset	vendor/imgui/imgui_widgets.cpp	/^float ImGui::GetColumnNormFromOffset(const ImGuiColumns* columns, float offset)$/;"	f	class:ImGui
GetColumnOffset	vendor/imgui/imgui_widgets.cpp	/^float ImGui::GetColumnOffset(int column_index)$/;"	f	class:ImGui
GetColumnOffsetFromNorm	vendor/imgui/imgui_widgets.cpp	/^float ImGui::GetColumnOffsetFromNorm(const ImGuiColumns* columns, float offset_norm)$/;"	f	class:ImGui
GetColumnWidth	vendor/imgui/imgui_widgets.cpp	/^float ImGui::GetColumnWidth(int column_index)$/;"	f	class:ImGui
GetColumnWidthEx	vendor/imgui/imgui_widgets.cpp	/^static float GetColumnWidthEx(ImGuiColumns* columns, int column_index, bool before_resize = false)$/;"	f	file:
GetColumnsCount	vendor/imgui/imgui_widgets.cpp	/^int ImGui::GetColumnsCount()$/;"	f	class:ImGui
GetColumnsID	vendor/imgui/imgui_widgets.cpp	/^ImGuiID ImGui::GetColumnsID(const char* str_id, int columns_count)$/;"	f	class:ImGui
GetContentRegionAvail	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetContentRegionAvail()$/;"	f	class:ImGui
GetContentRegionAvailWidth	vendor/imgui/imgui.h	/^    static inline float GetContentRegionAvailWidth()          { return GetContentRegionAvail().x; }$/;"	f	namespace:ImGui
GetContentRegionMax	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetContentRegionMax()$/;"	f	class:ImGui
GetContentRegionMaxAbs	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetContentRegionMaxAbs()$/;"	f	class:ImGui
GetCount	IndexBuffer/IndexBuffer.h	/^	inline unsigned int GetCount() const { return count; }$/;"	f	class:IndexBuffer
GetCurrentClipRect	vendor/imgui/imgui_draw.cpp	403;"	d	file:
GetCurrentClipRect	vendor/imgui/imgui_draw.cpp	472;"	d	file:
GetCurrentContext	vendor/imgui/imgui.cpp	/^ImGuiContext* ImGui::GetCurrentContext()$/;"	f	class:ImGui
GetCurrentTextureId	vendor/imgui/imgui_draw.cpp	404;"	d	file:
GetCurrentTextureId	vendor/imgui/imgui_draw.cpp	473;"	d	file:
GetCurrentWindow	vendor/imgui/imgui_internal.h	/^    inline    ImGuiWindow*  GetCurrentWindow()          { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }$/;"	f	namespace:ImGui
GetCurrentWindowRead	vendor/imgui/imgui_internal.h	/^    inline    ImGuiWindow*  GetCurrentWindowRead()      { ImGuiContext& g = *GImGui; return g.CurrentWindow; }$/;"	f	namespace:ImGui
GetCursorPos	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetCursorPos()$/;"	f	class:ImGui
GetCursorPosX	vendor/imgui/imgui.cpp	/^float ImGui::GetCursorPosX()$/;"	f	class:ImGui
GetCursorPosY	vendor/imgui/imgui.cpp	/^float ImGui::GetCursorPosY()$/;"	f	class:ImGui
GetCursorScreenPos	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetCursorScreenPos()$/;"	f	class:ImGui
GetCursorStartPos	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetCursorStartPos()$/;"	f	class:ImGui
GetCustomRectByIndex	vendor/imgui/imgui.h	/^    const ImFontAtlasCustomRect*GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }$/;"	f	struct:ImFontAtlas
GetDebugName	vendor/imgui/imgui.h	/^    const char*                 GetDebugName() const                { return ConfigData ? ConfigData->Name : "<unknown>"; }$/;"	f	struct:ImFont
GetDefaultCompressedFontDataTTFBase85	vendor/imgui/imgui_draw.cpp	/^static const char* GetDefaultCompressedFontDataTTFBase85()$/;"	f	file:
GetDefaultFont	vendor/imgui/imgui_internal.h	/^    inline ImFont*          GetDefaultFont() { ImGuiContext& g = *GImGui; return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0]; }$/;"	f	namespace:ImGui
GetDragDropPayload	vendor/imgui/imgui.cpp	/^const ImGuiPayload* ImGui::GetDragDropPayload()$/;"	f	class:ImGui
GetDraggedColumnOffset	vendor/imgui/imgui_widgets.cpp	/^static float GetDraggedColumnOffset(ImGuiColumns* columns, int column_index)$/;"	f	file:
GetDrawData	vendor/imgui/imgui.cpp	/^ImDrawData* ImGui::GetDrawData()$/;"	f	class:ImGui
GetDrawListSharedData	vendor/imgui/imgui.cpp	/^ImDrawListSharedData* ImGui::GetDrawListSharedData()$/;"	f	class:ImGui
GetElements	VertexBufferLayout/VertexBufferLayout.h	/^ 	inline const std::vector<VertexBufferLayoutElement> GetElements() const { return elements; }$/;"	f	class:VertexBufferLayout
GetFallbackWindowNameForWindowingList	vendor/imgui/imgui.cpp	/^static const char* GetFallbackWindowNameForWindowingList(ImGuiWindow* window)$/;"	f	file:
GetFloat	vendor/imgui/imgui.cpp	/^float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const$/;"	f	class:ImGuiStorage
GetFloatRef	vendor/imgui/imgui.cpp	/^float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)$/;"	f	class:ImGuiStorage
GetFocusID	vendor/imgui/imgui_internal.h	/^    inline ImGuiID          GetFocusID()    { ImGuiContext& g = *GImGui; return g.NavId; }$/;"	f	namespace:ImGui
GetFont	vendor/imgui/imgui.cpp	/^ImFont* ImGui::GetFont()$/;"	f	class:ImGui
GetFontSize	vendor/imgui/imgui.cpp	/^float ImGui::GetFontSize()$/;"	f	class:ImGui
GetFontTexUvWhitePixel	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetFontTexUvWhitePixel()$/;"	f	class:ImGui
GetForegroundDrawList	vendor/imgui/imgui.cpp	/^ImDrawList* ImGui::GetForegroundDrawList()$/;"	f	class:ImGui
GetForegroundDrawList	vendor/imgui/imgui.cpp	/^static ImDrawList* GetForegroundDrawList(ImGuiWindow*)$/;"	f	file:
GetFrameCount	vendor/imgui/imgui.cpp	/^int ImGui::GetFrameCount()$/;"	f	class:ImGui
GetFrameHeight	vendor/imgui/imgui.cpp	/^float ImGui::GetFrameHeight()$/;"	f	class:ImGui
GetFrameHeightWithSpacing	vendor/imgui/imgui.cpp	/^float ImGui::GetFrameHeightWithSpacing()$/;"	f	class:ImGui
GetGlyphRangesChineseFull	vendor/imgui/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesChineseFull()$/;"	f	class:ImFontAtlas
GetGlyphRangesChineseSimplifiedCommon	vendor/imgui/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesChineseSimplifiedCommon()$/;"	f	class:ImFontAtlas
GetGlyphRangesCyrillic	vendor/imgui/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesCyrillic()$/;"	f	class:ImFontAtlas
GetGlyphRangesDefault	vendor/imgui/imgui_draw.cpp	/^const ImWchar*   ImFontAtlas::GetGlyphRangesDefault()$/;"	f	class:ImFontAtlas
GetGlyphRangesJapanese	vendor/imgui/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesJapanese()$/;"	f	class:ImFontAtlas
GetGlyphRangesKorean	vendor/imgui/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesKorean()$/;"	f	class:ImFontAtlas
GetGlyphRangesThai	vendor/imgui/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesThai()$/;"	f	class:ImFontAtlas
GetGlyphRangesVietnamese	vendor/imgui/imgui_draw.cpp	/^const ImWchar*  ImFontAtlas::GetGlyphRangesVietnamese()$/;"	f	class:ImFontAtlas
GetHeight	Texture/Texture.h	/^	inline int GetHeight() const { return height; }$/;"	f	class:Texture
GetHeight	vendor/imgui/imgui_internal.h	/^    float       GetHeight() const                   { return Max.y - Min.y; }$/;"	f	struct:ImRect
GetHoveredID	vendor/imgui/imgui.cpp	/^ImGuiID ImGui::GetHoveredID()$/;"	f	class:ImGui
GetID	vendor/imgui/imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id)$/;"	f	class:ImGui
GetID	vendor/imgui/imgui.cpp	/^ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui
GetID	vendor/imgui/imgui.cpp	/^ImGuiID ImGui::GetID(const void* ptr_id)$/;"	f	class:ImGui
GetID	vendor/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow
GetID	vendor/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(const void* ptr)$/;"	f	class:ImGuiWindow
GetID	vendor/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetID(int n)$/;"	f	class:ImGuiWindow
GetIDFromRectangle	vendor/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)$/;"	f	class:ImGuiWindow
GetIDNoKeepAlive	vendor/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)$/;"	f	class:ImGuiWindow
GetIDNoKeepAlive	vendor/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetIDNoKeepAlive(const void* ptr)$/;"	f	class:ImGuiWindow
GetIDNoKeepAlive	vendor/imgui/imgui.cpp	/^ImGuiID ImGuiWindow::GetIDNoKeepAlive(int n)$/;"	f	class:ImGuiWindow
GetIO	vendor/imgui/imgui.cpp	/^ImGuiIO& ImGui::GetIO()$/;"	f	class:ImGui
GetIndex	vendor/imgui/imgui_internal.h	/^    ImPoolIdx   GetIndex(const T* p) const          { IM_ASSERT(p >= Data.Data && p < Data.Data + Data.Size); return (ImPoolIdx)(p - Data.Data); }$/;"	f	struct:ImPool
GetInt	vendor/imgui/imgui.cpp	/^int ImGuiStorage::GetInt(ImGuiID key, int default_val) const$/;"	f	class:ImGuiStorage
GetIntRef	vendor/imgui/imgui.cpp	/^int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)$/;"	f	class:ImGuiStorage
GetItemID	vendor/imgui/imgui_internal.h	/^    inline ImGuiID          GetItemID()     { ImGuiContext& g = *GImGui; return g.CurrentWindow->DC.LastItemId; }$/;"	f	namespace:ImGui
GetItemRectMax	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetItemRectMax()$/;"	f	class:ImGui
GetItemRectMin	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetItemRectMin()$/;"	f	class:ImGui
GetItemRectSize	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetItemRectSize()$/;"	f	class:ImGui
GetItemsLineHeightWithSpacing	vendor/imgui/imgui.h	/^    static inline float GetItemsLineHeightWithSpacing()       { return GetFrameHeightWithSpacing(); }$/;"	f	namespace:ImGui
GetKeyIndex	vendor/imgui/imgui.cpp	/^int ImGui::GetKeyIndex(ImGuiKey imgui_key)$/;"	f	class:ImGui
GetKeyPressedAmount	vendor/imgui/imgui.cpp	/^int ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)$/;"	f	class:ImGui
GetMinimumStepAtDecimalPrecision	vendor/imgui/imgui_widgets.cpp	/^static float GetMinimumStepAtDecimalPrecision(int decimal_precision)$/;"	f	file:
GetMouseCursor	vendor/imgui/imgui.cpp	/^ImGuiMouseCursor ImGui::GetMouseCursor()$/;"	f	class:ImGui
GetMouseCursorTexData	vendor/imgui/imgui_draw.cpp	/^bool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])$/;"	f	class:ImFontAtlas
GetMouseDragDelta	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)$/;"	f	class:ImGui
GetMousePos	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetMousePos()$/;"	f	class:ImGui
GetMousePosOnOpeningCurrentPopup	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()$/;"	f	class:ImGui
GetNavInputAmount	vendor/imgui/imgui.cpp	/^float ImGui::GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode)$/;"	f	class:ImGui
GetNavInputAmount2d	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)$/;"	f	class:ImGui
GetOrAddByKey	vendor/imgui/imgui_internal.h	/^    T*          GetOrAddByKey(ImGuiID key)          { int* p_idx = Map.GetIntRef(key, -1); if (*p_idx != -1) return &Data[*p_idx]; *p_idx = FreeIdx; return Add(); }$/;"	f	struct:ImPool
GetOverlayDrawList	vendor/imgui/imgui.h	/^    static inline ImDrawList* GetOverlayDrawList()            { return GetForegroundDrawList(); }$/;"	f	namespace:ImGui
GetRedoAvailCount	vendor/imgui/imgui_internal.h	/^    int         GetRedoAvailCount() const   { return STB_TEXTEDIT_UNDOSTATECOUNT - Stb.undostate.redo_point; }$/;"	f	struct:ImGuiInputTextState
GetResizeBorderRect	vendor/imgui/imgui.cpp	/^static ImRect GetResizeBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)$/;"	f	file:
GetScrollMaxX	vendor/imgui/imgui.cpp	/^float ImGui::GetScrollMaxX()$/;"	f	class:ImGui
GetScrollMaxY	vendor/imgui/imgui.cpp	/^float ImGui::GetScrollMaxY()$/;"	f	class:ImGui
GetScrollX	vendor/imgui/imgui.cpp	/^float ImGui::GetScrollX()$/;"	f	class:ImGui
GetScrollY	vendor/imgui/imgui.cpp	/^float ImGui::GetScrollY()$/;"	f	class:ImGui
GetScrollbarID	vendor/imgui/imgui_widgets.cpp	/^ImGuiID ImGui::GetScrollbarID(ImGuiWindow* window, ImGuiAxis axis)$/;"	f	class:ImGui
GetSize	vendor/imgui/imgui_internal.h	/^    ImVec2      GetSize() const                     { return ImVec2(Max.x - Min.x, Max.y - Min.y); }$/;"	f	struct:ImRect
GetSize	vendor/imgui/imgui_internal.h	/^    int         GetSize() const                     { return Data.Size; }$/;"	f	struct:ImPool
GetSizeOfType	VertexBufferLayout/VertexBufferLayout.h	/^	static unsigned int GetSizeOfType(unsigned int type){$/;"	f	struct:VertexBufferLayoutElement
GetStateStorage	vendor/imgui/imgui.cpp	/^ImGuiStorage* ImGui::GetStateStorage()$/;"	f	class:ImGui
GetStride	VertexBufferLayout/VertexBufferLayout.h	/^	inline unsigned int GetStride() const { return stride; }$/;"	f	class:VertexBufferLayout
GetStyle	vendor/imgui/imgui.cpp	/^ImGuiStyle& ImGui::GetStyle()$/;"	f	class:ImGui
GetStyleColorName	vendor/imgui/imgui.cpp	/^const char* ImGui::GetStyleColorName(ImGuiCol idx)$/;"	f	class:ImGui
GetStyleColorVec4	vendor/imgui/imgui.cpp	/^const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)$/;"	f	class:ImGui
GetStyleVarInfo	vendor/imgui/imgui.cpp	/^static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)$/;"	f	file:
GetTL	vendor/imgui/imgui_internal.h	/^    ImVec2      GetTL() const                       { return Min; }                   \/\/ Top-left$/;"	f	struct:ImRect
GetTR	vendor/imgui/imgui_internal.h	/^    ImVec2      GetTR() const                       { return ImVec2(Max.x, Min.y); }  \/\/ Top-right$/;"	f	struct:ImRect
GetTabBarFromTabBarRef	vendor/imgui/imgui_widgets.cpp	/^static ImGuiTabBar* GetTabBarFromTabBarRef(const ImGuiPtrOrIndex& ref)$/;"	f	file:
GetTabBarRefFromTabBar	vendor/imgui/imgui_widgets.cpp	/^static ImGuiPtrOrIndex GetTabBarRefFromTabBar(ImGuiTabBar* tab_bar)$/;"	f	file:
GetTabName	vendor/imgui/imgui_internal.h	/^    const char*         GetTabName(const ImGuiTabItem* tab) const$/;"	f	struct:ImGuiTabBar
GetTabOrder	vendor/imgui/imgui_internal.h	/^    int                 GetTabOrder(const ImGuiTabItem* tab) const  { return Tabs.index_from_ptr(tab); }$/;"	f	struct:ImGuiTabBar
GetTexDataAsAlpha8	vendor/imgui/imgui_draw.cpp	/^void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas
GetTexDataAsRGBA32	vendor/imgui/imgui_draw.cpp	/^void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)$/;"	f	class:ImFontAtlas
GetTextLineHeight	vendor/imgui/imgui.cpp	/^float ImGui::GetTextLineHeight()$/;"	f	class:ImGui
GetTextLineHeightWithSpacing	vendor/imgui/imgui.cpp	/^float ImGui::GetTextLineHeightWithSpacing()$/;"	f	class:ImGui
GetTime	vendor/imgui/imgui.cpp	/^double ImGui::GetTime()$/;"	f	class:ImGui
GetTopMostPopupModal	vendor/imgui/imgui.cpp	/^ImGuiWindow* ImGui::GetTopMostPopupModal()$/;"	f	class:ImGui
GetTreeNodeToLabelSpacing	vendor/imgui/imgui_widgets.cpp	/^float ImGui::GetTreeNodeToLabelSpacing()$/;"	f	class:ImGui
GetUndoAvailCount	vendor/imgui/imgui_internal.h	/^    int         GetUndoAvailCount() const   { return Stb.undostate.undo_point; }$/;"	f	struct:ImGuiInputTextState
GetUniformLocation	Shader/Shader.cpp	/^int Shader::GetUniformLocation(const std::string& name){$/;"	f	class:Shader
GetVarPtr	vendor/imgui/imgui.cpp	/^    void*           GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }$/;"	f	struct:ImGuiStyleVarInfo
GetVersion	vendor/imgui/imgui.cpp	/^const char* ImGui::GetVersion()$/;"	f	class:ImGui
GetViewportRect	vendor/imgui/imgui.cpp	/^static ImRect GetViewportRect()$/;"	f	file:
GetVoidPtr	vendor/imgui/imgui.cpp	/^void* ImGuiStorage::GetVoidPtr(ImGuiID key) const$/;"	f	class:ImGuiStorage
GetVoidPtrRef	vendor/imgui/imgui.cpp	/^void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)$/;"	f	class:ImGuiStorage
GetWidth	Texture/Texture.h	/^	inline int GetWidth() const { return width; }$/;"	f	class:Texture
GetWidth	vendor/imgui/imgui_internal.h	/^    float       GetWidth() const                    { return Max.x - Min.x; }$/;"	f	struct:ImRect
GetWindowAllowedExtentRect	vendor/imgui/imgui.cpp	/^ImRect ImGui::GetWindowAllowedExtentRect(ImGuiWindow* window)$/;"	f	class:ImGui
GetWindowBgColorIdxFromFlags	vendor/imgui/imgui.cpp	/^static ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)$/;"	f	file:
GetWindowContentRegionMax	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMax()$/;"	f	class:ImGui
GetWindowContentRegionMin	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowContentRegionMin()$/;"	f	class:ImGui
GetWindowContentRegionWidth	vendor/imgui/imgui.cpp	/^float ImGui::GetWindowContentRegionWidth()$/;"	f	class:ImGui
GetWindowDrawList	vendor/imgui/imgui.cpp	/^ImDrawList* ImGui::GetWindowDrawList()$/;"	f	class:ImGui
GetWindowHeight	vendor/imgui/imgui.cpp	/^float ImGui::GetWindowHeight()$/;"	f	class:ImGui
GetWindowPos	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowPos()$/;"	f	class:ImGui
GetWindowSize	vendor/imgui/imgui.cpp	/^ImVec2 ImGui::GetWindowSize()$/;"	f	class:ImGui
GetWindowWidth	vendor/imgui/imgui.cpp	/^float ImGui::GetWindowWidth()$/;"	f	class:ImGui
GlfwClientApi	vendor/imgui/imgui_impl_glfw.cpp	/^enum GlfwClientApi$/;"	g	file:
GlfwClientApi_OpenGL	vendor/imgui/imgui_impl_glfw.cpp	/^    GlfwClientApi_OpenGL,$/;"	e	enum:GlfwClientApi	file:
GlfwClientApi_Unknown	vendor/imgui/imgui_impl_glfw.cpp	/^    GlfwClientApi_Unknown,$/;"	e	enum:GlfwClientApi	file:
GlfwClientApi_Vulkan	vendor/imgui/imgui_impl_glfw.cpp	/^    GlfwClientApi_Vulkan$/;"	e	enum:GlfwClientApi	file:
Glyph	vendor/imgui/imgui.h	/^    typedef ImFontGlyph Glyph; \/\/ OBSOLETED in 1.52+$/;"	t	struct:ImFont
GlyphAdvanceX	vendor/imgui/imgui.h	/^    float           GlyphAdvanceX;  \/\/ Input    \/\/ For custom font glyphs only (ID<0x10000): glyph xadvance$/;"	m	struct:ImFontAtlasCustomRect
GlyphExtraSpacing	vendor/imgui/imgui.h	/^    ImVec2          GlyphExtraSpacing;      \/\/ 0, 0     \/\/ Extra spacing (in pixels) between glyphs. Only X axis is supported for now.$/;"	m	struct:ImFontConfig
GlyphMaxAdvanceX	vendor/imgui/imgui.h	/^    float           GlyphMaxAdvanceX;       \/\/ FLT_MAX  \/\/ Maximum AdvanceX for glyphs$/;"	m	struct:ImFontConfig
GlyphMinAdvanceX	vendor/imgui/imgui.h	/^    float           GlyphMinAdvanceX;       \/\/ 0        \/\/ Minimum AdvanceX for glyphs, set Min to align font icons, set both Min\/Max to enforce mono-space font$/;"	m	struct:ImFontConfig
GlyphOffset	vendor/imgui/imgui.h	/^    ImVec2          GlyphOffset;            \/\/ 0, 0     \/\/ Offset all glyphs from this font input.$/;"	m	struct:ImFontConfig
GlyphOffset	vendor/imgui/imgui.h	/^    ImVec2          GlyphOffset;    \/\/ Input    \/\/ For custom font glyphs only (ID<0x10000): glyph display offset$/;"	m	struct:ImFontAtlasCustomRect
GlyphRanges	vendor/imgui/imgui.h	/^    const ImWchar*  GlyphRanges;            \/\/ NULL     \/\/ Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.$/;"	m	struct:ImFontConfig
GlyphRangesBuilder	vendor/imgui/imgui.h	/^    typedef ImFontGlyphRangesBuilder GlyphRangesBuilder; \/\/ OBSOLETED in 1.67+$/;"	t	struct:ImFontAtlas
Glyphs	vendor/imgui/imgui.h	/^    ImVector<ImFontGlyph>       Glyphs;             \/\/ 12-16 \/\/ out \/\/            \/\/ All glyphs.$/;"	m	struct:ImFont
GlyphsCount	vendor/imgui/imgui_draw.cpp	/^    int                 GlyphsCount;        \/\/ Glyph count (excluding missing glyphs and glyphs already set by an earlier source font)$/;"	m	struct:ImFontBuildSrcData	file:
GlyphsCount	vendor/imgui/imgui_draw.cpp	/^    int                 GlyphsCount;$/;"	m	struct:ImFontBuildDstData	file:
GlyphsHighest	vendor/imgui/imgui_draw.cpp	/^    int                 GlyphsHighest;      \/\/ Highest requested codepoint$/;"	m	struct:ImFontBuildSrcData	file:
GlyphsHighest	vendor/imgui/imgui_draw.cpp	/^    int                 GlyphsHighest;$/;"	m	struct:ImFontBuildDstData	file:
GlyphsList	vendor/imgui/imgui_draw.cpp	/^    ImVector<int>       GlyphsList;         \/\/ Glyph codepoints list (flattened version of GlyphsMap)$/;"	m	struct:ImFontBuildSrcData	file:
GlyphsSet	vendor/imgui/imgui_draw.cpp	/^    ImBoolVector        GlyphsSet;          \/\/ Glyph bit map (random access, 1-bit per codepoint. This will be a maximum of 8KB)$/;"	m	struct:ImFontBuildSrcData	file:
GlyphsSet	vendor/imgui/imgui_draw.cpp	/^    ImBoolVector        GlyphsSet;          \/\/ This is used to resolve collision when multiple sources are merged into a same destination font.$/;"	m	struct:ImFontBuildDstData	file:
GrabMinSize	vendor/imgui/imgui.h	/^    float       GrabMinSize;                \/\/ Minimum width\/height of a grab box for slider\/scrollbar.$/;"	m	struct:ImGuiStyle
GrabRounding	vendor/imgui/imgui.h	/^    float       GrabRounding;               \/\/ Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.$/;"	m	struct:ImGuiStyle
GroupOffset	vendor/imgui/imgui_internal.h	/^    ImVec1                  GroupOffset;$/;"	m	struct:ImGuiWindowTempData
GroupStack	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiGroupData>GroupStack;$/;"	m	struct:ImGuiWindowTempData
GrowIndex	vendor/imgui/imgui_draw.cpp	/^void ImFont::GrowIndex(int new_size)$/;"	f	class:ImFont
HSV	vendor/imgui/imgui.h	/^    static ImColor HSV(float h, float s, float v, float a = 1.0f)   { float r,g,b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r,g,b,a); }$/;"	f	struct:ImColor
HasCloseButton	vendor/imgui/imgui_internal.h	/^    bool                    HasCloseButton;                     \/\/ Set when the window has a close button (p_open != NULL)$/;"	m	struct:ImGuiWindow
HasSelection	vendor/imgui/imgui.h	/^    bool                HasSelection() const { return SelectionStart != SelectionEnd; }$/;"	f	struct:ImGuiInputTextCallbackData
HasSelection	vendor/imgui/imgui_internal.h	/^    bool        HasSelection() const        { return Stb.select_start != Stb.select_end; }$/;"	f	struct:ImGuiInputTextState
Height	vendor/imgui/imgui.h	/^    unsigned short  Width, Height;  \/\/ Input    \/\/ Desired rectangle dimension$/;"	m	struct:ImFontAtlasCustomRect
HelpMarker	vendor/imgui/imgui_demo.cpp	/^static void HelpMarker(const char* desc)$/;"	f	file:
Hidden	vendor/imgui/imgui_internal.h	/^    bool                    Hidden;                             \/\/ Do not display (== (HiddenFrames*** > 0))$/;"	m	struct:ImGuiWindow
HiddenFramesCanSkipItems	vendor/imgui/imgui_internal.h	/^    int                     HiddenFramesCanSkipItems;           \/\/ Hide the window for N frames$/;"	m	struct:ImGuiWindow
HiddenFramesCannotSkipItems	vendor/imgui/imgui_internal.h	/^    int                     HiddenFramesCannotSkipItems;        \/\/ Hide the window for N frames while allowing items to be submitted so we can measure their size$/;"	m	struct:ImGuiWindow
History	vendor/imgui/imgui_demo.cpp	/^    ImVector<char*>       History;$/;"	m	struct:ExampleAppConsole	file:
HistoryPos	vendor/imgui/imgui_demo.cpp	/^    int                   HistoryPos;    \/\/ -1: new line, 0..History.Size-1 browsing history.$/;"	m	struct:ExampleAppConsole	file:
HostClipRect	vendor/imgui/imgui_internal.h	/^    ImRect              HostClipRect;           \/\/ Backup of ClipRect at the time of BeginColumns()$/;"	m	struct:ImGuiColumns
HostCursorMaxPosX	vendor/imgui/imgui_internal.h	/^    float               HostCursorMaxPosX;      \/\/ Backup of CursorMaxPos at the time of BeginColumns()$/;"	m	struct:ImGuiColumns
HostCursorPosY	vendor/imgui/imgui_internal.h	/^    float               HostCursorPosY;         \/\/ Backup of CursorPos at the time of BeginColumns()$/;"	m	struct:ImGuiColumns
HostWorkRect	vendor/imgui/imgui_internal.h	/^    ImRect              HostWorkRect;           \/\/ Backup of WorkRect at the time of BeginColumns()$/;"	m	struct:ImGuiColumns
HoveredId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 HoveredId;                          \/\/ Hovered widget$/;"	m	struct:ImGuiContext
HoveredIdAllowOverlap	vendor/imgui/imgui_internal.h	/^    bool                    HoveredIdAllowOverlap;$/;"	m	struct:ImGuiContext
HoveredIdNotActiveTimer	vendor/imgui/imgui_internal.h	/^    float                   HoveredIdNotActiveTimer;            \/\/ Measure contiguous hovering time where the item has not been active$/;"	m	struct:ImGuiContext
HoveredIdPreviousFrame	vendor/imgui/imgui_internal.h	/^    ImGuiID                 HoveredIdPreviousFrame;$/;"	m	struct:ImGuiContext
HoveredIdTimer	vendor/imgui/imgui_internal.h	/^    float                   HoveredIdTimer;                     \/\/ Measure contiguous hovering time$/;"	m	struct:ImGuiContext
HoveredRootWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            HoveredRootWindow;                  \/\/ Will catch mouse inputs (for focus\/move only)$/;"	m	struct:ImGuiContext
HoveredWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            HoveredWindow;                      \/\/ Will catch mouse inputs$/;"	m	struct:ImGuiContext
ID	vendor/imgui/imgui.h	/^    unsigned int    ID;             \/\/ Input    \/\/ User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other\/internal\/custom texture data.$/;"	m	struct:ImFontAtlasCustomRect
ID	vendor/imgui/imgui_internal.h	/^    ImGuiID                 ID;                                 \/\/ == ImHash(Name)$/;"	m	struct:ImGuiWindow
ID	vendor/imgui/imgui_internal.h	/^    ImGuiID                 ID;                     \/\/ widget id owning the text state$/;"	m	struct:ImGuiInputTextState
ID	vendor/imgui/imgui_internal.h	/^    ImGuiID             ID;                     \/\/ Zero for tab-bars used by docking$/;"	m	struct:ImGuiTabBar
ID	vendor/imgui/imgui_internal.h	/^    ImGuiID             ID;$/;"	m	struct:ImGuiColumns
ID	vendor/imgui/imgui_internal.h	/^    ImGuiID             ID;$/;"	m	struct:ImGuiTabItem
ID	vendor/imgui/imgui_internal.h	/^    ImGuiID       ID;           \/\/ Best candidate$/;"	m	struct:ImGuiNavMoveResult
ID	vendor/imgui/imgui_internal.h	/^    ImGuiID     ID;$/;"	m	struct:ImGuiWindowSettings
IDStack	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiID>       IDStack;                            \/\/ ID stack. ID are hashes seeded with the value at the top of the stack$/;"	m	struct:ImGuiWindow
IMGUI_API	vendor/imgui/imgui.h	57;"	d
IMGUI_CDECL	vendor/imgui/imgui_internal.h	155;"	d
IMGUI_CDECL	vendor/imgui/imgui_internal.h	157;"	d
IMGUI_CHECKVERSION	vendor/imgui/imgui.h	51;"	d
IMGUI_DEBUG_INI_SETTINGS	vendor/imgui/imgui.cpp	1002;"	d	file:
IMGUI_DEBUG_LOG	vendor/imgui/imgui_internal.h	150;"	d
IMGUI_DEBUG_NAV_RECTS	vendor/imgui/imgui.cpp	1001;"	d	file:
IMGUI_DEBUG_NAV_SCORING	vendor/imgui/imgui.cpp	1000;"	d	file:
IMGUI_DEFINE_MATH_OPERATORS	vendor/imgui/imgui.cpp	987;"	d	file:
IMGUI_DEFINE_MATH_OPERATORS	vendor/imgui/imgui_draw.cpp	31;"	d	file:
IMGUI_DEFINE_MATH_OPERATORS	vendor/imgui/imgui_widgets.cpp	37;"	d	file:
IMGUI_DISABLE_DEMO_WINDOWS	vendor/imgui/imgui_demo.cpp	116;"	d	file:
IMGUI_IMPL_API	vendor/imgui/imgui.h	60;"	d
IMGUI_IMPL_OPENGL_ES2	vendor/imgui/imgui_impl_opengl3.cpp	83;"	d	file:
IMGUI_IMPL_OPENGL_ES3	vendor/imgui/imgui_impl_opengl3.cpp	81;"	d	file:
IMGUI_IMPL_OPENGL_HAS_DRAW_WITH_BASE_VERTEX	vendor/imgui/imgui_impl_opengl3.cpp	113;"	d	file:
IMGUI_IMPL_OPENGL_HAS_DRAW_WITH_BASE_VERTEX	vendor/imgui/imgui_impl_opengl3.cpp	115;"	d	file:
IMGUI_IMPL_OPENGL_LOADER_GLEW	vendor/imgui/imgui_impl_opengl3.h	35;"	d
IMGUI_PAYLOAD_TYPE_COLOR_3F	vendor/imgui/imgui.h	896;"	d
IMGUI_PAYLOAD_TYPE_COLOR_4F	vendor/imgui/imgui.h	897;"	d
IMGUI_STB_NAMESPACE	vendor/imgui/imgui_draw.cpp	/^namespace IMGUI_STB_NAMESPACE$/;"	n	file:
IMGUI_TEST_ENGINE_ITEM_ADD	vendor/imgui/imgui_internal.h	1714;"	d
IMGUI_TEST_ENGINE_ITEM_ADD	vendor/imgui/imgui_internal.h	1718;"	d
IMGUI_TEST_ENGINE_ITEM_INFO	vendor/imgui/imgui_internal.h	1715;"	d
IMGUI_TEST_ENGINE_ITEM_INFO	vendor/imgui/imgui_internal.h	1719;"	d
IMGUI_TEST_ENGINE_LOG	vendor/imgui/imgui_internal.h	1716;"	d
IMGUI_TEST_ENGINE_LOG	vendor/imgui/imgui_internal.h	1720;"	d
IMGUI_VERSION	vendor/imgui/imgui.h	49;"	d
IMGUI_VERSION_NUM	vendor/imgui/imgui.h	50;"	d
IM_ALLOC	vendor/imgui/imgui.h	1203;"	d
IM_ARRAYSIZE	vendor/imgui/imgui.h	75;"	d
IM_ASSERT	vendor/imgui/imgui.h	66;"	d
IM_COL32	vendor/imgui/imgui.h	1727;"	d
IM_COL32_A_MASK	vendor/imgui/imgui.h	1719;"	d
IM_COL32_A_MASK	vendor/imgui/imgui.h	1725;"	d
IM_COL32_A_SHIFT	vendor/imgui/imgui.h	1718;"	d
IM_COL32_A_SHIFT	vendor/imgui/imgui.h	1724;"	d
IM_COL32_BLACK	vendor/imgui/imgui.h	1729;"	d
IM_COL32_BLACK_TRANS	vendor/imgui/imgui.h	1730;"	d
IM_COL32_B_SHIFT	vendor/imgui/imgui.h	1717;"	d
IM_COL32_B_SHIFT	vendor/imgui/imgui.h	1723;"	d
IM_COL32_G_SHIFT	vendor/imgui/imgui.h	1716;"	d
IM_COL32_G_SHIFT	vendor/imgui/imgui.h	1722;"	d
IM_COL32_R_SHIFT	vendor/imgui/imgui.h	1715;"	d
IM_COL32_R_SHIFT	vendor/imgui/imgui.h	1721;"	d
IM_COL32_WHITE	vendor/imgui/imgui.h	1728;"	d
IM_DEBUG_BREAK	vendor/imgui/imgui_internal.h	1698;"	d
IM_DEBUG_BREAK	vendor/imgui/imgui_internal.h	1700;"	d
IM_DEBUG_BREAK	vendor/imgui/imgui_internal.h	1702;"	d
IM_DELETE	vendor/imgui/imgui.h	/^template<typename T> void IM_DELETE(T* p)   { if (p) { p->~T(); ImGui::MemFree(p); } }$/;"	f
IM_F32_TO_INT8_SAT	vendor/imgui/imgui_internal.h	146;"	d
IM_F32_TO_INT8_UNBOUND	vendor/imgui/imgui_internal.h	145;"	d
IM_FIXNORMAL2F	vendor/imgui/imgui_draw.cpp	590;"	d	file:
IM_FMTARGS	vendor/imgui/imgui.h	69;"	d
IM_FMTARGS	vendor/imgui/imgui.h	72;"	d
IM_FMTLIST	vendor/imgui/imgui.h	70;"	d
IM_FMTLIST	vendor/imgui/imgui.h	73;"	d
IM_FREE	vendor/imgui/imgui.h	1204;"	d
IM_MAX	vendor/imgui/imgui_demo.cpp	109;"	d	file:
IM_NEW	vendor/imgui/imgui.h	1206;"	d
IM_NEWLINE	vendor/imgui/imgui_demo.cpp	102;"	d	file:
IM_NEWLINE	vendor/imgui/imgui_demo.cpp	106;"	d	file:
IM_NEWLINE	vendor/imgui/imgui_internal.h	139;"	d
IM_NEWLINE	vendor/imgui/imgui_internal.h	141;"	d
IM_NORMALIZE2F_OVER_ZERO	vendor/imgui/imgui_draw.cpp	589;"	d	file:
IM_OFFSETOF	vendor/imgui/imgui.h	76;"	d
IM_PI	vendor/imgui/imgui_internal.h	137;"	d
IM_PLACEMENT_NEW	vendor/imgui/imgui.h	1205;"	d
IM_S16_MAX	vendor/imgui/imgui_widgets.cpp	/^static const signed short   IM_S16_MAX = 32767;$/;"	v	file:
IM_S16_MIN	vendor/imgui/imgui_widgets.cpp	/^static const signed short   IM_S16_MIN = -32768;$/;"	v	file:
IM_S32_MAX	vendor/imgui/imgui_widgets.cpp	/^static const ImS32          IM_S32_MAX = INT_MAX;    \/\/ (2147483647), (0x7FFFFFFF)$/;"	v	file:
IM_S32_MIN	vendor/imgui/imgui_widgets.cpp	/^static const ImS32          IM_S32_MIN = INT_MIN;    \/\/ (-2147483647 - 1), (0x80000000);$/;"	v	file:
IM_S64_MAX	vendor/imgui/imgui_widgets.cpp	/^static const ImS64          IM_S64_MAX = 9223372036854775807LL;$/;"	v	file:
IM_S64_MAX	vendor/imgui/imgui_widgets.cpp	/^static const ImS64          IM_S64_MAX = LLONG_MAX;  \/\/ (9223372036854775807ll);$/;"	v	file:
IM_S64_MIN	vendor/imgui/imgui_widgets.cpp	/^static const ImS64          IM_S64_MIN = -9223372036854775807LL - 1;$/;"	v	file:
IM_S64_MIN	vendor/imgui/imgui_widgets.cpp	/^static const ImS64          IM_S64_MIN = LLONG_MIN;  \/\/ (-9223372036854775807ll - 1ll);$/;"	v	file:
IM_S8_MAX	vendor/imgui/imgui_widgets.cpp	/^static const signed char    IM_S8_MAX  = 127;$/;"	v	file:
IM_S8_MIN	vendor/imgui/imgui_widgets.cpp	/^static const signed char    IM_S8_MIN  = -128;$/;"	v	file:
IM_STATIC_ASSERT	vendor/imgui/imgui_internal.h	144;"	d
IM_TABSIZE	vendor/imgui/imgui_internal.h	143;"	d
IM_U16_MAX	vendor/imgui/imgui_widgets.cpp	/^static const unsigned short IM_U16_MAX = 0xFFFF;$/;"	v	file:
IM_U16_MIN	vendor/imgui/imgui_widgets.cpp	/^static const unsigned short IM_U16_MIN = 0;$/;"	v	file:
IM_U32_MAX	vendor/imgui/imgui_widgets.cpp	/^static const ImU32          IM_U32_MAX = UINT_MAX;   \/\/ (0xFFFFFFFF)$/;"	v	file:
IM_U32_MIN	vendor/imgui/imgui_widgets.cpp	/^static const ImU32          IM_U32_MIN = 0;$/;"	v	file:
IM_U64_MAX	vendor/imgui/imgui_widgets.cpp	/^static const ImU64          IM_U64_MAX = (2ULL * 9223372036854775807LL + 1);$/;"	v	file:
IM_U64_MAX	vendor/imgui/imgui_widgets.cpp	/^static const ImU64          IM_U64_MAX = ULLONG_MAX; \/\/ (0xFFFFFFFFFFFFFFFFull);$/;"	v	file:
IM_U64_MIN	vendor/imgui/imgui_widgets.cpp	/^static const ImU64          IM_U64_MIN = 0;$/;"	v	file:
IM_U8_MAX	vendor/imgui/imgui_widgets.cpp	/^static const unsigned char  IM_U8_MAX  = 0xFF;$/;"	v	file:
IM_U8_MIN	vendor/imgui/imgui_widgets.cpp	/^static const unsigned char  IM_U8_MIN  = 0;$/;"	v	file:
IM_UNUSED	vendor/imgui/imgui.h	77;"	d
INCLUDE_STB_TEXTEDIT_H	vendor/imgui/imstb_textedit.h	277;"	d
IO	vendor/imgui/imgui_internal.h	/^    ImGuiIO                 IO;$/;"	m	struct:ImGuiContext
IdxBuffer	vendor/imgui/imgui.h	/^    ImVector<ImDrawIdx>     IdxBuffer;          \/\/ Index buffer. Each command consume ImDrawCmd::ElemCount of those$/;"	m	struct:ImDrawList
IdxOffset	vendor/imgui/imgui.h	/^    unsigned int    IdxOffset;              \/\/ Start offset in index buffer. Always equal to sum of ElemCount drawn so far.$/;"	m	struct:ImDrawCmd
ImAcos	vendor/imgui/imgui_internal.h	/^static inline float  ImAcos(float x)                                            { return acosf(x); }$/;"	f
ImAcos01	vendor/imgui/imgui_draw.cpp	/^static inline float ImAcos01(float x)$/;"	f	file:
ImAddClampOverflow	vendor/imgui/imgui_internal.h	/^template<typename T> static inline T ImAddClampOverflow(T a, T b, T mn, T mx)   { if (b < 0 && (a < mn - b)) return mn; if (b > 0 && (a > mx - b)) return mx; return a + b; }$/;"	f
ImAlphaBlendColor	vendor/imgui/imgui_widgets.cpp	/^static inline ImU32 ImAlphaBlendColor(ImU32 col_a, ImU32 col_b)$/;"	f	file:
ImAtan2	vendor/imgui/imgui_internal.h	/^static inline float  ImAtan2(float y, float x)                                  { return atan2f(y, x); }$/;"	f
ImAtof	vendor/imgui/imgui_internal.h	/^static inline double ImAtof(const char* s)                                      { return atof(s); }$/;"	f
ImAtoi	vendor/imgui/imgui_widgets.cpp	/^static const char* ImAtoi(const char* src, TYPE* output)$/;"	f	file:
ImBoolVector	vendor/imgui/imgui_internal.h	/^    ImBoolVector()  { }$/;"	f	struct:ImBoolVector
ImBoolVector	vendor/imgui/imgui_internal.h	/^struct ImBoolVector$/;"	s
ImCeil	vendor/imgui/imgui_internal.h	/^static inline float  ImCeil(float x)                                            { return ceilf(x); }$/;"	f
ImCharIsBlankA	vendor/imgui/imgui_internal.h	/^static inline bool      ImCharIsBlankA(char c)          { return c == ' ' || c == '\\t'; }$/;"	f
ImCharIsBlankW	vendor/imgui/imgui_internal.h	/^static inline bool      ImCharIsBlankW(unsigned int c)  { return c == ' ' || c == '\\t' || c == 0x3000; }$/;"	f
ImClamp	vendor/imgui/imgui_internal.h	/^static inline ImVec2 ImClamp(const ImVec2& v, const ImVec2& mn, ImVec2 mx)      { return ImVec2((v.x < mn.x) ? mn.x : (v.x > mx.x) ? mx.x : v.x, (v.y < mn.y) ? mn.y : (v.y > mx.y) ? mx.y : v.y); }$/;"	f
ImClamp	vendor/imgui/imgui_internal.h	/^template<typename T> static inline T ImClamp(T v, T mn, T mx)                   { return (v < mn) ? mn : (v > mx) ? mx : v; }$/;"	f
ImColor	vendor/imgui/imgui.h	/^    ImColor()                                                       { Value.x = Value.y = Value.z = Value.w = 0.0f; }$/;"	f	struct:ImColor
ImColor	vendor/imgui/imgui.h	/^    ImColor(ImU32 rgba)                                             { float sc = 1.0f\/255.0f; Value.x = (float)((rgba>>IM_COL32_R_SHIFT)&0xFF) * sc; Value.y = (float)((rgba>>IM_COL32_G_SHIFT)&0xFF) * sc; Value.z = (float)((rgba>>IM_COL32_B_SHIFT)&0xFF) * sc; Value.w = (float)((rgba>>IM_COL32_A_SHIFT)&0xFF) * sc; }$/;"	f	struct:ImColor
ImColor	vendor/imgui/imgui.h	/^    ImColor(const ImVec4& col)                                      { Value = col; }$/;"	f	struct:ImColor
ImColor	vendor/imgui/imgui.h	/^    ImColor(float r, float g, float b, float a = 1.0f)              { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }$/;"	f	struct:ImColor
ImColor	vendor/imgui/imgui.h	/^    ImColor(int r, int g, int b, int a = 255)                       { float sc = 1.0f\/255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }$/;"	f	struct:ImColor
ImColor	vendor/imgui/imgui.h	/^struct ImColor$/;"	s
ImCos	vendor/imgui/imgui_internal.h	/^static inline float  ImCos(float x)                                             { return cosf(x); }$/;"	f
ImDot	vendor/imgui/imgui_internal.h	/^static inline float  ImDot(const ImVec2& a, const ImVec2& b)                    { return a.x * b.x + a.y * b.y; }$/;"	f
ImDrawCallback	vendor/imgui/imgui.h	/^typedef void (*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);$/;"	t
ImDrawCallback_ResetRenderState	vendor/imgui/imgui.h	1773;"	d
ImDrawChannel	vendor/imgui/imgui.h	/^struct ImDrawChannel$/;"	s
ImDrawCmd	vendor/imgui/imgui.h	/^    ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = (ImTextureID)NULL; VtxOffset = IdxOffset = 0;  UserCallback = NULL; UserCallbackData = NULL; }$/;"	f	struct:ImDrawCmd
ImDrawCmd	vendor/imgui/imgui.h	/^struct ImDrawCmd$/;"	s
ImDrawCornerFlags	vendor/imgui/imgui.h	/^typedef int ImDrawCornerFlags;      \/\/ -> enum ImDrawCornerFlags_    \/\/ Flags: for ImDrawList::AddRect(), AddRectFilled() etc.$/;"	t
ImDrawCornerFlags_	vendor/imgui/imgui.h	/^enum ImDrawCornerFlags_$/;"	g
ImDrawCornerFlags_All	vendor/imgui/imgui.h	/^    ImDrawCornerFlags_All       = 0xF     \/\/ In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_Bot	vendor/imgui/imgui.h	/^    ImDrawCornerFlags_Bot       = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   \/\/ 0xC$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_BotLeft	vendor/imgui/imgui.h	/^    ImDrawCornerFlags_BotLeft   = 1 << 2, \/\/ 0x4$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_BotRight	vendor/imgui/imgui.h	/^    ImDrawCornerFlags_BotRight  = 1 << 3, \/\/ 0x8$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_Left	vendor/imgui/imgui.h	/^    ImDrawCornerFlags_Left      = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    \/\/ 0x5$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_None	vendor/imgui/imgui.h	/^    ImDrawCornerFlags_None      = 0,$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_Right	vendor/imgui/imgui.h	/^    ImDrawCornerFlags_Right     = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  \/\/ 0xA$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_Top	vendor/imgui/imgui.h	/^    ImDrawCornerFlags_Top       = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   \/\/ 0x3$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_TopLeft	vendor/imgui/imgui.h	/^    ImDrawCornerFlags_TopLeft   = 1 << 0, \/\/ 0x1$/;"	e	enum:ImDrawCornerFlags_
ImDrawCornerFlags_TopRight	vendor/imgui/imgui.h	/^    ImDrawCornerFlags_TopRight  = 1 << 1, \/\/ 0x2$/;"	e	enum:ImDrawCornerFlags_
ImDrawData	vendor/imgui/imgui.h	/^    ImDrawData()    { Valid = false; Clear(); }$/;"	f	struct:ImDrawData
ImDrawData	vendor/imgui/imgui.h	/^struct ImDrawData$/;"	s
ImDrawDataBuilder	vendor/imgui/imgui_internal.h	/^struct ImDrawDataBuilder$/;"	s
ImDrawIdx	vendor/imgui/imgui.h	/^typedef unsigned short ImDrawIdx;$/;"	t
ImDrawList	vendor/imgui/imgui.h	/^    ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }$/;"	f	struct:ImDrawList
ImDrawList	vendor/imgui/imgui.h	/^struct ImDrawList$/;"	s
ImDrawListFlags	vendor/imgui/imgui.h	/^typedef int ImDrawListFlags;        \/\/ -> enum ImDrawListFlags_      \/\/ Flags: for ImDrawList$/;"	t
ImDrawListFlags_	vendor/imgui/imgui.h	/^enum ImDrawListFlags_$/;"	g
ImDrawListFlags_AllowVtxOffset	vendor/imgui/imgui.h	/^    ImDrawListFlags_AllowVtxOffset   = 1 << 2   \/\/ Can emit 'VtxOffset > 0' to allow large meshes. Set when 'ImGuiBackendFlags_RendererHasVtxOffset' is enabled.$/;"	e	enum:ImDrawListFlags_
ImDrawListFlags_AntiAliasedFill	vendor/imgui/imgui.h	/^    ImDrawListFlags_AntiAliasedFill  = 1 << 1,  \/\/ Filled shapes have anti-aliased edges (*2 the number of vertices)$/;"	e	enum:ImDrawListFlags_
ImDrawListFlags_AntiAliasedLines	vendor/imgui/imgui.h	/^    ImDrawListFlags_AntiAliasedLines = 1 << 0,  \/\/ Lines are anti-aliased (*2 the number of triangles for 1.0f wide line, otherwise *3 the number of triangles)$/;"	e	enum:ImDrawListFlags_
ImDrawListFlags_None	vendor/imgui/imgui.h	/^    ImDrawListFlags_None             = 0,$/;"	e	enum:ImDrawListFlags_
ImDrawListSharedData	vendor/imgui/imgui_draw.cpp	/^ImDrawListSharedData::ImDrawListSharedData()$/;"	f	class:ImDrawListSharedData
ImDrawListSharedData	vendor/imgui/imgui_internal.h	/^struct IMGUI_API ImDrawListSharedData$/;"	s
ImDrawListSplitter	vendor/imgui/imgui.h	/^    inline ImDrawListSplitter()  { Clear(); }$/;"	f	struct:ImDrawListSplitter
ImDrawListSplitter	vendor/imgui/imgui.h	/^struct ImDrawListSplitter$/;"	s
ImDrawVert	vendor/imgui/imgui.h	/^struct ImDrawVert$/;"	s
ImFabs	vendor/imgui/imgui_internal.h	/^static inline float  ImFabs(float x)                                            { return fabsf(x); }$/;"	f
ImFileLoadToMemory	vendor/imgui/imgui.cpp	/^void* ImFileLoadToMemory(const char* filename, const char* file_open_mode, size_t* out_file_size, int padding_bytes)$/;"	f
ImFileOpen	vendor/imgui/imgui.cpp	/^FILE* ImFileOpen(const char* filename, const char* mode)$/;"	f
ImFloor	vendor/imgui/imgui_internal.h	/^static inline ImVec2 ImFloor(const ImVec2& v)                                   { return ImVec2((float)(int)v.x, (float)(int)v.y); }$/;"	f
ImFloor	vendor/imgui/imgui_internal.h	/^static inline float  ImFloor(float f)                                           { return (float)(int)f; }$/;"	f
ImFloorStd	vendor/imgui/imgui_internal.h	/^static inline float  ImFloorStd(float x)                                        { return floorf(x); }   \/\/ we already uses our own ImFloor() { return (float)(int)v } internally so the standard one wrapper is named differently (it's used by stb_truetype)$/;"	f
ImFmod	vendor/imgui/imgui_internal.h	/^static inline double ImFmod(double x, double y)                                 { return fmod(x, y); }$/;"	f
ImFmod	vendor/imgui/imgui_internal.h	/^static inline float  ImFmod(float x, float y)                                   { return fmodf(x, y); }$/;"	f
ImFont	vendor/imgui/imgui.h	/^struct ImFont$/;"	s
ImFont	vendor/imgui/imgui_draw.cpp	/^ImFont::ImFont()$/;"	f	class:ImFont
ImFontAtlas	vendor/imgui/imgui.h	/^struct ImFontAtlas$/;"	s
ImFontAtlas	vendor/imgui/imgui_draw.cpp	/^ImFontAtlas::ImFontAtlas()$/;"	f	class:ImFontAtlas
ImFontAtlasBuildFinish	vendor/imgui/imgui_draw.cpp	/^void ImFontAtlasBuildFinish(ImFontAtlas* atlas)$/;"	f
ImFontAtlasBuildMultiplyCalcLookupTable	vendor/imgui/imgui_draw.cpp	/^void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)$/;"	f
ImFontAtlasBuildMultiplyRectAlpha8	vendor/imgui/imgui_draw.cpp	/^void    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)$/;"	f
ImFontAtlasBuildPackCustomRects	vendor/imgui/imgui_draw.cpp	/^void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* stbrp_context_opaque)$/;"	f
ImFontAtlasBuildRegisterDefaultCustomRects	vendor/imgui/imgui_draw.cpp	/^void ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas)$/;"	f
ImFontAtlasBuildRenderDefaultTexData	vendor/imgui/imgui_draw.cpp	/^static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)$/;"	f	file:
ImFontAtlasBuildSetupFont	vendor/imgui/imgui_draw.cpp	/^void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)$/;"	f
ImFontAtlasBuildWithStbTruetype	vendor/imgui/imgui_draw.cpp	/^bool    ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)$/;"	f
ImFontAtlasCustomRect	vendor/imgui/imgui.h	/^    ImFontAtlasCustomRect()         { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0,0); Font = NULL; }$/;"	f	struct:ImFontAtlasCustomRect
ImFontAtlasCustomRect	vendor/imgui/imgui.h	/^struct ImFontAtlasCustomRect$/;"	s
ImFontAtlasFlags	vendor/imgui/imgui.h	/^typedef int ImFontAtlasFlags;       \/\/ -> enum ImFontAtlasFlags_     \/\/ Flags: for ImFontAtlas$/;"	t
ImFontAtlasFlags_	vendor/imgui/imgui.h	/^enum ImFontAtlasFlags_$/;"	g
ImFontAtlasFlags_NoMouseCursors	vendor/imgui/imgui.h	/^    ImFontAtlasFlags_NoMouseCursors     = 1 << 1    \/\/ Don't build software mouse cursors into the atlas$/;"	e	enum:ImFontAtlasFlags_
ImFontAtlasFlags_NoPowerOfTwoHeight	vendor/imgui/imgui.h	/^    ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   \/\/ Don't round the height to next power of two$/;"	e	enum:ImFontAtlasFlags_
ImFontAtlasFlags_None	vendor/imgui/imgui.h	/^    ImFontAtlasFlags_None               = 0,$/;"	e	enum:ImFontAtlasFlags_
ImFontBuildDstData	vendor/imgui/imgui_draw.cpp	/^struct ImFontBuildDstData$/;"	s	file:
ImFontBuildSrcData	vendor/imgui/imgui_draw.cpp	/^struct ImFontBuildSrcData$/;"	s	file:
ImFontConfig	vendor/imgui/imgui.h	/^struct ImFontConfig$/;"	s
ImFontConfig	vendor/imgui/imgui_draw.cpp	/^ImFontConfig::ImFontConfig()$/;"	f	class:ImFontConfig
ImFontGlyph	vendor/imgui/imgui.h	/^struct ImFontGlyph$/;"	s
ImFontGlyphRangesBuilder	vendor/imgui/imgui.h	/^    ImFontGlyphRangesBuilder()          { Clear(); }$/;"	f	struct:ImFontGlyphRangesBuilder
ImFontGlyphRangesBuilder	vendor/imgui/imgui.h	/^struct ImFontGlyphRangesBuilder$/;"	s
ImFormatString	vendor/imgui/imgui.cpp	/^int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)$/;"	f
ImFormatStringV	vendor/imgui/imgui.cpp	/^int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)$/;"	f
ImGetDirQuadrantFromDelta	vendor/imgui/imgui.cpp	/^ImGuiDir ImGetDirQuadrantFromDelta(float dx, float dy)$/;"	f
ImGui	vendor/imgui/imgui.cpp	/^namespace ImGui$/;"	n	file:
ImGui	vendor/imgui/imgui.h	/^namespace ImGui$/;"	n
ImGui	vendor/imgui/imgui_internal.h	/^namespace ImGui$/;"	n
ImGui	vendor/imgui/imgui_widgets.cpp	/^namespace ImGui$/;"	n	file:
ImGuiAxis	vendor/imgui/imgui_internal.h	/^enum ImGuiAxis$/;"	g
ImGuiAxis_None	vendor/imgui/imgui_internal.h	/^    ImGuiAxis_None = -1,$/;"	e	enum:ImGuiAxis
ImGuiAxis_X	vendor/imgui/imgui_internal.h	/^    ImGuiAxis_X = 0,$/;"	e	enum:ImGuiAxis
ImGuiAxis_Y	vendor/imgui/imgui_internal.h	/^    ImGuiAxis_Y = 1$/;"	e	enum:ImGuiAxis
ImGuiBackendFlags	vendor/imgui/imgui.h	/^typedef int ImGuiBackendFlags;      \/\/ -> enum ImGuiBackendFlags_    \/\/ Flags: for io.BackendFlags$/;"	t
ImGuiBackendFlags_	vendor/imgui/imgui.h	/^enum ImGuiBackendFlags_$/;"	g
ImGuiBackendFlags_HasGamepad	vendor/imgui/imgui.h	/^    ImGuiBackendFlags_HasGamepad            = 1 << 0,   \/\/ Back-end Platform supports gamepad and currently has one connected.$/;"	e	enum:ImGuiBackendFlags_
ImGuiBackendFlags_HasMouseCursors	vendor/imgui/imgui.h	/^    ImGuiBackendFlags_HasMouseCursors       = 1 << 1,   \/\/ Back-end Platform supports honoring GetMouseCursor() value to change the OS cursor shape.$/;"	e	enum:ImGuiBackendFlags_
ImGuiBackendFlags_HasSetMousePos	vendor/imgui/imgui.h	/^    ImGuiBackendFlags_HasSetMousePos        = 1 << 2,   \/\/ Back-end Platform supports io.WantSetMousePos requests to reposition the OS mouse position (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).$/;"	e	enum:ImGuiBackendFlags_
ImGuiBackendFlags_None	vendor/imgui/imgui.h	/^    ImGuiBackendFlags_None                  = 0,$/;"	e	enum:ImGuiBackendFlags_
ImGuiBackendFlags_RendererHasVtxOffset	vendor/imgui/imgui.h	/^    ImGuiBackendFlags_RendererHasVtxOffset  = 1 << 3    \/\/ Back-end Renderer supports ImDrawCmd::VtxOffset. This enables output of large meshes (64K+ vertices) while still using 16-bits indices.$/;"	e	enum:ImGuiBackendFlags_
ImGuiButtonFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiButtonFlags;           \/\/ -> enum ImGuiButtonFlags_        \/\/ Flags: for ButtonEx(), ButtonBehavior()$/;"	t
ImGuiButtonFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiButtonFlags_$/;"	g
ImGuiButtonFlags_AlignTextBaseLine	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_AlignTextBaseLine      = 1 << 9,   \/\/ vertically align button to match text baseline - ButtonEx() only \/\/ FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_AllowItemOverlap	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_AllowItemOverlap       = 1 << 6,   \/\/ require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_Disabled	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_Disabled               = 1 << 8,   \/\/ disable interactions$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_DontClosePopups	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_DontClosePopups        = 1 << 7,   \/\/ disable automatically closing parent popup on press \/\/ [UNUSED]$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_FlattenChildren	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_FlattenChildren        = 1 << 5,   \/\/ allow interactions even if a child window is overlapping$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_NoHoldingActiveID	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_NoHoldingActiveID      = 1 << 11,  \/\/ don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_NoHoveredOnNav	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_NoHoveredOnNav         = 1 << 14   \/\/ don't report as hovered when navigated on$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_NoKeyModifiers	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_NoKeyModifiers         = 1 << 10,  \/\/ disable interaction if a key modifier is held$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_NoNavFocus	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_NoNavFocus             = 1 << 13,  \/\/ don't override navigation focus when activated$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_None                   = 0,$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnClick	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_PressedOnClick         = 1 << 2,   \/\/ return true on click (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnClickRelease	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_PressedOnClickRelease  = 1 << 1,   \/\/ [Default] return true on click + release on same item$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnDoubleClick	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_PressedOnDoubleClick   = 1 << 4,   \/\/ return true on double-click (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnDragDropHold	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_PressedOnDragDropHold  = 1 << 12,  \/\/ press when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_PressedOnRelease	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_PressedOnRelease       = 1 << 3,   \/\/ return true on release (default requires click+release)$/;"	e	enum:ImGuiButtonFlags_
ImGuiButtonFlags_Repeat	vendor/imgui/imgui_internal.h	/^    ImGuiButtonFlags_Repeat                 = 1 << 0,   \/\/ hold to repeat$/;"	e	enum:ImGuiButtonFlags_
ImGuiCol	vendor/imgui/imgui.h	/^typedef int ImGuiCol;               \/\/ -> enum ImGuiCol_             \/\/ Enum: A color identifier for styling$/;"	t
ImGuiCol_	vendor/imgui/imgui.h	/^enum ImGuiCol_$/;"	g
ImGuiCol_Border	vendor/imgui/imgui.h	/^    ImGuiCol_Border,$/;"	e	enum:ImGuiCol_
ImGuiCol_BorderShadow	vendor/imgui/imgui.h	/^    ImGuiCol_BorderShadow,$/;"	e	enum:ImGuiCol_
ImGuiCol_Button	vendor/imgui/imgui.h	/^    ImGuiCol_Button,$/;"	e	enum:ImGuiCol_
ImGuiCol_ButtonActive	vendor/imgui/imgui.h	/^    ImGuiCol_ButtonActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ButtonHovered	vendor/imgui/imgui.h	/^    ImGuiCol_ButtonHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_COUNT	vendor/imgui/imgui.h	/^    ImGuiCol_COUNT$/;"	e	enum:ImGuiCol_
ImGuiCol_CheckMark	vendor/imgui/imgui.h	/^    ImGuiCol_CheckMark,$/;"	e	enum:ImGuiCol_
ImGuiCol_ChildBg	vendor/imgui/imgui.h	/^    ImGuiCol_ChildBg,               \/\/ Background of child windows$/;"	e	enum:ImGuiCol_
ImGuiCol_ChildWindowBg	vendor/imgui/imgui.h	/^    , ImGuiCol_ChildWindowBg = ImGuiCol_ChildBg                                      \/\/ [renamed in 1.53]$/;"	e	enum:ImGuiCol_
ImGuiCol_DragDropTarget	vendor/imgui/imgui.h	/^    ImGuiCol_DragDropTarget,$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBg	vendor/imgui/imgui.h	/^    ImGuiCol_FrameBg,               \/\/ Background of checkbox, radio button, plot, slider, text input$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBgActive	vendor/imgui/imgui.h	/^    ImGuiCol_FrameBgActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_FrameBgHovered	vendor/imgui/imgui.h	/^    ImGuiCol_FrameBgHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_Header	vendor/imgui/imgui.h	/^    ImGuiCol_Header,                \/\/ Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem$/;"	e	enum:ImGuiCol_
ImGuiCol_HeaderActive	vendor/imgui/imgui.h	/^    ImGuiCol_HeaderActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_HeaderHovered	vendor/imgui/imgui.h	/^    ImGuiCol_HeaderHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_MenuBarBg	vendor/imgui/imgui.h	/^    ImGuiCol_MenuBarBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_ModalWindowDarkening	vendor/imgui/imgui.h	/^    , ImGuiCol_ModalWindowDarkening = ImGuiCol_ModalWindowDimBg                      \/\/ [renamed in 1.63]$/;"	e	enum:ImGuiCol_
ImGuiCol_ModalWindowDimBg	vendor/imgui/imgui.h	/^    ImGuiCol_ModalWindowDimBg,      \/\/ Darken\/colorize entire screen behind a modal window, when one is active$/;"	e	enum:ImGuiCol_
ImGuiCol_NavHighlight	vendor/imgui/imgui.h	/^    ImGuiCol_NavHighlight,          \/\/ Gamepad\/keyboard: current highlighted item$/;"	e	enum:ImGuiCol_
ImGuiCol_NavWindowingDimBg	vendor/imgui/imgui.h	/^    ImGuiCol_NavWindowingDimBg,     \/\/ Darken\/colorize entire screen behind the CTRL+TAB window list, when active$/;"	e	enum:ImGuiCol_
ImGuiCol_NavWindowingHighlight	vendor/imgui/imgui.h	/^    ImGuiCol_NavWindowingHighlight, \/\/ Highlight window when using CTRL+TAB$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotHistogram	vendor/imgui/imgui.h	/^    ImGuiCol_PlotHistogram,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotHistogramHovered	vendor/imgui/imgui.h	/^    ImGuiCol_PlotHistogramHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotLines	vendor/imgui/imgui.h	/^    ImGuiCol_PlotLines,$/;"	e	enum:ImGuiCol_
ImGuiCol_PlotLinesHovered	vendor/imgui/imgui.h	/^    ImGuiCol_PlotLinesHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_PopupBg	vendor/imgui/imgui.h	/^    ImGuiCol_PopupBg,               \/\/ Background of popups, menus, tooltips windows$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGrip	vendor/imgui/imgui.h	/^    ImGuiCol_ResizeGrip,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGripActive	vendor/imgui/imgui.h	/^    ImGuiCol_ResizeGripActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ResizeGripHovered	vendor/imgui/imgui.h	/^    ImGuiCol_ResizeGripHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarBg	vendor/imgui/imgui.h	/^    ImGuiCol_ScrollbarBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrab	vendor/imgui/imgui.h	/^    ImGuiCol_ScrollbarGrab,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrabActive	vendor/imgui/imgui.h	/^    ImGuiCol_ScrollbarGrabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_ScrollbarGrabHovered	vendor/imgui/imgui.h	/^    ImGuiCol_ScrollbarGrabHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_Separator	vendor/imgui/imgui.h	/^    ImGuiCol_Separator,$/;"	e	enum:ImGuiCol_
ImGuiCol_SeparatorActive	vendor/imgui/imgui.h	/^    ImGuiCol_SeparatorActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_SeparatorHovered	vendor/imgui/imgui.h	/^    ImGuiCol_SeparatorHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_SliderGrab	vendor/imgui/imgui.h	/^    ImGuiCol_SliderGrab,$/;"	e	enum:ImGuiCol_
ImGuiCol_SliderGrabActive	vendor/imgui/imgui.h	/^    ImGuiCol_SliderGrabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_Tab	vendor/imgui/imgui.h	/^    ImGuiCol_Tab,$/;"	e	enum:ImGuiCol_
ImGuiCol_TabActive	vendor/imgui/imgui.h	/^    ImGuiCol_TabActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_TabHovered	vendor/imgui/imgui.h	/^    ImGuiCol_TabHovered,$/;"	e	enum:ImGuiCol_
ImGuiCol_TabUnfocused	vendor/imgui/imgui.h	/^    ImGuiCol_TabUnfocused,$/;"	e	enum:ImGuiCol_
ImGuiCol_TabUnfocusedActive	vendor/imgui/imgui.h	/^    ImGuiCol_TabUnfocusedActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_Text	vendor/imgui/imgui.h	/^    ImGuiCol_Text,$/;"	e	enum:ImGuiCol_
ImGuiCol_TextDisabled	vendor/imgui/imgui.h	/^    ImGuiCol_TextDisabled,$/;"	e	enum:ImGuiCol_
ImGuiCol_TextSelectedBg	vendor/imgui/imgui.h	/^    ImGuiCol_TextSelectedBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBg	vendor/imgui/imgui.h	/^    ImGuiCol_TitleBg,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBgActive	vendor/imgui/imgui.h	/^    ImGuiCol_TitleBgActive,$/;"	e	enum:ImGuiCol_
ImGuiCol_TitleBgCollapsed	vendor/imgui/imgui.h	/^    ImGuiCol_TitleBgCollapsed,$/;"	e	enum:ImGuiCol_
ImGuiCol_WindowBg	vendor/imgui/imgui.h	/^    ImGuiCol_WindowBg,              \/\/ Background of normal windows$/;"	e	enum:ImGuiCol_
ImGuiColorEditFlags	vendor/imgui/imgui.h	/^typedef int ImGuiColorEditFlags;    \/\/ -> enum ImGuiColorEditFlags_  \/\/ Flags: for ColorEdit4(), ColorPicker4() etc.$/;"	t
ImGuiColorEditFlags_	vendor/imgui/imgui.h	/^enum ImGuiColorEditFlags_$/;"	g
ImGuiColorEditFlags_AlphaBar	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_AlphaBar        = 1 << 16,  \/\/              \/\/ ColorEdit, ColorPicker: show vertical alpha bar\/gradient in picker.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_AlphaPreview	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_AlphaPreview    = 1 << 17,  \/\/              \/\/ ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_AlphaPreviewHalf	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_AlphaPreviewHalf= 1 << 18,  \/\/              \/\/ ColorEdit, ColorPicker, ColorButton: display half opaque \/ half checkerboard, instead of opaque.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_DisplayHSV	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_DisplayHSV      = 1 << 21,  \/\/ [Display]    \/\/ "$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_DisplayHex	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_DisplayHex      = 1 << 22,  \/\/ [Display]    \/\/ "$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_DisplayRGB	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_DisplayRGB      = 1 << 20,  \/\/ [Display]    \/\/ ColorEdit: override _display_ type among RGB\/HSV\/Hex. ColorPicker: select any combination using one or more of RGB\/HSV\/Hex.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_Float	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_Float           = 1 << 24,  \/\/ [DataType]   \/\/ ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_HDR	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_HDR             = 1 << 19,  \/\/              \/\/ (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_HEX	vendor/imgui/imgui.h	/^    , ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  \/\/ [renamed in 1.69]$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_HSV	vendor/imgui/imgui.h	/^    , ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  \/\/ [renamed in 1.69]$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_InputHSV	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_InputHSV        = 1 << 28,  \/\/ [Input]      \/\/ ColorEdit, ColorPicker: input and output data in HSV format.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_InputRGB	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_InputRGB        = 1 << 27,  \/\/ [Input]      \/\/ ColorEdit, ColorPicker: input and output data in RGB format.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoAlpha	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_NoAlpha         = 1 << 1,   \/\/              \/\/ ColorEdit, ColorPicker, ColorButton: ignore Alpha component (will only read 3 components from the input pointer).$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoDragDrop	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_NoDragDrop      = 1 << 9,   \/\/              \/\/ ColorEdit: disable drag and drop target. ColorButton: disable drag and drop source.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoInputs	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_NoInputs        = 1 << 5,   \/\/              \/\/ ColorEdit, ColorPicker: disable inputs sliders\/text widgets (e.g. to show only the small preview colored square).$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoLabel	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_NoLabel         = 1 << 7,   \/\/              \/\/ ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoOptions	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_NoOptions       = 1 << 3,   \/\/              \/\/ ColorEdit: disable toggling options menu when right-clicking on inputs\/small preview.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoPicker	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_NoPicker        = 1 << 2,   \/\/              \/\/ ColorEdit: disable picker when clicking on colored square.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoSidePreview	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_NoSidePreview   = 1 << 8,   \/\/              \/\/ ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoSmallPreview	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_NoSmallPreview  = 1 << 4,   \/\/              \/\/ ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_NoTooltip	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_NoTooltip       = 1 << 6,   \/\/              \/\/ ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_None	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_None            = 0,$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_PickerHueBar	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_PickerHueBar    = 1 << 25,  \/\/ [Picker]     \/\/ ColorPicker: bar for Hue, rectangle for Sat\/Value.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_PickerHueWheel	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_PickerHueWheel  = 1 << 26,  \/\/ [Picker]     \/\/ ColorPicker: wheel for Hue, triangle for Sat\/Value.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_RGB	vendor/imgui/imgui.h	/^    , ImGuiColorEditFlags_RGB = ImGuiColorEditFlags_DisplayRGB, ImGuiColorEditFlags_HSV = ImGuiColorEditFlags_DisplayHSV, ImGuiColorEditFlags_HEX = ImGuiColorEditFlags_DisplayHex  \/\/ [renamed in 1.69]$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags_Uint8	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags_Uint8           = 1 << 23,  \/\/ [DataType]   \/\/ ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags__DataTypeMask	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags__DataTypeMask   = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_Float,$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags__DisplayMask	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags__DisplayMask    = ImGuiColorEditFlags_DisplayRGB|ImGuiColorEditFlags_DisplayHSV|ImGuiColorEditFlags_DisplayHex,$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags__InputMask	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags__InputMask      = ImGuiColorEditFlags_InputRGB|ImGuiColorEditFlags_InputHSV$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags__OptionsDefault	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8|ImGuiColorEditFlags_DisplayRGB|ImGuiColorEditFlags_InputRGB|ImGuiColorEditFlags_PickerHueBar,$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorEditFlags__PickerMask	vendor/imgui/imgui.h	/^    ImGuiColorEditFlags__PickerMask     = ImGuiColorEditFlags_PickerHueWheel|ImGuiColorEditFlags_PickerHueBar,$/;"	e	enum:ImGuiColorEditFlags_
ImGuiColorMod	vendor/imgui/imgui_internal.h	/^struct ImGuiColorMod$/;"	s
ImGuiColumnData	vendor/imgui/imgui_internal.h	/^    ImGuiColumnData()   { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = ImGuiColumnsFlags_None; }$/;"	f	struct:ImGuiColumnData
ImGuiColumnData	vendor/imgui/imgui_internal.h	/^struct ImGuiColumnData$/;"	s
ImGuiColumns	vendor/imgui/imgui_internal.h	/^    ImGuiColumns()      { Clear(); }$/;"	f	struct:ImGuiColumns
ImGuiColumns	vendor/imgui/imgui_internal.h	/^struct ImGuiColumns$/;"	s
ImGuiColumnsFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiColumnsFlags;          \/\/ -> enum ImGuiColumnsFlags_       \/\/ Flags: BeginColumns()$/;"	t
ImGuiColumnsFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiColumnsFlags_$/;"	g
ImGuiColumnsFlags_GrowParentContentsSize	vendor/imgui/imgui_internal.h	/^    ImGuiColumnsFlags_GrowParentContentsSize= 1 << 4    \/\/ (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.$/;"	e	enum:ImGuiColumnsFlags_
ImGuiColumnsFlags_NoBorder	vendor/imgui/imgui_internal.h	/^    ImGuiColumnsFlags_NoBorder              = 1 << 0,   \/\/ Disable column dividers$/;"	e	enum:ImGuiColumnsFlags_
ImGuiColumnsFlags_NoForceWithinWindow	vendor/imgui/imgui_internal.h	/^    ImGuiColumnsFlags_NoForceWithinWindow   = 1 << 3,   \/\/ Disable forcing columns to fit within window$/;"	e	enum:ImGuiColumnsFlags_
ImGuiColumnsFlags_NoPreserveWidths	vendor/imgui/imgui_internal.h	/^    ImGuiColumnsFlags_NoPreserveWidths      = 1 << 2,   \/\/ Disable column width preservation when adjusting columns$/;"	e	enum:ImGuiColumnsFlags_
ImGuiColumnsFlags_NoResize	vendor/imgui/imgui_internal.h	/^    ImGuiColumnsFlags_NoResize              = 1 << 1,   \/\/ Disable resizing columns when clicking on the dividers$/;"	e	enum:ImGuiColumnsFlags_
ImGuiColumnsFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiColumnsFlags_None                  = 0,$/;"	e	enum:ImGuiColumnsFlags_
ImGuiComboFlags	vendor/imgui/imgui.h	/^typedef int ImGuiComboFlags;        \/\/ -> enum ImGuiComboFlags_      \/\/ Flags: for BeginCombo()$/;"	t
ImGuiComboFlags_	vendor/imgui/imgui.h	/^enum ImGuiComboFlags_$/;"	g
ImGuiComboFlags_HeightLarge	vendor/imgui/imgui.h	/^    ImGuiComboFlags_HeightLarge             = 1 << 3,   \/\/ Max ~20 items visible$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_HeightLargest	vendor/imgui/imgui.h	/^    ImGuiComboFlags_HeightLargest           = 1 << 4,   \/\/ As many fitting items as possible$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_HeightMask_	vendor/imgui/imgui.h	/^    ImGuiComboFlags_HeightMask_             = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_HeightRegular	vendor/imgui/imgui.h	/^    ImGuiComboFlags_HeightRegular           = 1 << 2,   \/\/ Max ~8 items visible (default)$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_HeightSmall	vendor/imgui/imgui.h	/^    ImGuiComboFlags_HeightSmall             = 1 << 1,   \/\/ Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_NoArrowButton	vendor/imgui/imgui.h	/^    ImGuiComboFlags_NoArrowButton           = 1 << 5,   \/\/ Display on the preview box without the square arrow button$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_NoPreview	vendor/imgui/imgui.h	/^    ImGuiComboFlags_NoPreview               = 1 << 6,   \/\/ Display only a square arrow button$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_None	vendor/imgui/imgui.h	/^    ImGuiComboFlags_None                    = 0,$/;"	e	enum:ImGuiComboFlags_
ImGuiComboFlags_PopupAlignLeft	vendor/imgui/imgui.h	/^    ImGuiComboFlags_PopupAlignLeft          = 1 << 0,   \/\/ Align the popup toward the left by default$/;"	e	enum:ImGuiComboFlags_
ImGuiCond	vendor/imgui/imgui.h	/^typedef int ImGuiCond;              \/\/ -> enum ImGuiCond_            \/\/ Enum: A condition for many Set*() functions$/;"	t
ImGuiCond_	vendor/imgui/imgui.h	/^enum ImGuiCond_$/;"	g
ImGuiCond_Always	vendor/imgui/imgui.h	/^    ImGuiCond_Always        = 1 << 0,   \/\/ Set the variable$/;"	e	enum:ImGuiCond_
ImGuiCond_Appearing	vendor/imgui/imgui.h	/^    ImGuiCond_Appearing     = 1 << 3    \/\/ Set the variable if the object\/window is appearing after being hidden\/inactive (or the first time)$/;"	e	enum:ImGuiCond_
ImGuiCond_FirstUseEver	vendor/imgui/imgui.h	/^    ImGuiCond_FirstUseEver  = 1 << 2,   \/\/ Set the variable if the object\/window has no persistently saved data (no entry in .ini file)$/;"	e	enum:ImGuiCond_
ImGuiCond_Once	vendor/imgui/imgui.h	/^    ImGuiCond_Once          = 1 << 1,   \/\/ Set the variable once per runtime session (only the first call with succeed)$/;"	e	enum:ImGuiCond_
ImGuiConfigFlags	vendor/imgui/imgui.h	/^typedef int ImGuiConfigFlags;       \/\/ -> enum ImGuiConfigFlags_     \/\/ Flags: for io.ConfigFlags$/;"	t
ImGuiConfigFlags_	vendor/imgui/imgui.h	/^enum ImGuiConfigFlags_$/;"	g
ImGuiConfigFlags_IsSRGB	vendor/imgui/imgui.h	/^    ImGuiConfigFlags_IsSRGB                 = 1 << 20,  \/\/ Application is SRGB-aware.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_IsTouchScreen	vendor/imgui/imgui.h	/^    ImGuiConfigFlags_IsTouchScreen          = 1 << 21   \/\/ Application is using a touch screen instead of a mouse.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NavEnableGamepad	vendor/imgui/imgui.h	/^    ImGuiConfigFlags_NavEnableGamepad       = 1 << 1,   \/\/ Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NavEnableKeyboard	vendor/imgui/imgui.h	/^    ImGuiConfigFlags_NavEnableKeyboard      = 1 << 0,   \/\/ Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeysDown[].$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NavEnableSetMousePos	vendor/imgui/imgui.h	/^    ImGuiConfigFlags_NavEnableSetMousePos   = 1 << 2,   \/\/ Instruct navigation to move the mouse cursor. May be useful on TV\/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NavNoCaptureKeyboard	vendor/imgui/imgui.h	/^    ImGuiConfigFlags_NavNoCaptureKeyboard   = 1 << 3,   \/\/ Instruct navigation to not set the io.WantCaptureKeyboard flag when io.NavActive is set.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NoMouse	vendor/imgui/imgui.h	/^    ImGuiConfigFlags_NoMouse                = 1 << 4,   \/\/ Instruct imgui to clear mouse position\/buttons in NewFrame(). This allows ignoring the mouse information set by the back-end.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_NoMouseCursorChange	vendor/imgui/imgui.h	/^    ImGuiConfigFlags_NoMouseCursorChange    = 1 << 5,   \/\/ Instruct back-end to not alter mouse cursor shape and visibility. Use if the back-end cursor changes are interfering with yours and you don't want to use SetMouseCursor() to change mouse cursor. You may want to honor requests from imgui by reading GetMouseCursor() yourself instead.$/;"	e	enum:ImGuiConfigFlags_
ImGuiConfigFlags_None	vendor/imgui/imgui.h	/^    ImGuiConfigFlags_None                   = 0,$/;"	e	enum:ImGuiConfigFlags_
ImGuiContext	vendor/imgui/imgui_internal.h	/^    ImGuiContext(ImFontAtlas* shared_font_atlas) : BackgroundDrawList(&DrawListSharedData), ForegroundDrawList(&DrawListSharedData)$/;"	f	struct:ImGuiContext
ImGuiContext	vendor/imgui/imgui_internal.h	/^struct ImGuiContext$/;"	s
ImGuiDataType	vendor/imgui/imgui.h	/^typedef int ImGuiDataType;          \/\/ -> enum ImGuiDataType_        \/\/ Enum: A primary data type$/;"	t
ImGuiDataTypeInfo	vendor/imgui/imgui_internal.h	/^struct ImGuiDataTypeInfo$/;"	s
ImGuiDataType_	vendor/imgui/imgui.h	/^enum ImGuiDataType_$/;"	g
ImGuiDataType_COUNT	vendor/imgui/imgui.h	/^    ImGuiDataType_COUNT$/;"	e	enum:ImGuiDataType_
ImGuiDataType_COUNT	vendor/imgui/imgui_widgets.cpp	/^IM_STATIC_ASSERT(IM_ARRAYSIZE(GDataTypeInfo) == ImGuiDataType_COUNT);$/;"	v
ImGuiDataType_Double	vendor/imgui/imgui.h	/^    ImGuiDataType_Double,   \/\/ double$/;"	e	enum:ImGuiDataType_
ImGuiDataType_Float	vendor/imgui/imgui.h	/^    ImGuiDataType_Float,    \/\/ float$/;"	e	enum:ImGuiDataType_
ImGuiDataType_S16	vendor/imgui/imgui.h	/^    ImGuiDataType_S16,      \/\/ short$/;"	e	enum:ImGuiDataType_
ImGuiDataType_S32	vendor/imgui/imgui.h	/^    ImGuiDataType_S32,      \/\/ int$/;"	e	enum:ImGuiDataType_
ImGuiDataType_S64	vendor/imgui/imgui.h	/^    ImGuiDataType_S64,      \/\/ long long \/ __int64$/;"	e	enum:ImGuiDataType_
ImGuiDataType_S8	vendor/imgui/imgui.h	/^    ImGuiDataType_S8,       \/\/ signed char \/ char (with sensible compilers)$/;"	e	enum:ImGuiDataType_
ImGuiDataType_U16	vendor/imgui/imgui.h	/^    ImGuiDataType_U16,      \/\/ unsigned short$/;"	e	enum:ImGuiDataType_
ImGuiDataType_U32	vendor/imgui/imgui.h	/^    ImGuiDataType_U32,      \/\/ unsigned int$/;"	e	enum:ImGuiDataType_
ImGuiDataType_U64	vendor/imgui/imgui.h	/^    ImGuiDataType_U64,      \/\/ unsigned long long \/ unsigned __int64$/;"	e	enum:ImGuiDataType_
ImGuiDataType_U8	vendor/imgui/imgui.h	/^    ImGuiDataType_U8,       \/\/ unsigned char$/;"	e	enum:ImGuiDataType_
ImGuiDir	vendor/imgui/imgui.h	/^typedef int ImGuiDir;               \/\/ -> enum ImGuiDir_             \/\/ Enum: A cardinal direction$/;"	t
ImGuiDir_	vendor/imgui/imgui.h	/^enum ImGuiDir_$/;"	g
ImGuiDir_COUNT	vendor/imgui/imgui.h	/^    ImGuiDir_COUNT$/;"	e	enum:ImGuiDir_
ImGuiDir_Down	vendor/imgui/imgui.h	/^    ImGuiDir_Down    = 3,$/;"	e	enum:ImGuiDir_
ImGuiDir_Left	vendor/imgui/imgui.h	/^    ImGuiDir_Left    = 0,$/;"	e	enum:ImGuiDir_
ImGuiDir_None	vendor/imgui/imgui.h	/^    ImGuiDir_None    = -1,$/;"	e	enum:ImGuiDir_
ImGuiDir_Right	vendor/imgui/imgui.h	/^    ImGuiDir_Right   = 1,$/;"	e	enum:ImGuiDir_
ImGuiDir_Up	vendor/imgui/imgui.h	/^    ImGuiDir_Up      = 2,$/;"	e	enum:ImGuiDir_
ImGuiDragDropFlags	vendor/imgui/imgui.h	/^typedef int ImGuiDragDropFlags;     \/\/ -> enum ImGuiDragDropFlags_   \/\/ Flags: for BeginDragDropSource(), AcceptDragDropPayload()$/;"	t
ImGuiDragDropFlags_	vendor/imgui/imgui.h	/^enum ImGuiDragDropFlags_$/;"	g
ImGuiDragDropFlags_AcceptBeforeDelivery	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_AcceptBeforeDelivery         = 1 << 10,  \/\/ AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_AcceptNoDrawDefaultRect	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_AcceptNoDrawDefaultRect      = 1 << 11,  \/\/ Do not draw the default highlight rectangle when hovering over target.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_AcceptNoPreviewTooltip	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_AcceptNoPreviewTooltip       = 1 << 12,  \/\/ Request hiding the BeginDragDropSource tooltip from the BeginDragDropTarget site.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_AcceptPeekOnly	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_AcceptPeekOnly               = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  \/\/ For peeking ahead and inspecting the payload before delivery.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_None	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_None                         = 0,$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceAllowNullID	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_SourceAllowNullID            = 1 << 3,   \/\/ Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceAutoExpirePayload	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_SourceAutoExpirePayload      = 1 << 5,   \/\/ Automatically expire the payload if the source cease to be submitted (otherwise payloads are persisting while being dragged)$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceExtern	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_SourceExtern                 = 1 << 4,   \/\/ External source (from outside of dear imgui), won't attempt to read current item\/window info. Will always return true. Only one Extern source can be active simultaneously.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceNoDisableHover	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_SourceNoDisableHover         = 1 << 1,   \/\/ By default, when dragging we clear data so that IsItemHovered() will return false, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceNoHoldToOpenOthers	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_SourceNoHoldToOpenOthers     = 1 << 2,   \/\/ Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragDropFlags_SourceNoPreviewTooltip	vendor/imgui/imgui.h	/^    ImGuiDragDropFlags_SourceNoPreviewTooltip       = 1 << 0,   \/\/ By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.$/;"	e	enum:ImGuiDragDropFlags_
ImGuiDragFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiDragFlags;             \/\/ -> enum ImGuiDragFlags_          \/\/ Flags: for DragBehavior()$/;"	t
ImGuiDragFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiDragFlags_$/;"	g
ImGuiDragFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiDragFlags_None                     = 0,$/;"	e	enum:ImGuiDragFlags_
ImGuiDragFlags_Vertical	vendor/imgui/imgui_internal.h	/^    ImGuiDragFlags_Vertical                 = 1 << 0$/;"	e	enum:ImGuiDragFlags_
ImGuiFocusedFlags	vendor/imgui/imgui.h	/^typedef int ImGuiFocusedFlags;      \/\/ -> enum ImGuiFocusedFlags_    \/\/ Flags: for IsWindowFocused()$/;"	t
ImGuiFocusedFlags_	vendor/imgui/imgui.h	/^enum ImGuiFocusedFlags_$/;"	g
ImGuiFocusedFlags_AnyWindow	vendor/imgui/imgui.h	/^    ImGuiFocusedFlags_AnyWindow                     = 1 << 2,   \/\/ IsWindowFocused(): Return true if any window is focused. Important: If you are trying to tell how to dispatch your low-level inputs, do NOT use this. Use ImGui::GetIO().WantCaptureMouse instead.$/;"	e	enum:ImGuiFocusedFlags_
ImGuiFocusedFlags_ChildWindows	vendor/imgui/imgui.h	/^    ImGuiFocusedFlags_ChildWindows                  = 1 << 0,   \/\/ IsWindowFocused(): Return true if any children of the window is focused$/;"	e	enum:ImGuiFocusedFlags_
ImGuiFocusedFlags_None	vendor/imgui/imgui.h	/^    ImGuiFocusedFlags_None                          = 0,$/;"	e	enum:ImGuiFocusedFlags_
ImGuiFocusedFlags_RootAndChildWindows	vendor/imgui/imgui.h	/^    ImGuiFocusedFlags_RootAndChildWindows           = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows$/;"	e	enum:ImGuiFocusedFlags_
ImGuiFocusedFlags_RootWindow	vendor/imgui/imgui.h	/^    ImGuiFocusedFlags_RootWindow                    = 1 << 1,   \/\/ IsWindowFocused(): Test from root window (top most parent of the current hierarchy)$/;"	e	enum:ImGuiFocusedFlags_
ImGuiGroupData	vendor/imgui/imgui_internal.h	/^struct ImGuiGroupData$/;"	s
ImGuiHoveredFlags	vendor/imgui/imgui.h	/^typedef int ImGuiHoveredFlags;      \/\/ -> enum ImGuiHoveredFlags_    \/\/ Flags: for IsItemHovered(), IsWindowHovered() etc.$/;"	t
ImGuiHoveredFlags_	vendor/imgui/imgui.h	/^enum ImGuiHoveredFlags_$/;"	g
ImGuiHoveredFlags_AllowWhenBlockedByActiveItem	vendor/imgui/imgui.h	/^    ImGuiHoveredFlags_AllowWhenBlockedByActiveItem  = 1 << 5,   \/\/ Return true even if an active item is blocking access to this item\/window. Useful for Drag and Drop patterns.$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_AllowWhenBlockedByPopup	vendor/imgui/imgui.h	/^    ImGuiHoveredFlags_AllowWhenBlockedByPopup       = 1 << 3,   \/\/ Return true even if a popup window is normally blocking access to this item\/window$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_AllowWhenDisabled	vendor/imgui/imgui.h	/^    ImGuiHoveredFlags_AllowWhenDisabled             = 1 << 7,   \/\/ Return true even if the item is disabled$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_AllowWhenOverlapped	vendor/imgui/imgui.h	/^    ImGuiHoveredFlags_AllowWhenOverlapped           = 1 << 6,   \/\/ Return true even if the position is obstructed or overlapped by another window$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_AnyWindow	vendor/imgui/imgui.h	/^    ImGuiHoveredFlags_AnyWindow                     = 1 << 2,   \/\/ IsWindowHovered() only: Return true if any window is hovered$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_ChildWindows	vendor/imgui/imgui.h	/^    ImGuiHoveredFlags_ChildWindows                  = 1 << 0,   \/\/ IsWindowHovered() only: Return true if any children of the window is hovered$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_None	vendor/imgui/imgui.h	/^    ImGuiHoveredFlags_None                          = 0,        \/\/ Return true if directly over the item\/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_RectOnly	vendor/imgui/imgui.h	/^    ImGuiHoveredFlags_RectOnly                      = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_RootAndChildWindows	vendor/imgui/imgui.h	/^    ImGuiHoveredFlags_RootAndChildWindows           = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows$/;"	e	enum:ImGuiHoveredFlags_
ImGuiHoveredFlags_RootWindow	vendor/imgui/imgui.h	/^    ImGuiHoveredFlags_RootWindow                    = 1 << 1,   \/\/ IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)$/;"	e	enum:ImGuiHoveredFlags_
ImGuiID	vendor/imgui/imgui.h	/^typedef unsigned int ImGuiID;       \/\/ Unique ID used by widgets (typically hashed from a stack of string)$/;"	t
ImGuiIO	vendor/imgui/imgui.cpp	/^ImGuiIO::ImGuiIO()$/;"	f	class:ImGuiIO
ImGuiIO	vendor/imgui/imgui.h	/^struct ImGuiIO$/;"	s
ImGuiInputReadMode	vendor/imgui/imgui_internal.h	/^enum ImGuiInputReadMode$/;"	g
ImGuiInputReadMode_Down	vendor/imgui/imgui_internal.h	/^    ImGuiInputReadMode_Down,$/;"	e	enum:ImGuiInputReadMode
ImGuiInputReadMode_Pressed	vendor/imgui/imgui_internal.h	/^    ImGuiInputReadMode_Pressed,$/;"	e	enum:ImGuiInputReadMode
ImGuiInputReadMode_Released	vendor/imgui/imgui_internal.h	/^    ImGuiInputReadMode_Released,$/;"	e	enum:ImGuiInputReadMode
ImGuiInputReadMode_Repeat	vendor/imgui/imgui_internal.h	/^    ImGuiInputReadMode_Repeat,$/;"	e	enum:ImGuiInputReadMode
ImGuiInputReadMode_RepeatFast	vendor/imgui/imgui_internal.h	/^    ImGuiInputReadMode_RepeatFast$/;"	e	enum:ImGuiInputReadMode
ImGuiInputReadMode_RepeatSlow	vendor/imgui/imgui_internal.h	/^    ImGuiInputReadMode_RepeatSlow,$/;"	e	enum:ImGuiInputReadMode
ImGuiInputSource	vendor/imgui/imgui_internal.h	/^enum ImGuiInputSource$/;"	g
ImGuiInputSource_COUNT	vendor/imgui/imgui_internal.h	/^    ImGuiInputSource_COUNT$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_Mouse	vendor/imgui/imgui_internal.h	/^    ImGuiInputSource_Mouse,$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_Nav	vendor/imgui/imgui_internal.h	/^    ImGuiInputSource_Nav,$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_NavGamepad	vendor/imgui/imgui_internal.h	/^    ImGuiInputSource_NavGamepad,    \/\/ "$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_NavKeyboard	vendor/imgui/imgui_internal.h	/^    ImGuiInputSource_NavKeyboard,   \/\/ Only used occasionally for storage, not tested\/handled by most code$/;"	e	enum:ImGuiInputSource
ImGuiInputSource_None	vendor/imgui/imgui_internal.h	/^    ImGuiInputSource_None = 0,$/;"	e	enum:ImGuiInputSource
ImGuiInputTextCallback	vendor/imgui/imgui.h	/^typedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData *data);$/;"	t
ImGuiInputTextCallbackData	vendor/imgui/imgui.h	/^struct ImGuiInputTextCallbackData$/;"	s
ImGuiInputTextCallbackData	vendor/imgui/imgui_widgets.cpp	/^ImGuiInputTextCallbackData::ImGuiInputTextCallbackData()$/;"	f	class:ImGuiInputTextCallbackData
ImGuiInputTextFlags	vendor/imgui/imgui.h	/^typedef int ImGuiInputTextFlags;    \/\/ -> enum ImGuiInputTextFlags_  \/\/ Flags: for InputText(), InputTextMultiline()$/;"	t
ImGuiInputTextFlags_	vendor/imgui/imgui.h	/^enum ImGuiInputTextFlags_$/;"	g
ImGuiInputTextFlags_AllowTabInput	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_AllowTabInput       = 1 << 10,  \/\/ Pressing TAB input a '\\t' character into the text field$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AlwaysInsertMode	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_AlwaysInsertMode    = 1 << 13,  \/\/ Insert mode$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_AutoSelectAll	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_AutoSelectAll       = 1 << 4,   \/\/ Select entire text when first taking mouse focus$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackAlways	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CallbackAlways      = 1 << 8,   \/\/ Callback on each iteration. User code may query cursor position, modify text buffer.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackCharFilter	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CallbackCharFilter  = 1 << 9,   \/\/ Callback on character inputs to replace or discard them. Modify 'EventChar' to replace or discard, or return 1 in callback to discard.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackCompletion	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CallbackCompletion  = 1 << 6,   \/\/ Callback on pressing TAB (for completion handling)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackHistory	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CallbackHistory     = 1 << 7,   \/\/ Callback on pressing Up\/Down arrows (for history handling)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CallbackResize	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CallbackResize      = 1 << 18,  \/\/ Callback on buffer capacity changes request (beyond 'buf_size' parameter value), allowing the string to grow. Notify when the string wants to be resized (for string types which hold a cache of their Size). You will be provided a new BufSize in the callback and NEED to honor it. (see misc\/cpp\/imgui_stdlib.h for an example of using this)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsDecimal	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CharsDecimal        = 1 << 0,   \/\/ Allow 0123456789.+-*\/$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsHexadecimal	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CharsHexadecimal    = 1 << 1,   \/\/ Allow 0123456789ABCDEFabcdef$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsNoBlank	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CharsNoBlank        = 1 << 3,   \/\/ Filter out spaces, tabs$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsScientific	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CharsScientific     = 1 << 17,  \/\/ Allow 0123456789.+-*\/eE (Scientific notation input)$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CharsUppercase	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CharsUppercase      = 1 << 2,   \/\/ Turn a..z into A..Z$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_CtrlEnterForNewLine	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  \/\/ In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_EnterReturnsTrue	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_EnterReturnsTrue    = 1 << 5,   \/\/ Return 'true' when Enter is pressed (as opposed to every time the value was modified). Consider looking at the IsItemDeactivatedAfterEdit() function.$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_Multiline	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_Multiline           = 1 << 20,  \/\/ For internal use by InputTextMultiline()$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_NoHorizontalScroll	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_NoHorizontalScroll  = 1 << 12,  \/\/ Disable following the cursor horizontally$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_NoMarkEdited	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_NoMarkEdited        = 1 << 21   \/\/ For internal use by functions using InputText() before reformatting data$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_NoUndoRedo	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_NoUndoRedo          = 1 << 16,  \/\/ Disable undo\/redo. Note that input text owns the text data while active, if you want to provide your own undo\/redo stack you need e.g. to call ClearActiveID().$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_None	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_None                = 0,$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_Password	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_Password            = 1 << 15,  \/\/ Password mode, display all characters as '*'$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextFlags_ReadOnly	vendor/imgui/imgui.h	/^    ImGuiInputTextFlags_ReadOnly            = 1 << 14,  \/\/ Read-only mode$/;"	e	enum:ImGuiInputTextFlags_
ImGuiInputTextState	vendor/imgui/imgui_internal.h	/^    ImGuiInputTextState()                   { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiInputTextState
ImGuiInputTextState	vendor/imgui/imgui_internal.h	/^struct IMGUI_API ImGuiInputTextState$/;"	s
ImGuiItemFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiItemFlags;             \/\/ -> enum ImGuiItemFlags_          \/\/ Flags: for PushItemFlag()$/;"	t
ImGuiItemFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiItemFlags_$/;"	g
ImGuiItemFlags_ButtonRepeat	vendor/imgui/imgui_internal.h	/^    ImGuiItemFlags_ButtonRepeat             = 1 << 1,  \/\/ false    \/\/ Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_Default_	vendor/imgui/imgui_internal.h	/^    ImGuiItemFlags_Default_                 = 0$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_Disabled	vendor/imgui/imgui_internal.h	/^    ImGuiItemFlags_Disabled                 = 1 << 2,  \/\/ false    \/\/ [BETA] Disable interactions but doesn't affect visuals yet. See github.com\/ocornut\/imgui\/issues\/211$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_MixedValue	vendor/imgui/imgui_internal.h	/^    ImGuiItemFlags_MixedValue               = 1 << 6,  \/\/ false    \/\/ [BETA] Represent a mixed\/indeterminate value, generally multi-selection where values differ. Currently only supported by Checkbox() (later should support all sorts of widgets)$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_NoNav	vendor/imgui/imgui_internal.h	/^    ImGuiItemFlags_NoNav                    = 1 << 3,  \/\/ false$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_NoNavDefaultFocus	vendor/imgui/imgui_internal.h	/^    ImGuiItemFlags_NoNavDefaultFocus        = 1 << 4,  \/\/ false$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_NoTabStop	vendor/imgui/imgui_internal.h	/^    ImGuiItemFlags_NoTabStop                = 1 << 0,  \/\/ false$/;"	e	enum:ImGuiItemFlags_
ImGuiItemFlags_SelectableDontClosePopup	vendor/imgui/imgui_internal.h	/^    ImGuiItemFlags_SelectableDontClosePopup = 1 << 5,  \/\/ false    \/\/ MenuItem\/Selectable() automatically closes current Popup window$/;"	e	enum:ImGuiItemFlags_
ImGuiItemHoveredDataBackup	vendor/imgui/imgui_internal.h	/^    ImGuiItemHoveredDataBackup() { Backup(); }$/;"	f	struct:ImGuiItemHoveredDataBackup
ImGuiItemHoveredDataBackup	vendor/imgui/imgui_internal.h	/^struct ImGuiItemHoveredDataBackup$/;"	s
ImGuiItemStatusFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiItemStatusFlags;       \/\/ -> enum ImGuiItemStatusFlags_    \/\/ Flags: for DC.LastItemStatusFlags$/;"	t
ImGuiItemStatusFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiItemStatusFlags_$/;"	g
ImGuiItemStatusFlags_Checkable	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_Checkable          = 1 << 12,  \/\/$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_Checked	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_Checked            = 1 << 13   \/\/$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_Deactivated	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_Deactivated        = 1 << 5    \/\/ Only valid if ImGuiItemStatusFlags_HasDeactivated is set.$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_Edited	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_Edited             = 1 << 2,   \/\/ Value exposed by item was edited in the current frame (should match the bool return value of most widgets)$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_HasDeactivated	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_HasDeactivated     = 1 << 4,   \/\/ Set if the widget\/group is able to provide data for the ImGuiItemStatusFlags_Deactivated flag.$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_HasDisplayRect	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_HasDisplayRect     = 1 << 1,$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_HoveredRect	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_HoveredRect        = 1 << 0,$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_None               = 0,$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_Openable	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_Openable           = 1 << 10,  \/\/$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_Opened	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_Opened             = 1 << 11,  \/\/$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiItemStatusFlags_ToggledSelection	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags_ToggledSelection   = 1 << 3,   \/\/ Set when Selectable(), TreeNode() reports toggling a selection. We can't report "Selected" because reporting the change allows us to handle clipping with less issues.$/;"	e	enum:ImGuiItemStatusFlags_
ImGuiKey	vendor/imgui/imgui.h	/^typedef int ImGuiKey;               \/\/ -> enum ImGuiKey_             \/\/ Enum: A key identifier (ImGui-side enum)$/;"	t
ImGuiKey_	vendor/imgui/imgui.h	/^enum ImGuiKey_$/;"	g
ImGuiKey_A	vendor/imgui/imgui.h	/^    ImGuiKey_A,         \/\/ for text edit CTRL+A: select all$/;"	e	enum:ImGuiKey_
ImGuiKey_Backspace	vendor/imgui/imgui.h	/^    ImGuiKey_Backspace,$/;"	e	enum:ImGuiKey_
ImGuiKey_C	vendor/imgui/imgui.h	/^    ImGuiKey_C,         \/\/ for text edit CTRL+C: copy$/;"	e	enum:ImGuiKey_
ImGuiKey_COUNT	vendor/imgui/imgui.h	/^    ImGuiKey_COUNT$/;"	e	enum:ImGuiKey_
ImGuiKey_Delete	vendor/imgui/imgui.h	/^    ImGuiKey_Delete,$/;"	e	enum:ImGuiKey_
ImGuiKey_DownArrow	vendor/imgui/imgui.h	/^    ImGuiKey_DownArrow,$/;"	e	enum:ImGuiKey_
ImGuiKey_End	vendor/imgui/imgui.h	/^    ImGuiKey_End,$/;"	e	enum:ImGuiKey_
ImGuiKey_Enter	vendor/imgui/imgui.h	/^    ImGuiKey_Enter,$/;"	e	enum:ImGuiKey_
ImGuiKey_Escape	vendor/imgui/imgui.h	/^    ImGuiKey_Escape,$/;"	e	enum:ImGuiKey_
ImGuiKey_Home	vendor/imgui/imgui.h	/^    ImGuiKey_Home,$/;"	e	enum:ImGuiKey_
ImGuiKey_Insert	vendor/imgui/imgui.h	/^    ImGuiKey_Insert,$/;"	e	enum:ImGuiKey_
ImGuiKey_KeyPadEnter	vendor/imgui/imgui.h	/^    ImGuiKey_KeyPadEnter,$/;"	e	enum:ImGuiKey_
ImGuiKey_LeftArrow	vendor/imgui/imgui.h	/^    ImGuiKey_LeftArrow,$/;"	e	enum:ImGuiKey_
ImGuiKey_PageDown	vendor/imgui/imgui.h	/^    ImGuiKey_PageDown,$/;"	e	enum:ImGuiKey_
ImGuiKey_PageUp	vendor/imgui/imgui.h	/^    ImGuiKey_PageUp,$/;"	e	enum:ImGuiKey_
ImGuiKey_RightArrow	vendor/imgui/imgui.h	/^    ImGuiKey_RightArrow,$/;"	e	enum:ImGuiKey_
ImGuiKey_Space	vendor/imgui/imgui.h	/^    ImGuiKey_Space,$/;"	e	enum:ImGuiKey_
ImGuiKey_Tab	vendor/imgui/imgui.h	/^    ImGuiKey_Tab,$/;"	e	enum:ImGuiKey_
ImGuiKey_UpArrow	vendor/imgui/imgui.h	/^    ImGuiKey_UpArrow,$/;"	e	enum:ImGuiKey_
ImGuiKey_V	vendor/imgui/imgui.h	/^    ImGuiKey_V,         \/\/ for text edit CTRL+V: paste$/;"	e	enum:ImGuiKey_
ImGuiKey_X	vendor/imgui/imgui.h	/^    ImGuiKey_X,         \/\/ for text edit CTRL+X: cut$/;"	e	enum:ImGuiKey_
ImGuiKey_Y	vendor/imgui/imgui.h	/^    ImGuiKey_Y,         \/\/ for text edit CTRL+Y: redo$/;"	e	enum:ImGuiKey_
ImGuiKey_Z	vendor/imgui/imgui.h	/^    ImGuiKey_Z,         \/\/ for text edit CTRL+Z: undo$/;"	e	enum:ImGuiKey_
ImGuiLayoutType	vendor/imgui/imgui_internal.h	/^typedef int ImGuiLayoutType;            \/\/ -> enum ImGuiLayoutType_         \/\/ Enum: Horizontal or vertical$/;"	t
ImGuiLayoutType_	vendor/imgui/imgui_internal.h	/^enum ImGuiLayoutType_$/;"	g
ImGuiLayoutType_Horizontal	vendor/imgui/imgui_internal.h	/^    ImGuiLayoutType_Horizontal = 0,$/;"	e	enum:ImGuiLayoutType_
ImGuiLayoutType_Vertical	vendor/imgui/imgui_internal.h	/^    ImGuiLayoutType_Vertical = 1$/;"	e	enum:ImGuiLayoutType_
ImGuiListClipper	vendor/imgui/imgui.h	/^    ImGuiListClipper(int items_count = -1, float items_height = -1.0f)  { Begin(items_count, items_height); } \/\/ NB: Begin() initialize every fields (as we allow user to call Begin\/End multiple times on a same instance if they want).$/;"	f	struct:ImGuiListClipper
ImGuiListClipper	vendor/imgui/imgui.h	/^struct ImGuiListClipper$/;"	s
ImGuiLogType	vendor/imgui/imgui_internal.h	/^enum ImGuiLogType$/;"	g
ImGuiLogType_Buffer	vendor/imgui/imgui_internal.h	/^    ImGuiLogType_Buffer,$/;"	e	enum:ImGuiLogType
ImGuiLogType_Clipboard	vendor/imgui/imgui_internal.h	/^    ImGuiLogType_Clipboard$/;"	e	enum:ImGuiLogType
ImGuiLogType_File	vendor/imgui/imgui_internal.h	/^    ImGuiLogType_File,$/;"	e	enum:ImGuiLogType
ImGuiLogType_None	vendor/imgui/imgui_internal.h	/^    ImGuiLogType_None = 0,$/;"	e	enum:ImGuiLogType
ImGuiLogType_TTY	vendor/imgui/imgui_internal.h	/^    ImGuiLogType_TTY,$/;"	e	enum:ImGuiLogType
ImGuiMenuColumns	vendor/imgui/imgui_internal.h	/^struct IMGUI_API ImGuiMenuColumns$/;"	s
ImGuiMenuColumns	vendor/imgui/imgui_widgets.cpp	/^ImGuiMenuColumns::ImGuiMenuColumns()$/;"	f	class:ImGuiMenuColumns
ImGuiMouseCursor	vendor/imgui/imgui.h	/^typedef int ImGuiMouseCursor;       \/\/ -> enum ImGuiMouseCursor_     \/\/ Enum: A mouse cursor identifier$/;"	t
ImGuiMouseCursor_	vendor/imgui/imgui.h	/^enum ImGuiMouseCursor_$/;"	g
ImGuiMouseCursor_Arrow	vendor/imgui/imgui.h	/^    ImGuiMouseCursor_Arrow = 0,$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_COUNT	vendor/imgui/imgui.h	/^    ImGuiMouseCursor_COUNT$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_Count_	vendor/imgui/imgui.h	/^    , ImGuiMouseCursor_Count_ = ImGuiMouseCursor_COUNT      \/\/ [renamed in 1.60]$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_Hand	vendor/imgui/imgui.h	/^    ImGuiMouseCursor_Hand,              \/\/ (Unused by Dear ImGui functions. Use for e.g. hyperlinks)$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_None	vendor/imgui/imgui.h	/^    ImGuiMouseCursor_None = -1,$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeAll	vendor/imgui/imgui.h	/^    ImGuiMouseCursor_ResizeAll,         \/\/ (Unused by Dear ImGui functions)$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeEW	vendor/imgui/imgui.h	/^    ImGuiMouseCursor_ResizeEW,          \/\/ When hovering over a vertical border or a column$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNESW	vendor/imgui/imgui.h	/^    ImGuiMouseCursor_ResizeNESW,        \/\/ When hovering over the bottom-left corner of a window$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNS	vendor/imgui/imgui.h	/^    ImGuiMouseCursor_ResizeNS,          \/\/ When hovering over an horizontal border$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_ResizeNWSE	vendor/imgui/imgui.h	/^    ImGuiMouseCursor_ResizeNWSE,        \/\/ When hovering over the bottom-right corner of a window$/;"	e	enum:ImGuiMouseCursor_
ImGuiMouseCursor_TextInput	vendor/imgui/imgui.h	/^    ImGuiMouseCursor_TextInput,         \/\/ When hovering over InputText, etc.$/;"	e	enum:ImGuiMouseCursor_
ImGuiNavDirSourceFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiNavDirSourceFlags;     \/\/ -> enum ImGuiNavDirSourceFlags_  \/\/ Flags: for GetNavInputAmount2d()$/;"	t
ImGuiNavDirSourceFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiNavDirSourceFlags_$/;"	g
ImGuiNavDirSourceFlags_Keyboard	vendor/imgui/imgui_internal.h	/^    ImGuiNavDirSourceFlags_Keyboard     = 1 << 0,$/;"	e	enum:ImGuiNavDirSourceFlags_
ImGuiNavDirSourceFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiNavDirSourceFlags_None         = 0,$/;"	e	enum:ImGuiNavDirSourceFlags_
ImGuiNavDirSourceFlags_PadDPad	vendor/imgui/imgui_internal.h	/^    ImGuiNavDirSourceFlags_PadDPad      = 1 << 1,$/;"	e	enum:ImGuiNavDirSourceFlags_
ImGuiNavDirSourceFlags_PadLStick	vendor/imgui/imgui_internal.h	/^    ImGuiNavDirSourceFlags_PadLStick    = 1 << 2$/;"	e	enum:ImGuiNavDirSourceFlags_
ImGuiNavForward	vendor/imgui/imgui_internal.h	/^enum ImGuiNavForward$/;"	g
ImGuiNavForward_ForwardActive	vendor/imgui/imgui_internal.h	/^    ImGuiNavForward_ForwardActive$/;"	e	enum:ImGuiNavForward
ImGuiNavForward_ForwardQueued	vendor/imgui/imgui_internal.h	/^    ImGuiNavForward_ForwardQueued,$/;"	e	enum:ImGuiNavForward
ImGuiNavForward_None	vendor/imgui/imgui_internal.h	/^    ImGuiNavForward_None,$/;"	e	enum:ImGuiNavForward
ImGuiNavHighlightFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiNavHighlightFlags;     \/\/ -> enum ImGuiNavHighlightFlags_  \/\/ Flags: for RenderNavHighlight()$/;"	t
ImGuiNavHighlightFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiNavHighlightFlags_$/;"	g
ImGuiNavHighlightFlags_AlwaysDraw	vendor/imgui/imgui_internal.h	/^    ImGuiNavHighlightFlags_AlwaysDraw   = 1 << 2,       \/\/ Draw rectangular highlight if (g.NavId == id) _even_ when using the mouse.$/;"	e	enum:ImGuiNavHighlightFlags_
ImGuiNavHighlightFlags_NoRounding	vendor/imgui/imgui_internal.h	/^    ImGuiNavHighlightFlags_NoRounding   = 1 << 3$/;"	e	enum:ImGuiNavHighlightFlags_
ImGuiNavHighlightFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiNavHighlightFlags_None         = 0,$/;"	e	enum:ImGuiNavHighlightFlags_
ImGuiNavHighlightFlags_TypeDefault	vendor/imgui/imgui_internal.h	/^    ImGuiNavHighlightFlags_TypeDefault  = 1 << 0,$/;"	e	enum:ImGuiNavHighlightFlags_
ImGuiNavHighlightFlags_TypeThin	vendor/imgui/imgui_internal.h	/^    ImGuiNavHighlightFlags_TypeThin     = 1 << 1,$/;"	e	enum:ImGuiNavHighlightFlags_
ImGuiNavInput	vendor/imgui/imgui.h	/^typedef int ImGuiNavInput;          \/\/ -> enum ImGuiNavInput_        \/\/ Enum: An input identifier for navigation$/;"	t
ImGuiNavInput_	vendor/imgui/imgui.h	/^enum ImGuiNavInput_$/;"	g
ImGuiNavInput_Activate	vendor/imgui/imgui.h	/^    ImGuiNavInput_Activate,      \/\/ activate \/ open \/ toggle \/ tweak value       \/\/ e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_COUNT	vendor/imgui/imgui.h	/^    ImGuiNavInput_COUNT,$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_Cancel	vendor/imgui/imgui.h	/^    ImGuiNavInput_Cancel,        \/\/ cancel \/ close \/ exit                        \/\/ e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_DpadDown	vendor/imgui/imgui.h	/^    ImGuiNavInput_DpadDown,      \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_DpadLeft	vendor/imgui/imgui.h	/^    ImGuiNavInput_DpadLeft,      \/\/ move \/ tweak \/ resize window (w\/ PadMenu)    \/\/ e.g. D-pad Left\/Right\/Up\/Down (Gamepads), Arrow keys (Keyboard)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_DpadRight	vendor/imgui/imgui.h	/^    ImGuiNavInput_DpadRight,     \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_DpadUp	vendor/imgui/imgui.h	/^    ImGuiNavInput_DpadUp,        \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_FocusNext	vendor/imgui/imgui.h	/^    ImGuiNavInput_FocusNext,     \/\/ prev window (w\/ PadMenu)                     \/\/ e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_FocusPrev	vendor/imgui/imgui.h	/^    ImGuiNavInput_FocusPrev,     \/\/ next window (w\/ PadMenu)                     \/\/ e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_Input	vendor/imgui/imgui.h	/^    ImGuiNavInput_Input,         \/\/ text input \/ on-screen keyboard              \/\/ e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_InternalStart_	vendor/imgui/imgui.h	/^    ImGuiNavInput_InternalStart_ = ImGuiNavInput_KeyMenu_$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyDown_	vendor/imgui/imgui.h	/^    ImGuiNavInput_KeyDown_,      \/\/ move down$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyLeft_	vendor/imgui/imgui.h	/^    ImGuiNavInput_KeyLeft_,      \/\/ move left                                    \/\/ = Arrow keys$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyMenu_	vendor/imgui/imgui.h	/^    ImGuiNavInput_KeyMenu_,      \/\/ toggle menu                                  \/\/ = io.KeyAlt$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyRight_	vendor/imgui/imgui.h	/^    ImGuiNavInput_KeyRight_,     \/\/ move right$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyTab_	vendor/imgui/imgui.h	/^    ImGuiNavInput_KeyTab_,       \/\/ tab                                          \/\/ = Tab key$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_KeyUp_	vendor/imgui/imgui.h	/^    ImGuiNavInput_KeyUp_,        \/\/ move up$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_LStickDown	vendor/imgui/imgui.h	/^    ImGuiNavInput_LStickDown,    \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_LStickLeft	vendor/imgui/imgui.h	/^    ImGuiNavInput_LStickLeft,    \/\/ scroll \/ move window (w\/ PadMenu)            \/\/ e.g. Left Analog Stick Left\/Right\/Up\/Down$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_LStickRight	vendor/imgui/imgui.h	/^    ImGuiNavInput_LStickRight,   \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_LStickUp	vendor/imgui/imgui.h	/^    ImGuiNavInput_LStickUp,      \/\/$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_Menu	vendor/imgui/imgui.h	/^    ImGuiNavInput_Menu,          \/\/ tap: toggle menu \/ hold: focus, move, resize \/\/ e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_TweakFast	vendor/imgui/imgui.h	/^    ImGuiNavInput_TweakFast,     \/\/ faster tweaks                                \/\/ e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)$/;"	e	enum:ImGuiNavInput_
ImGuiNavInput_TweakSlow	vendor/imgui/imgui.h	/^    ImGuiNavInput_TweakSlow,     \/\/ slower tweaks                                \/\/ e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)$/;"	e	enum:ImGuiNavInput_
ImGuiNavLayer	vendor/imgui/imgui_internal.h	/^enum ImGuiNavLayer$/;"	g
ImGuiNavLayer_COUNT	vendor/imgui/imgui_internal.h	/^    ImGuiNavLayer_COUNT$/;"	e	enum:ImGuiNavLayer
ImGuiNavLayer_Main	vendor/imgui/imgui_internal.h	/^    ImGuiNavLayer_Main  = 0,    \/\/ Main scrolling layer$/;"	e	enum:ImGuiNavLayer
ImGuiNavLayer_Menu	vendor/imgui/imgui_internal.h	/^    ImGuiNavLayer_Menu  = 1,    \/\/ Menu layer (access with Alt\/ImGuiNavInput_Menu)$/;"	e	enum:ImGuiNavLayer
ImGuiNavMoveFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiNavMoveFlags;          \/\/ -> enum ImGuiNavMoveFlags_       \/\/ Flags: for navigation requests$/;"	t
ImGuiNavMoveFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiNavMoveFlags_$/;"	g
ImGuiNavMoveFlags_AllowCurrentNavId	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveFlags_AllowCurrentNavId     = 1 << 4,   \/\/ Allow scoring and considering the current NavId as a move target candidate. This is used when the move source is offset (e.g. pressing PageDown actually needs to send a Up move request, if we are pressing PageDown from the bottom-most item we need to stay in place)$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_AlsoScoreVisibleSet	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveFlags_AlsoScoreVisibleSet   = 1 << 5    \/\/ Store alternate result in NavMoveResultLocalVisibleSet that only comprise elements that are already fully visible.$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_LoopX	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveFlags_LoopX                 = 1 << 0,   \/\/ On failed request, restart from opposite side$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_LoopY	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveFlags_LoopY                 = 1 << 1,$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveFlags_None                  = 0,$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_WrapX	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveFlags_WrapX                 = 1 << 2,   \/\/ On failed request, request from opposite side one line down (when NavDir==right) or one line up (when NavDir==left)$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveFlags_WrapY	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveFlags_WrapY                 = 1 << 3,   \/\/ This is not super useful for provided for completeness$/;"	e	enum:ImGuiNavMoveFlags_
ImGuiNavMoveResult	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveResult() { Clear(); }$/;"	f	struct:ImGuiNavMoveResult
ImGuiNavMoveResult	vendor/imgui/imgui_internal.h	/^struct ImGuiNavMoveResult$/;"	s
ImGuiNextItemData	vendor/imgui/imgui_internal.h	/^    ImGuiNextItemData()         { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiNextItemData
ImGuiNextItemData	vendor/imgui/imgui_internal.h	/^struct ImGuiNextItemData$/;"	s
ImGuiNextItemDataFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiNextItemDataFlags;     \/\/ -> enum ImGuiNextItemDataFlags_  \/\/ Flags: for SetNextItemXXX() functions$/;"	t
ImGuiNextItemDataFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiNextItemDataFlags_$/;"	g
ImGuiNextItemDataFlags_HasOpen	vendor/imgui/imgui_internal.h	/^    ImGuiNextItemDataFlags_HasOpen  = 1 << 1$/;"	e	enum:ImGuiNextItemDataFlags_
ImGuiNextItemDataFlags_HasWidth	vendor/imgui/imgui_internal.h	/^    ImGuiNextItemDataFlags_HasWidth = 1 << 0,$/;"	e	enum:ImGuiNextItemDataFlags_
ImGuiNextItemDataFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiNextItemDataFlags_None     = 0,$/;"	e	enum:ImGuiNextItemDataFlags_
ImGuiNextWindowData	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowData()       { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiNextWindowData
ImGuiNextWindowData	vendor/imgui/imgui_internal.h	/^struct ImGuiNextWindowData$/;"	s
ImGuiNextWindowDataFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiNextWindowDataFlags;   \/\/ -> enum ImGuiNextWindowDataFlags_\/\/ Flags: for SetNextWindowXXX() functions$/;"	t
ImGuiNextWindowDataFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiNextWindowDataFlags_$/;"	g
ImGuiNextWindowDataFlags_HasBgAlpha	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasBgAlpha         = 1 << 6$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasCollapsed	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasCollapsed       = 1 << 3,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasContentSize	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasContentSize     = 1 << 2,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasFocus	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasFocus           = 1 << 5,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasPos	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasPos             = 1 << 0,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasSize	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasSize            = 1 << 1,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_HasSizeConstraint	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowDataFlags_HasSizeConstraint  = 1 << 4,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiNextWindowDataFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowDataFlags_None               = 0,$/;"	e	enum:ImGuiNextWindowDataFlags_
ImGuiOnceUponAFrame	vendor/imgui/imgui.h	/^    ImGuiOnceUponAFrame() { RefFrame = -1; }$/;"	f	struct:ImGuiOnceUponAFrame
ImGuiOnceUponAFrame	vendor/imgui/imgui.h	/^struct ImGuiOnceUponAFrame$/;"	s
ImGuiPayload	vendor/imgui/imgui.h	/^    ImGuiPayload()  { Clear(); }$/;"	f	struct:ImGuiPayload
ImGuiPayload	vendor/imgui/imgui.h	/^struct ImGuiPayload$/;"	s
ImGuiPlotArrayGetterData	vendor/imgui/imgui_widgets.cpp	/^    ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }$/;"	f	struct:ImGuiPlotArrayGetterData
ImGuiPlotArrayGetterData	vendor/imgui/imgui_widgets.cpp	/^struct ImGuiPlotArrayGetterData$/;"	s	file:
ImGuiPlotType	vendor/imgui/imgui_internal.h	/^enum ImGuiPlotType$/;"	g
ImGuiPlotType_Histogram	vendor/imgui/imgui_internal.h	/^    ImGuiPlotType_Histogram$/;"	e	enum:ImGuiPlotType
ImGuiPlotType_Lines	vendor/imgui/imgui_internal.h	/^    ImGuiPlotType_Lines,$/;"	e	enum:ImGuiPlotType
ImGuiPopupData	vendor/imgui/imgui_internal.h	/^    ImGuiPopupData() { PopupId = 0; Window = SourceWindow = NULL; OpenFrameCount = -1; OpenParentId = 0; }$/;"	f	struct:ImGuiPopupData
ImGuiPopupData	vendor/imgui/imgui_internal.h	/^struct ImGuiPopupData$/;"	s
ImGuiPopupPositionPolicy	vendor/imgui/imgui_internal.h	/^enum ImGuiPopupPositionPolicy$/;"	g
ImGuiPopupPositionPolicy_ComboBox	vendor/imgui/imgui_internal.h	/^    ImGuiPopupPositionPolicy_ComboBox$/;"	e	enum:ImGuiPopupPositionPolicy
ImGuiPopupPositionPolicy_Default	vendor/imgui/imgui_internal.h	/^    ImGuiPopupPositionPolicy_Default,$/;"	e	enum:ImGuiPopupPositionPolicy
ImGuiPtrOrIndex	vendor/imgui/imgui_internal.h	/^    ImGuiPtrOrIndex(int index)          { Ptr = NULL; Index = index; }$/;"	f	struct:ImGuiPtrOrIndex
ImGuiPtrOrIndex	vendor/imgui/imgui_internal.h	/^    ImGuiPtrOrIndex(void* ptr)          { Ptr = ptr; Index = -1; }$/;"	f	struct:ImGuiPtrOrIndex
ImGuiPtrOrIndex	vendor/imgui/imgui_internal.h	/^struct ImGuiPtrOrIndex$/;"	s
ImGuiResizeGripDef	vendor/imgui/imgui.cpp	/^struct ImGuiResizeGripDef$/;"	s	file:
ImGuiSelectableFlags	vendor/imgui/imgui.h	/^typedef int ImGuiSelectableFlags;   \/\/ -> enum ImGuiSelectableFlags_ \/\/ Flags: for Selectable()$/;"	t
ImGuiSelectableFlagsPrivate_	vendor/imgui/imgui_internal.h	/^enum ImGuiSelectableFlagsPrivate_$/;"	g
ImGuiSelectableFlags_	vendor/imgui/imgui.h	/^enum ImGuiSelectableFlags_$/;"	g
ImGuiSelectableFlags_AllowDoubleClick	vendor/imgui/imgui.h	/^    ImGuiSelectableFlags_AllowDoubleClick   = 1 << 2,   \/\/ Generate press events on double clicks too$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_AllowItemOverlap	vendor/imgui/imgui_internal.h	/^    ImGuiSelectableFlags_AllowItemOverlap   = 1 << 24,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_Disabled	vendor/imgui/imgui.h	/^    ImGuiSelectableFlags_Disabled           = 1 << 3    \/\/ Cannot be selected, display grayed out text$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_DontClosePopups	vendor/imgui/imgui.h	/^    ImGuiSelectableFlags_DontClosePopups    = 1 << 0,   \/\/ Clicking this don't close parent popup window$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_DrawFillAvailWidth	vendor/imgui/imgui_internal.h	/^    ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 23,  \/\/ FIXME: We may be able to remove this (added in 6251d379 for menus)$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_DrawHoveredWhenHeld	vendor/imgui/imgui_internal.h	/^    ImGuiSelectableFlags_DrawHoveredWhenHeld= 1 << 25,  \/\/ Always show active when held, even is not hovered. This concept could probably be renamed\/formalized somehow.$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_NoHoldingActiveID	vendor/imgui/imgui_internal.h	/^    ImGuiSelectableFlags_NoHoldingActiveID  = 1 << 20,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_None	vendor/imgui/imgui.h	/^    ImGuiSelectableFlags_None               = 0,$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSelectableFlags_PressedOnClick	vendor/imgui/imgui_internal.h	/^    ImGuiSelectableFlags_PressedOnClick     = 1 << 21,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_PressedOnRelease	vendor/imgui/imgui_internal.h	/^    ImGuiSelectableFlags_PressedOnRelease   = 1 << 22,$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_SetNavIdOnHover	vendor/imgui/imgui_internal.h	/^    ImGuiSelectableFlags_SetNavIdOnHover    = 1 << 26$/;"	e	enum:ImGuiSelectableFlagsPrivate_
ImGuiSelectableFlags_SpanAllColumns	vendor/imgui/imgui.h	/^    ImGuiSelectableFlags_SpanAllColumns     = 1 << 1,   \/\/ Selectable frame can span all columns (text will still fit in current column)$/;"	e	enum:ImGuiSelectableFlags_
ImGuiSeparatorFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiSeparatorFlags;        \/\/ -> enum ImGuiSeparatorFlags_     \/\/ Flags: for SeparatorEx()$/;"	t
ImGuiSeparatorFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiSeparatorFlags_$/;"	g
ImGuiSeparatorFlags_Horizontal	vendor/imgui/imgui_internal.h	/^    ImGuiSeparatorFlags_Horizontal          = 1 << 0,   \/\/ Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar$/;"	e	enum:ImGuiSeparatorFlags_
ImGuiSeparatorFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiSeparatorFlags_None                = 0,$/;"	e	enum:ImGuiSeparatorFlags_
ImGuiSeparatorFlags_SpanAllColumns	vendor/imgui/imgui_internal.h	/^    ImGuiSeparatorFlags_SpanAllColumns      = 1 << 2$/;"	e	enum:ImGuiSeparatorFlags_
ImGuiSeparatorFlags_Vertical	vendor/imgui/imgui_internal.h	/^    ImGuiSeparatorFlags_Vertical            = 1 << 1,$/;"	e	enum:ImGuiSeparatorFlags_
ImGuiSettingsHandler	vendor/imgui/imgui_internal.h	/^    ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }$/;"	f	struct:ImGuiSettingsHandler
ImGuiSettingsHandler	vendor/imgui/imgui_internal.h	/^struct ImGuiSettingsHandler$/;"	s
ImGuiShrinkWidthItem	vendor/imgui/imgui_internal.h	/^struct ImGuiShrinkWidthItem$/;"	s
ImGuiSizeCallback	vendor/imgui/imgui.h	/^typedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);$/;"	t
ImGuiSizeCallbackData	vendor/imgui/imgui.h	/^struct ImGuiSizeCallbackData$/;"	s
ImGuiSliderFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiSliderFlags;           \/\/ -> enum ImGuiSliderFlags_        \/\/ Flags: for SliderBehavior()$/;"	t
ImGuiSliderFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiSliderFlags_$/;"	g
ImGuiSliderFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiSliderFlags_None                   = 0,$/;"	e	enum:ImGuiSliderFlags_
ImGuiSliderFlags_Vertical	vendor/imgui/imgui_internal.h	/^    ImGuiSliderFlags_Vertical               = 1 << 0$/;"	e	enum:ImGuiSliderFlags_
ImGuiStorage	vendor/imgui/imgui.h	/^struct ImGuiStorage$/;"	s
ImGuiStoragePair	vendor/imgui/imgui.h	/^        ImGuiStoragePair(ImGuiID _key, float _val_f)    { key = _key; val_f = _val_f; }$/;"	f	struct:ImGuiStorage::ImGuiStoragePair
ImGuiStoragePair	vendor/imgui/imgui.h	/^        ImGuiStoragePair(ImGuiID _key, int _val_i)      { key = _key; val_i = _val_i; }$/;"	f	struct:ImGuiStorage::ImGuiStoragePair
ImGuiStoragePair	vendor/imgui/imgui.h	/^        ImGuiStoragePair(ImGuiID _key, void* _val_p)    { key = _key; val_p = _val_p; }$/;"	f	struct:ImGuiStorage::ImGuiStoragePair
ImGuiStoragePair	vendor/imgui/imgui.h	/^    struct ImGuiStoragePair$/;"	s	struct:ImGuiStorage
ImGuiStyle	vendor/imgui/imgui.cpp	/^ImGuiStyle::ImGuiStyle()$/;"	f	class:ImGuiStyle
ImGuiStyle	vendor/imgui/imgui.h	/^struct ImGuiStyle$/;"	s
ImGuiStyleMod	vendor/imgui/imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v)  { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }$/;"	f	struct:ImGuiStyleMod
ImGuiStyleMod	vendor/imgui/imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, float v)   { VarIdx = idx; BackupFloat[0] = v; }$/;"	f	struct:ImGuiStyleMod
ImGuiStyleMod	vendor/imgui/imgui_internal.h	/^    ImGuiStyleMod(ImGuiStyleVar idx, int v)     { VarIdx = idx; BackupInt[0] = v; }$/;"	f	struct:ImGuiStyleMod
ImGuiStyleMod	vendor/imgui/imgui_internal.h	/^struct ImGuiStyleMod$/;"	s
ImGuiStyleVar	vendor/imgui/imgui.h	/^typedef int ImGuiStyleVar;          \/\/ -> enum ImGuiStyleVar_        \/\/ Enum: A variable identifier for styling$/;"	t
ImGuiStyleVarInfo	vendor/imgui/imgui.cpp	/^struct ImGuiStyleVarInfo$/;"	s	file:
ImGuiStyleVar_	vendor/imgui/imgui.h	/^enum ImGuiStyleVar_$/;"	g
ImGuiStyleVar_Alpha	vendor/imgui/imgui.h	/^    ImGuiStyleVar_Alpha,               \/\/ float     Alpha$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ButtonTextAlign	vendor/imgui/imgui.h	/^    ImGuiStyleVar_ButtonTextAlign,     \/\/ ImVec2    ButtonTextAlign$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_COUNT	vendor/imgui/imgui.h	/^    ImGuiStyleVar_COUNT$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ChildBorderSize	vendor/imgui/imgui.h	/^    ImGuiStyleVar_ChildBorderSize,     \/\/ float     ChildBorderSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ChildRounding	vendor/imgui/imgui.h	/^    ImGuiStyleVar_ChildRounding,       \/\/ float     ChildRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ChildWindowRounding	vendor/imgui/imgui.h	/^    , ImGuiStyleVar_ChildWindowRounding = ImGuiStyleVar_ChildRounding   \/\/ [renamed in 1.53]$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_Count_	vendor/imgui/imgui.h	/^    , ImGuiStyleVar_Count_ = ImGuiStyleVar_COUNT                        \/\/ [renamed in 1.60]$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FrameBorderSize	vendor/imgui/imgui.h	/^    ImGuiStyleVar_FrameBorderSize,     \/\/ float     FrameBorderSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FramePadding	vendor/imgui/imgui.h	/^    ImGuiStyleVar_FramePadding,        \/\/ ImVec2    FramePadding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_FrameRounding	vendor/imgui/imgui.h	/^    ImGuiStyleVar_FrameRounding,       \/\/ float     FrameRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_GrabMinSize	vendor/imgui/imgui.h	/^    ImGuiStyleVar_GrabMinSize,         \/\/ float     GrabMinSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_GrabRounding	vendor/imgui/imgui.h	/^    ImGuiStyleVar_GrabRounding,        \/\/ float     GrabRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_IndentSpacing	vendor/imgui/imgui.h	/^    ImGuiStyleVar_IndentSpacing,       \/\/ float     IndentSpacing$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ItemInnerSpacing	vendor/imgui/imgui.h	/^    ImGuiStyleVar_ItemInnerSpacing,    \/\/ ImVec2    ItemInnerSpacing$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ItemSpacing	vendor/imgui/imgui.h	/^    ImGuiStyleVar_ItemSpacing,         \/\/ ImVec2    ItemSpacing$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_PopupBorderSize	vendor/imgui/imgui.h	/^    ImGuiStyleVar_PopupBorderSize,     \/\/ float     PopupBorderSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_PopupRounding	vendor/imgui/imgui.h	/^    ImGuiStyleVar_PopupRounding,       \/\/ float     PopupRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ScrollbarRounding	vendor/imgui/imgui.h	/^    ImGuiStyleVar_ScrollbarRounding,   \/\/ float     ScrollbarRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_ScrollbarSize	vendor/imgui/imgui.h	/^    ImGuiStyleVar_ScrollbarSize,       \/\/ float     ScrollbarSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_SelectableTextAlign	vendor/imgui/imgui.h	/^    ImGuiStyleVar_SelectableTextAlign, \/\/ ImVec2    SelectableTextAlign$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_TabRounding	vendor/imgui/imgui.h	/^    ImGuiStyleVar_TabRounding,         \/\/ float     TabRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowBorderSize	vendor/imgui/imgui.h	/^    ImGuiStyleVar_WindowBorderSize,    \/\/ float     WindowBorderSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowMinSize	vendor/imgui/imgui.h	/^    ImGuiStyleVar_WindowMinSize,       \/\/ ImVec2    WindowMinSize$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowPadding	vendor/imgui/imgui.h	/^    ImGuiStyleVar_WindowPadding,       \/\/ ImVec2    WindowPadding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowRounding	vendor/imgui/imgui.h	/^    ImGuiStyleVar_WindowRounding,      \/\/ float     WindowRounding$/;"	e	enum:ImGuiStyleVar_
ImGuiStyleVar_WindowTitleAlign	vendor/imgui/imgui.h	/^    ImGuiStyleVar_WindowTitleAlign,    \/\/ ImVec2    WindowTitleAlign$/;"	e	enum:ImGuiStyleVar_
ImGuiTabBar	vendor/imgui/imgui_internal.h	/^struct ImGuiTabBar$/;"	s
ImGuiTabBar	vendor/imgui/imgui_widgets.cpp	/^ImGuiTabBar::ImGuiTabBar()$/;"	f	class:ImGuiTabBar
ImGuiTabBarFlags	vendor/imgui/imgui.h	/^typedef int ImGuiTabBarFlags;       \/\/ -> enum ImGuiTabBarFlags_     \/\/ Flags: for BeginTabBar()$/;"	t
ImGuiTabBarFlagsPrivate_	vendor/imgui/imgui_internal.h	/^enum ImGuiTabBarFlagsPrivate_$/;"	g
ImGuiTabBarFlags_	vendor/imgui/imgui.h	/^enum ImGuiTabBarFlags_$/;"	g
ImGuiTabBarFlags_AutoSelectNewTabs	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_AutoSelectNewTabs              = 1 << 1,   \/\/ Automatically select new tabs when they appear$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_DockNode	vendor/imgui/imgui_internal.h	/^    ImGuiTabBarFlags_DockNode                   = 1 << 20,  \/\/ Part of a dock node [we don't use this in the master branch but it facilitate branch syncing to keep this around]$/;"	e	enum:ImGuiTabBarFlagsPrivate_
ImGuiTabBarFlags_FittingPolicyDefault_	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_FittingPolicyDefault_          = ImGuiTabBarFlags_FittingPolicyResizeDown$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_FittingPolicyMask_	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_FittingPolicyMask_             = ImGuiTabBarFlags_FittingPolicyResizeDown | ImGuiTabBarFlags_FittingPolicyScroll,$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_FittingPolicyResizeDown	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_FittingPolicyResizeDown        = 1 << 6,   \/\/ Resize tabs when they don't fit$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_FittingPolicyScroll	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_FittingPolicyScroll            = 1 << 7,   \/\/ Add scroll buttons when tabs don't fit$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_IsFocused	vendor/imgui/imgui_internal.h	/^    ImGuiTabBarFlags_IsFocused                  = 1 << 21,$/;"	e	enum:ImGuiTabBarFlagsPrivate_
ImGuiTabBarFlags_NoCloseWithMiddleMouseButton	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_NoCloseWithMiddleMouseButton   = 1 << 3,   \/\/ Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_NoTabListScrollingButtons	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_NoTabListScrollingButtons      = 1 << 4,   \/\/ Disable scrolling buttons (apply when fitting policy is ImGuiTabBarFlags_FittingPolicyScroll)$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_NoTooltip	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_NoTooltip                      = 1 << 5,   \/\/ Disable tooltips when hovering a tab$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_None	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_None                           = 0,$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_Reorderable	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_Reorderable                    = 1 << 0,   \/\/ Allow manually dragging tabs to re-order them + New tabs are appended at the end of list$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabBarFlags_SaveSettings	vendor/imgui/imgui_internal.h	/^    ImGuiTabBarFlags_SaveSettings               = 1 << 22   \/\/ FIXME: Settings are handled by the docking system, this only request the tab bar to mark settings dirty when reordering tabs$/;"	e	enum:ImGuiTabBarFlagsPrivate_
ImGuiTabBarFlags_TabListPopupButton	vendor/imgui/imgui.h	/^    ImGuiTabBarFlags_TabListPopupButton             = 1 << 2,   \/\/ Disable buttons to open the tab list popup$/;"	e	enum:ImGuiTabBarFlags_
ImGuiTabItem	vendor/imgui/imgui_internal.h	/^    ImGuiTabItem()      { ID = Flags = 0; LastFrameVisible = LastFrameSelected = -1; NameOffset = -1; Offset = Width = WidthContents = 0.0f; }$/;"	f	struct:ImGuiTabItem
ImGuiTabItem	vendor/imgui/imgui_internal.h	/^struct ImGuiTabItem$/;"	s
ImGuiTabItemFlags	vendor/imgui/imgui.h	/^typedef int ImGuiTabItemFlags;      \/\/ -> enum ImGuiTabItemFlags_    \/\/ Flags: for BeginTabItem()$/;"	t
ImGuiTabItemFlagsPrivate_	vendor/imgui/imgui_internal.h	/^enum ImGuiTabItemFlagsPrivate_$/;"	g
ImGuiTabItemFlags_	vendor/imgui/imgui.h	/^enum ImGuiTabItemFlags_$/;"	g
ImGuiTabItemFlags_NoCloseButton	vendor/imgui/imgui_internal.h	/^    ImGuiTabItemFlags_NoCloseButton             = 1 << 20   \/\/ Store whether p_open is set or not, which we need to recompute WidthContents during layout.$/;"	e	enum:ImGuiTabItemFlagsPrivate_
ImGuiTabItemFlags_NoCloseWithMiddleMouseButton	vendor/imgui/imgui.h	/^    ImGuiTabItemFlags_NoCloseWithMiddleMouseButton  = 1 << 2,   \/\/ Disable behavior of closing tabs (that are submitted with p_open != NULL) with middle mouse button. You can still repro this behavior on user's side with if (IsItemHovered() && IsMouseClicked(2)) *p_open = false.$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_NoPushId	vendor/imgui/imgui.h	/^    ImGuiTabItemFlags_NoPushId                      = 1 << 3    \/\/ Don't call PushID(tab->ID)\/PopID() on BeginTabItem()\/EndTabItem()$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_None	vendor/imgui/imgui.h	/^    ImGuiTabItemFlags_None                          = 0,$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_SetSelected	vendor/imgui/imgui.h	/^    ImGuiTabItemFlags_SetSelected                   = 1 << 1,   \/\/ Trigger flag to programmatically make the tab selected when calling BeginTabItem()$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTabItemFlags_UnsavedDocument	vendor/imgui/imgui.h	/^    ImGuiTabItemFlags_UnsavedDocument               = 1 << 0,   \/\/ Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. Also: tab is selected on closure and closure is deferred by one frame to allow code to undo it without flicker.$/;"	e	enum:ImGuiTabItemFlags_
ImGuiTextBuffer	vendor/imgui/imgui.h	/^    ImGuiTextBuffer()   { }$/;"	f	struct:ImGuiTextBuffer
ImGuiTextBuffer	vendor/imgui/imgui.h	/^struct ImGuiTextBuffer$/;"	s
ImGuiTextEditCallback	vendor/imgui/imgui.h	/^typedef ImGuiInputTextCallback      ImGuiTextEditCallback;    \/\/ OBSOLETED in 1.63 (from Aug 2018): made the names consistent$/;"	t
ImGuiTextEditCallbackData	vendor/imgui/imgui.h	/^typedef ImGuiInputTextCallbackData  ImGuiTextEditCallbackData;$/;"	t
ImGuiTextFilter	vendor/imgui/imgui.cpp	/^ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)$/;"	f	class:ImGuiTextFilter
ImGuiTextFilter	vendor/imgui/imgui.h	/^struct ImGuiTextFilter$/;"	s
ImGuiTextFlags	vendor/imgui/imgui_internal.h	/^typedef int ImGuiTextFlags;             \/\/ -> enum ImGuiTextFlags_          \/\/ Flags: for TextEx()$/;"	t
ImGuiTextFlags_	vendor/imgui/imgui_internal.h	/^enum ImGuiTextFlags_$/;"	g
ImGuiTextFlags_NoWidthForLargeClippedText	vendor/imgui/imgui_internal.h	/^    ImGuiTextFlags_NoWidthForLargeClippedText = 1 << 0$/;"	e	enum:ImGuiTextFlags_
ImGuiTextFlags_None	vendor/imgui/imgui_internal.h	/^    ImGuiTextFlags_None = 0,$/;"	e	enum:ImGuiTextFlags_
ImGuiTextRange	vendor/imgui/imgui.h	/^        ImGuiTextRange()                                { b = e = NULL; }$/;"	f	struct:ImGuiTextFilter::ImGuiTextRange
ImGuiTextRange	vendor/imgui/imgui.h	/^        ImGuiTextRange(const char* _b, const char* _e)  { b = _b; e = _e; }$/;"	f	struct:ImGuiTextFilter::ImGuiTextRange
ImGuiTextRange	vendor/imgui/imgui.h	/^    struct ImGuiTextRange$/;"	s	struct:ImGuiTextFilter
ImGuiTreeNodeFlags	vendor/imgui/imgui.h	/^typedef int ImGuiTreeNodeFlags;     \/\/ -> enum ImGuiTreeNodeFlags_   \/\/ Flags: for TreeNode(), TreeNodeEx(), CollapsingHeader()$/;"	t
ImGuiTreeNodeFlagsPrivate_	vendor/imgui/imgui_internal.h	/^enum ImGuiTreeNodeFlagsPrivate_$/;"	g
ImGuiTreeNodeFlags_	vendor/imgui/imgui.h	/^enum ImGuiTreeNodeFlags_$/;"	g
ImGuiTreeNodeFlags_AllowItemOverlap	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_AllowItemOverlap     = 1 << 2,   \/\/ Hit testing to allow subsequent widgets to overlap this one$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_AllowOverlapMode	vendor/imgui/imgui.h	/^    , ImGuiTreeNodeFlags_AllowOverlapMode = ImGuiTreeNodeFlags_AllowItemOverlap \/\/ [renamed in 1.53]$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Bullet	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_Bullet               = 1 << 9,   \/\/ Display a bullet instead of arrow$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_ClipLabelForTrailingButton	vendor/imgui/imgui_internal.h	/^    ImGuiTreeNodeFlags_ClipLabelForTrailingButton = 1 << 20$/;"	e	enum:ImGuiTreeNodeFlagsPrivate_
ImGuiTreeNodeFlags_CollapsingHeader	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_CollapsingHeader     = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoTreePushOnOpen | ImGuiTreeNodeFlags_NoAutoOpenOnLog$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_DefaultOpen	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_DefaultOpen          = 1 << 5,   \/\/ Default node to be open$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_FramePadding	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_FramePadding         = 1 << 10,  \/\/ Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Framed	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_Framed               = 1 << 1,   \/\/ Full colored frame (e.g. for CollapsingHeader)$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Leaf	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_Leaf                 = 1 << 8,   \/\/ No collapsing, no arrow (use as a convenience for leaf nodes).$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_NavLeftJumpsBackHere	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  \/\/ (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_NoAutoOpenOnLog	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_NoAutoOpenOnLog      = 1 << 4,   \/\/ Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_NoTreePushOnOpen	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_NoTreePushOnOpen     = 1 << 3,   \/\/ Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_None	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_None                 = 0,$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_OpenOnArrow	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_OpenOnArrow          = 1 << 7,   \/\/ Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_OpenOnDoubleClick	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_OpenOnDoubleClick    = 1 << 6,   \/\/ Need double-click to open node$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiTreeNodeFlags_Selected	vendor/imgui/imgui.h	/^    ImGuiTreeNodeFlags_Selected             = 1 << 0,   \/\/ Draw as selected$/;"	e	enum:ImGuiTreeNodeFlags_
ImGuiWindow	vendor/imgui/imgui.cpp	/^ImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name)$/;"	f	class:ImGuiWindow
ImGuiWindow	vendor/imgui/imgui_internal.h	/^struct IMGUI_API ImGuiWindow$/;"	s
ImGuiWindowFlags	vendor/imgui/imgui.h	/^typedef int ImGuiWindowFlags;       \/\/ -> enum ImGuiWindowFlags_     \/\/ Flags: for Begin(), BeginChild()$/;"	t
ImGuiWindowFlags_	vendor/imgui/imgui.h	/^enum ImGuiWindowFlags_$/;"	g
ImGuiWindowFlags_AlwaysAutoResize	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_AlwaysAutoResize       = 1 << 6,   \/\/ Resize every window to its content every frame$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysHorizontalScrollbar	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_AlwaysHorizontalScrollbar=1<< 15,  \/\/ Always show horizontal scrollbar (even if ContentSize.x < Size.x)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysUseWindowPadding	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  \/\/ Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_AlwaysVerticalScrollbar	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 << 14,  \/\/ Always show vertical scrollbar (even if ContentSize.y < Size.y)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildMenu	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_ChildMenu              = 1 << 28   \/\/ Don't use! For internal use by BeginMenu()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_ChildWindow	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_ChildWindow            = 1 << 24,  \/\/ Don't use! For internal use by BeginChild()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_HorizontalScrollbar	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_HorizontalScrollbar    = 1 << 11,  \/\/ Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_MenuBar	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_MenuBar                = 1 << 10,  \/\/ Has a menu-bar$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Modal	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_Modal                  = 1 << 27,  \/\/ Don't use! For internal use by BeginPopupModal()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NavFlattened	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NavFlattened           = 1 << 23,  \/\/ [BETA] Allow gamepad\/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoBackground	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoBackground           = 1 << 7,   \/\/ Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f).$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoBringToFrontOnFocus	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoBringToFrontOnFocus  = 1 << 13,  \/\/ Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoCollapse	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoCollapse             = 1 << 5,   \/\/ Disable user collapsing window by double-clicking on it$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoDecoration	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoDecoration           = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse,$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoFocusOnAppearing	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoFocusOnAppearing     = 1 << 12,  \/\/ Disable taking focus when transitioning from hidden to visible state$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoInputs	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoInputs               = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoMouseInputs	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoMouseInputs          = 1 << 9,   \/\/ Disable catching mouse, hovering test with pass through.$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoMove	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoMove                 = 1 << 2,   \/\/ Disable user moving the window$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoNav	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoNav                  = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoNavFocus	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoNavFocus             = 1 << 19,  \/\/ No focusing toward this window with gamepad\/keyboard navigation (e.g. skipped by CTRL+TAB)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoNavInputs	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoNavInputs            = 1 << 18,  \/\/ No gamepad\/keyboard navigation within the window$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoResize	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoResize               = 1 << 1,   \/\/ Disable user resizing with the lower-right grip$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoSavedSettings	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoSavedSettings        = 1 << 8,   \/\/ Never load\/save settings in .ini file$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoScrollWithMouse	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoScrollWithMouse      = 1 << 4,   \/\/ Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoScrollbar	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoScrollbar            = 1 << 3,   \/\/ Disable scrollbars (window can still scroll with mouse or programmatically)$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_NoTitleBar	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_NoTitleBar             = 1 << 0,   \/\/ Disable title-bar$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_None	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_None                   = 0,$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Popup	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_Popup                  = 1 << 26,  \/\/ Don't use! For internal use by BeginPopup()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_Tooltip	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_Tooltip                = 1 << 25,  \/\/ Don't use! For internal use by BeginTooltip()$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowFlags_UnsavedDocument	vendor/imgui/imgui.h	/^    ImGuiWindowFlags_UnsavedDocument        = 1 << 20,  \/\/ Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab\/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker.$/;"	e	enum:ImGuiWindowFlags_
ImGuiWindowSettings	vendor/imgui/imgui_internal.h	/^    ImGuiWindowSettings() { Name = NULL; ID = 0; Pos = Size = ImVec2(0,0); Collapsed = false; }$/;"	f	struct:ImGuiWindowSettings
ImGuiWindowSettings	vendor/imgui/imgui_internal.h	/^struct ImGuiWindowSettings$/;"	s
ImGuiWindowTempData	vendor/imgui/imgui_internal.h	/^    ImGuiWindowTempData()$/;"	f	struct:ImGuiWindowTempData
ImGuiWindowTempData	vendor/imgui/imgui_internal.h	/^struct IMGUI_API ImGuiWindowTempData$/;"	s
ImGui_ImplGlfw_CharCallback	vendor/imgui/imgui_impl_glfw.cpp	/^void ImGui_ImplGlfw_CharCallback(GLFWwindow* window, unsigned int c)$/;"	f
ImGui_ImplGlfw_GetClipboardText	vendor/imgui/imgui_impl_glfw.cpp	/^static const char* ImGui_ImplGlfw_GetClipboardText(void* user_data)$/;"	f	file:
ImGui_ImplGlfw_Init	vendor/imgui/imgui_impl_glfw.cpp	/^static bool ImGui_ImplGlfw_Init(GLFWwindow* window, bool install_callbacks, GlfwClientApi client_api)$/;"	f	file:
ImGui_ImplGlfw_InitForOpenGL	vendor/imgui/imgui_impl_glfw.cpp	/^bool ImGui_ImplGlfw_InitForOpenGL(GLFWwindow* window, bool install_callbacks)$/;"	f
ImGui_ImplGlfw_InitForVulkan	vendor/imgui/imgui_impl_glfw.cpp	/^bool ImGui_ImplGlfw_InitForVulkan(GLFWwindow* window, bool install_callbacks)$/;"	f
ImGui_ImplGlfw_KeyCallback	vendor/imgui/imgui_impl_glfw.cpp	/^void ImGui_ImplGlfw_KeyCallback(GLFWwindow* window, int key, int scancode, int action, int mods)$/;"	f
ImGui_ImplGlfw_MouseButtonCallback	vendor/imgui/imgui_impl_glfw.cpp	/^void ImGui_ImplGlfw_MouseButtonCallback(GLFWwindow* window, int button, int action, int mods)$/;"	f
ImGui_ImplGlfw_NewFrame	vendor/imgui/imgui_impl_glfw.cpp	/^void ImGui_ImplGlfw_NewFrame()$/;"	f
ImGui_ImplGlfw_ScrollCallback	vendor/imgui/imgui_impl_glfw.cpp	/^void ImGui_ImplGlfw_ScrollCallback(GLFWwindow* window, double xoffset, double yoffset)$/;"	f
ImGui_ImplGlfw_SetClipboardText	vendor/imgui/imgui_impl_glfw.cpp	/^static void ImGui_ImplGlfw_SetClipboardText(void* user_data, const char* text)$/;"	f	file:
ImGui_ImplGlfw_Shutdown	vendor/imgui/imgui_impl_glfw.cpp	/^void ImGui_ImplGlfw_Shutdown()$/;"	f
ImGui_ImplGlfw_UpdateGamepads	vendor/imgui/imgui_impl_glfw.cpp	/^static void ImGui_ImplGlfw_UpdateGamepads()$/;"	f	file:
ImGui_ImplGlfw_UpdateMouseCursor	vendor/imgui/imgui_impl_glfw.cpp	/^static void ImGui_ImplGlfw_UpdateMouseCursor()$/;"	f	file:
ImGui_ImplGlfw_UpdateMousePosAndButtons	vendor/imgui/imgui_impl_glfw.cpp	/^static void ImGui_ImplGlfw_UpdateMousePosAndButtons()$/;"	f	file:
ImGui_ImplOpenGL3_CreateDeviceObjects	vendor/imgui/imgui_impl_opengl3.cpp	/^bool    ImGui_ImplOpenGL3_CreateDeviceObjects()$/;"	f
ImGui_ImplOpenGL3_CreateFontsTexture	vendor/imgui/imgui_impl_opengl3.cpp	/^bool ImGui_ImplOpenGL3_CreateFontsTexture()$/;"	f
ImGui_ImplOpenGL3_DestroyDeviceObjects	vendor/imgui/imgui_impl_opengl3.cpp	/^void    ImGui_ImplOpenGL3_DestroyDeviceObjects()$/;"	f
ImGui_ImplOpenGL3_DestroyFontsTexture	vendor/imgui/imgui_impl_opengl3.cpp	/^void ImGui_ImplOpenGL3_DestroyFontsTexture()$/;"	f
ImGui_ImplOpenGL3_Init	vendor/imgui/imgui_impl_opengl3.cpp	/^bool    ImGui_ImplOpenGL3_Init(const char* glsl_version)$/;"	f
ImGui_ImplOpenGL3_NewFrame	vendor/imgui/imgui_impl_opengl3.cpp	/^void    ImGui_ImplOpenGL3_NewFrame()$/;"	f
ImGui_ImplOpenGL3_RenderDrawData	vendor/imgui/imgui_impl_opengl3.cpp	/^void    ImGui_ImplOpenGL3_RenderDrawData(ImDrawData* draw_data)$/;"	f
ImGui_ImplOpenGL3_SetupRenderState	vendor/imgui/imgui_impl_opengl3.cpp	/^static void ImGui_ImplOpenGL3_SetupRenderState(ImDrawData* draw_data, int fb_width, int fb_height, GLuint vertex_array_object)$/;"	f	file:
ImGui_ImplOpenGL3_Shutdown	vendor/imgui/imgui_impl_opengl3.cpp	/^void    ImGui_ImplOpenGL3_Shutdown()$/;"	f
ImHash	vendor/imgui/imgui_internal.h	/^static inline ImU32     ImHash(const void* data, int size, ImU32 seed = 0) { return size ? ImHashData(data, (size_t)size, seed) : ImHashStr((const char*)data, 0, seed); } \/\/ [moved to ImHashStr\/ImHashData in 1.68]$/;"	f
ImHashData	vendor/imgui/imgui.cpp	/^ImU32 ImHashData(const void* data_p, size_t data_size, ImU32 seed)$/;"	f
ImHashStr	vendor/imgui/imgui.cpp	/^ImU32 ImHashStr(const char* data_p, size_t data_size, ImU32 seed)$/;"	f
ImInvLength	vendor/imgui/imgui_internal.h	/^static inline float  ImInvLength(const ImVec2& lhs, float fail_value)           { float d = lhs.x*lhs.x + lhs.y*lhs.y; if (d > 0.0f) return 1.0f \/ ImSqrt(d); return fail_value; }$/;"	f
ImIsPowerOfTwo	vendor/imgui/imgui_internal.h	/^static inline bool      ImIsPowerOfTwo(int v)           { return v != 0 && (v & (v - 1)) == 0; }$/;"	f
ImLengthSqr	vendor/imgui/imgui_internal.h	/^static inline float  ImLengthSqr(const ImVec2& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y; }$/;"	f
ImLengthSqr	vendor/imgui/imgui_internal.h	/^static inline float  ImLengthSqr(const ImVec4& lhs)                             { return lhs.x*lhs.x + lhs.y*lhs.y + lhs.z*lhs.z + lhs.w*lhs.w; }$/;"	f
ImLerp	vendor/imgui/imgui_internal.h	/^static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t)  { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }$/;"	f
ImLerp	vendor/imgui/imgui_internal.h	/^static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t)          { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }$/;"	f
ImLerp	vendor/imgui/imgui_internal.h	/^static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t)          { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }$/;"	f
ImLerp	vendor/imgui/imgui_internal.h	/^template<typename T> static inline T ImLerp(T a, T b, float t)                  { return (T)(a + (b - a) * t); }$/;"	f
ImLineClosestPoint	vendor/imgui/imgui.cpp	/^ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)$/;"	f
ImLinearSweep	vendor/imgui/imgui_internal.h	/^static inline float  ImLinearSweep(float current, float target, float speed)    { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }$/;"	f
ImMax	vendor/imgui/imgui_internal.h	/^static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }$/;"	f
ImMax	vendor/imgui/imgui_internal.h	/^template<typename T> static inline T ImMax(T lhs, T rhs)                        { return lhs >= rhs ? lhs : rhs; }$/;"	f
ImMin	vendor/imgui/imgui_internal.h	/^static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }$/;"	f
ImMin	vendor/imgui/imgui_internal.h	/^template<typename T> static inline T ImMin(T lhs, T rhs)                        { return lhs < rhs ? lhs : rhs; }$/;"	f
ImModPositive	vendor/imgui/imgui_internal.h	/^static inline int    ImModPositive(int a, int b)                                { return (a + b) % b; }$/;"	f
ImMul	vendor/imgui/imgui_internal.h	/^static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs)                { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }$/;"	f
ImNewDummy	vendor/imgui/imgui.h	/^struct ImNewDummy {};$/;"	s
ImParseFormatFindEnd	vendor/imgui/imgui_widgets.cpp	/^const char* ImParseFormatFindEnd(const char* fmt)$/;"	f
ImParseFormatFindStart	vendor/imgui/imgui_widgets.cpp	/^const char* ImParseFormatFindStart(const char* fmt)$/;"	f
ImParseFormatPrecision	vendor/imgui/imgui_widgets.cpp	/^int ImParseFormatPrecision(const char* fmt, int default_precision)$/;"	f
ImParseFormatTrimDecorations	vendor/imgui/imgui_widgets.cpp	/^const char* ImParseFormatTrimDecorations(const char* fmt, char* buf, size_t buf_size)$/;"	f
ImPool	vendor/imgui/imgui_internal.h	/^    ImPool()    { FreeIdx = 0; }$/;"	f	struct:ImPool
ImPool	vendor/imgui/imgui_internal.h	/^struct IMGUI_API ImPool$/;"	s
ImPoolIdx	vendor/imgui/imgui_internal.h	/^typedef int ImPoolIdx;$/;"	t
ImPow	vendor/imgui/imgui_internal.h	/^static inline double ImPow(double x, double y)                                  { return pow(x, y); }$/;"	f
ImPow	vendor/imgui/imgui_internal.h	/^static inline float  ImPow(float x, float y)                                    { return powf(x, y); }$/;"	f
ImQsort	vendor/imgui/imgui_internal.h	177;"	d
ImRect	vendor/imgui/imgui_internal.h	/^    ImRect()                                        : Min(FLT_MAX,FLT_MAX), Max(-FLT_MAX,-FLT_MAX)  {}$/;"	f	struct:ImRect
ImRect	vendor/imgui/imgui_internal.h	/^    ImRect(const ImVec2& min, const ImVec2& max)    : Min(min), Max(max)                            {}$/;"	f	struct:ImRect
ImRect	vendor/imgui/imgui_internal.h	/^    ImRect(const ImVec4& v)                         : Min(v.x, v.y), Max(v.z, v.w)                  {}$/;"	f	struct:ImRect
ImRect	vendor/imgui/imgui_internal.h	/^    ImRect(float x1, float y1, float x2, float y2)  : Min(x1, y1), Max(x2, y2)                      {}$/;"	f	struct:ImRect
ImRect	vendor/imgui/imgui_internal.h	/^struct IMGUI_API ImRect$/;"	s
ImRotate	vendor/imgui/imgui_internal.h	/^static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a)        { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }$/;"	f
ImS16	vendor/imgui/imgui.h	/^typedef signed short        ImS16;  \/\/ 16-bit signed integer$/;"	t
ImS32	vendor/imgui/imgui.h	/^typedef signed int          ImS32;  \/\/ 32-bit signed integer == int$/;"	t
ImS64	vendor/imgui/imgui.h	/^typedef int64_t             ImS64;  \/\/ 64-bit signed integer (pre C++11)$/;"	t
ImS64	vendor/imgui/imgui.h	/^typedef signed   __int64    ImS64;  \/\/ 64-bit signed integer (pre and post C++11 with Visual Studio)$/;"	t
ImS64	vendor/imgui/imgui.h	/^typedef signed   long long  ImS64;  \/\/ 64-bit signed integer (post C++11)$/;"	t
ImS8	vendor/imgui/imgui.h	/^typedef signed char         ImS8;   \/\/ 8-bit signed integer == char$/;"	t
ImSaturate	vendor/imgui/imgui_internal.h	/^static inline float  ImSaturate(float f)                                        { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }$/;"	f
ImSin	vendor/imgui/imgui_internal.h	/^static inline float  ImSin(float x)                                             { return sinf(x); }$/;"	f
ImSqrt	vendor/imgui/imgui_internal.h	/^static inline float  ImSqrt(float x)                                            { return sqrtf(x); }$/;"	f
ImStb	vendor/imgui/imgui_internal.h	/^namespace ImStb$/;"	n
ImStb	vendor/imgui/imgui_widgets.cpp	/^namespace ImStb$/;"	n	file:
ImStrTrimBlanks	vendor/imgui/imgui.cpp	/^void ImStrTrimBlanks(char* buf)$/;"	f
ImStrbolW	vendor/imgui/imgui.cpp	/^const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) \/\/ find beginning-of-line$/;"	f
ImStrchrRange	vendor/imgui/imgui.cpp	/^const char* ImStrchrRange(const char* str, const char* str_end, char c)$/;"	f
ImStrdup	vendor/imgui/imgui.cpp	/^char* ImStrdup(const char* str)$/;"	f
ImStrdupcpy	vendor/imgui/imgui.cpp	/^char* ImStrdupcpy(char* dst, size_t* p_dst_size, const char* src)$/;"	f
ImStreolRange	vendor/imgui/imgui.cpp	/^const char* ImStreolRange(const char* str, const char* str_end)$/;"	f
ImStricmp	vendor/imgui/imgui.cpp	/^int ImStricmp(const char* str1, const char* str2)$/;"	f
ImStristr	vendor/imgui/imgui.cpp	/^const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)$/;"	f
ImStrlenW	vendor/imgui/imgui.cpp	/^int ImStrlenW(const ImWchar* str)$/;"	f
ImStrncpy	vendor/imgui/imgui.cpp	/^void ImStrncpy(char* dst, const char* src, size_t count)$/;"	f
ImStrnicmp	vendor/imgui/imgui.cpp	/^int ImStrnicmp(const char* str1, const char* str2, size_t count)$/;"	f
ImSubClampOverflow	vendor/imgui/imgui_internal.h	/^template<typename T> static inline T ImSubClampOverflow(T a, T b, T mn, T mx)   { if (b > 0 && (a < mn + b)) return mn; if (b < 0 && (a > mx + b)) return mx; return a - b; }$/;"	f
ImSwap	vendor/imgui/imgui_internal.h	/^template<typename T> static inline void ImSwap(T& a, T& b)                      { T tmp = a; a = b; b = tmp; }$/;"	f
ImTextCharFromUtf8	vendor/imgui/imgui.cpp	/^int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)$/;"	f
ImTextCharToUtf8	vendor/imgui/imgui.cpp	/^static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)$/;"	f	file:
ImTextCountCharsFromUtf8	vendor/imgui/imgui.cpp	/^int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)$/;"	f
ImTextCountUtf8BytesFromChar	vendor/imgui/imgui.cpp	/^int ImTextCountUtf8BytesFromChar(const char* in_text, const char* in_text_end)$/;"	f
ImTextCountUtf8BytesFromChar	vendor/imgui/imgui.cpp	/^static inline int ImTextCountUtf8BytesFromChar(unsigned int c)$/;"	f	file:
ImTextCountUtf8BytesFromStr	vendor/imgui/imgui.cpp	/^int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)$/;"	f
ImTextStrFromUtf8	vendor/imgui/imgui.cpp	/^int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)$/;"	f
ImTextStrToUtf8	vendor/imgui/imgui.cpp	/^int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)$/;"	f
ImTextureID	vendor/imgui/imgui.h	/^typedef void* ImTextureID;          \/\/ User data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)$/;"	t
ImTriangleBarycentricCoords	vendor/imgui/imgui.cpp	/^void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)$/;"	f
ImTriangleClosestPoint	vendor/imgui/imgui.cpp	/^ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)$/;"	f
ImTriangleContainsPoint	vendor/imgui/imgui.cpp	/^bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)$/;"	f
ImU16	vendor/imgui/imgui.h	/^typedef unsigned short      ImU16;  \/\/ 16-bit unsigned integer$/;"	t
ImU32	vendor/imgui/imgui.h	/^typedef unsigned int        ImU32;  \/\/ 32-bit unsigned integer (often used to store packed colors)$/;"	t
ImU64	vendor/imgui/imgui.h	/^typedef uint64_t            ImU64;  \/\/ 64-bit unsigned integer (pre C++11)$/;"	t
ImU64	vendor/imgui/imgui.h	/^typedef unsigned __int64    ImU64;  \/\/ 64-bit unsigned integer (pre and post C++11 with Visual Studio)$/;"	t
ImU64	vendor/imgui/imgui.h	/^typedef unsigned long long  ImU64;  \/\/ 64-bit unsigned integer (post C++11)$/;"	t
ImU8	vendor/imgui/imgui.h	/^typedef unsigned char       ImU8;   \/\/ 8-bit unsigned integer$/;"	t
ImUpperPowerOfTwo	vendor/imgui/imgui_internal.h	/^static inline int       ImUpperPowerOfTwo(int v)        { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }$/;"	f
ImVec1	vendor/imgui/imgui_internal.h	/^    ImVec1()         { x = 0.0f; }$/;"	f	struct:ImVec1
ImVec1	vendor/imgui/imgui_internal.h	/^    ImVec1(float _x) { x = _x; }$/;"	f	struct:ImVec1
ImVec1	vendor/imgui/imgui_internal.h	/^struct ImVec1$/;"	s
ImVec2	vendor/imgui/imgui.h	/^    ImVec2()  { x = y = 0.0f; }$/;"	f	struct:ImVec2
ImVec2	vendor/imgui/imgui.h	/^    ImVec2(float _x, float _y) { x = _x; y = _y; }$/;"	f	struct:ImVec2
ImVec2	vendor/imgui/imgui.h	/^struct ImVec2$/;"	s
ImVec4	vendor/imgui/imgui.h	/^    ImVec4()  { x = y = z = w = 0.0f; }$/;"	f	struct:ImVec4
ImVec4	vendor/imgui/imgui.h	/^    ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }$/;"	f	struct:ImVec4
ImVec4	vendor/imgui/imgui.h	/^struct ImVec4$/;"	s
ImVector	vendor/imgui/imgui.h	/^    inline ImVector()                                       { Size = Capacity = 0; Data = NULL; }$/;"	f	struct:ImVector
ImVector	vendor/imgui/imgui.h	/^    inline ImVector(const ImVector<T>& src)                 { Size = Capacity = 0; Data = NULL; operator=(src); }$/;"	f	struct:ImVector
ImVector	vendor/imgui/imgui.h	/^struct ImVector$/;"	s
ImWchar	vendor/imgui/imgui.h	/^typedef unsigned short ImWchar;     \/\/ A single U16 character for keyboard input\/display. We encode them as multi bytes UTF-8 when used in strings.$/;"	t
Image	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)$/;"	f	class:ImGui
ImageButton	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)$/;"	f	class:ImGui
ImeSetInputScreenPosFn	vendor/imgui/imgui.h	/^    void        (*ImeSetInputScreenPosFn)(int x, int y);$/;"	m	struct:ImGuiIO
ImeSetInputScreenPosFn_DefaultImpl	vendor/imgui/imgui.cpp	/^static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)$/;"	f	file:
ImeSetInputScreenPosFn_DefaultImpl	vendor/imgui/imgui.cpp	/^static void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}$/;"	f	file:
ImeWindowHandle	vendor/imgui/imgui.h	/^    void*       ImeWindowHandle;                \/\/ = NULL           \/\/ (Windows) Set this to your HWND to get automatic IME cursor positioning.$/;"	m	struct:ImGuiIO
Indent	vendor/imgui/imgui.cpp	/^void ImGui::Indent(float indent_w)$/;"	f	class:ImGui
Indent	vendor/imgui/imgui_internal.h	/^    ImVec1                  Indent;                 \/\/ Indentation \/ start position from left of window (increased by TreePush\/TreePop, etc.)$/;"	m	struct:ImGuiWindowTempData
IndentSpacing	vendor/imgui/imgui.h	/^    float       IndentSpacing;              \/\/ Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).$/;"	m	struct:ImGuiStyle
Index	vendor/imgui/imgui_internal.h	/^    int             Index;              \/\/ Usually index in a main pool.$/;"	m	struct:ImGuiPtrOrIndex
Index	vendor/imgui/imgui_internal.h	/^    int             Index;$/;"	m	struct:ImGuiShrinkWidthItem
IndexAdvanceX	vendor/imgui/imgui.h	/^    ImVector<float>             IndexAdvanceX;      \/\/ 12-16 \/\/ out \/\/            \/\/ Sparse. Glyphs->AdvanceX in a directly indexable way (cache-friendly for CalcTextSize functions which only this this info, and are often bottleneck in large UI).$/;"	m	struct:ImFont
IndexBuffer	IndexBuffer/IndexBuffer.cpp	/^IndexBuffer::IndexBuffer(const unsigned int* data, unsigned int count)$/;"	f	class:IndexBuffer
IndexBuffer	IndexBuffer/IndexBuffer.h	/^class IndexBuffer{$/;"	c
IndexLookup	vendor/imgui/imgui.h	/^    ImVector<ImWchar>           IndexLookup;        \/\/ 12-16 \/\/ out \/\/            \/\/ Sparse. Index glyphs by Unicode code-point.$/;"	m	struct:ImFont
IniFilename	vendor/imgui/imgui.h	/^    const char* IniFilename;                    \/\/ = "imgui.ini"    \/\/ Path to .ini file. Set NULL to disable automatic .ini loading\/saving, if e.g. you want to manually load\/save from memory.$/;"	m	struct:ImGuiIO
IniSavingRate	vendor/imgui/imgui.h	/^    float       IniSavingRate;                  \/\/ = 5.0f           \/\/ Minimum time between saving positions\/sizes to .ini file, in seconds.$/;"	m	struct:ImGuiIO
InitialFlags	vendor/imgui/imgui_internal.h	/^    ImDrawListFlags InitialFlags;               \/\/ Initial flags at the beginning of the frame (it is possible to alter flags on a per-drawlist basis afterwards)$/;"	m	struct:ImDrawListSharedData
InitialTextA	vendor/imgui/imgui_internal.h	/^    ImVector<char>          InitialTextA;           \/\/ backup of end-user buffer at the time of focus (in UTF-8, unaltered)$/;"	m	struct:ImGuiInputTextState
Initialize	vendor/imgui/imgui.cpp	/^void ImGui::Initialize(ImGuiContext* context)$/;"	f	class:ImGui
Initialized	vendor/imgui/imgui_internal.h	/^    bool                    Initialized;$/;"	m	struct:ImGuiContext
InnerClipRect	vendor/imgui/imgui_internal.h	/^    ImRect                  InnerClipRect;                      \/\/ == InnerRect shrunk by WindowPadding*0.5f on each side, clipped within viewport or parent clip rect.$/;"	m	struct:ImGuiWindow
InnerDir	vendor/imgui/imgui.cpp	/^    ImVec2  InnerDir;$/;"	m	struct:ImGuiResizeGripDef	file:
InnerRect	vendor/imgui/imgui_internal.h	/^    ImRect                  InnerRect;                          \/\/ Inner rectangle (omit title bar, menu bar, scroll bar)$/;"	m	struct:ImGuiWindow
InputBuf	vendor/imgui/imgui.h	/^    char                    InputBuf[256];$/;"	m	struct:ImGuiTextFilter
InputBuf	vendor/imgui/imgui_demo.cpp	/^    char                  InputBuf[256];$/;"	m	struct:ExampleAppConsole	file:
InputDouble	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat2	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputFloat2(const char* label, float v[2], const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat2	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat3	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputFloat3(const char* label, float v[3], const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat3	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat4	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputFloat4(const char* label, float v[4], const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputFloat4	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputInt	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputInt2	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputInt3	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputInt4	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputQueueCharacters	vendor/imgui/imgui.h	/^    ImVector<ImWchar> InputQueueCharacters;     \/\/ Queue of _characters_ input (obtained by platform back-end). Fill using AddInputCharacter() helper.$/;"	m	struct:ImGuiIO
InputScalar	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputScalar(const char* label, ImGuiDataType data_type, void* data_ptr, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputScalarN	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* step, const void* step_fast, const char* format, ImGuiInputTextFlags flags)$/;"	f	class:ImGui
InputText	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)$/;"	f	class:ImGui
InputTextCalcTextLenAndLineCount	vendor/imgui/imgui_widgets.cpp	/^static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)$/;"	f	file:
InputTextCalcTextSizeW	vendor/imgui/imgui_widgets.cpp	/^static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)$/;"	f	file:
InputTextEx	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputTextEx(const char* label, const char* hint, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* callback_user_data)$/;"	f	class:ImGui
InputTextFilterCharacter	vendor/imgui/imgui_widgets.cpp	/^static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)$/;"	f	file:
InputTextMultiline	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)$/;"	f	class:ImGui
InputTextPasswordFont	vendor/imgui/imgui_internal.h	/^    ImFont                  InputTextPasswordFont;$/;"	m	struct:ImGuiContext
InputTextState	vendor/imgui/imgui_internal.h	/^    ImGuiInputTextState     InputTextState;$/;"	m	struct:ImGuiContext
InputTextWithHint	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InputTextWithHint(const char* label, const char* hint, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiInputTextCallback callback, void* user_data)$/;"	f	class:ImGui
InsertChars	vendor/imgui/imgui_widgets.cpp	/^void ImGuiInputTextCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)$/;"	f	class:ImGuiInputTextCallbackData
InvisibleButton	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)$/;"	f	class:ImGui
IsActive	vendor/imgui/imgui.h	/^    bool                IsActive() const { return !Filters.empty(); }$/;"	f	struct:ImGuiTextFilter
IsAnyItemActive	vendor/imgui/imgui.cpp	/^bool ImGui::IsAnyItemActive()$/;"	f	class:ImGui
IsAnyItemFocused	vendor/imgui/imgui.cpp	/^bool ImGui::IsAnyItemFocused()$/;"	f	class:ImGui
IsAnyItemHovered	vendor/imgui/imgui.cpp	/^bool ImGui::IsAnyItemHovered()$/;"	f	class:ImGui
IsAnyMouseDown	vendor/imgui/imgui.cpp	/^bool ImGui::IsAnyMouseDown()$/;"	f	class:ImGui
IsAnyWindowFocused	vendor/imgui/imgui.h	/^    static inline bool  IsAnyWindowFocused()                  { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }$/;"	f	namespace:ImGui
IsAnyWindowHovered	vendor/imgui/imgui.h	/^    static inline bool  IsAnyWindowHovered()                  { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }$/;"	f	namespace:ImGui
IsBeingResized	vendor/imgui/imgui_internal.h	/^    bool                IsBeingResized;$/;"	m	struct:ImGuiColumns
IsBuilt	vendor/imgui/imgui.h	/^    bool                        IsBuilt()                   { return Fonts.Size > 0 && (TexPixelsAlpha8 != NULL || TexPixelsRGBA32 != NULL); }$/;"	f	struct:ImFontAtlas
IsClippedEx	vendor/imgui/imgui.cpp	/^bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)$/;"	f	class:ImGui
IsDataType	vendor/imgui/imgui.h	/^    bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }$/;"	f	struct:ImGuiPayload
IsDelivery	vendor/imgui/imgui.h	/^    bool IsDelivery() const                 { return Delivery; }$/;"	f	struct:ImGuiPayload
IsDragDropPayloadBeingAccepted	vendor/imgui/imgui.cpp	/^bool ImGui::IsDragDropPayloadBeingAccepted()$/;"	f	class:ImGui
IsFirstFrame	vendor/imgui/imgui_internal.h	/^    bool                IsFirstFrame;$/;"	m	struct:ImGuiColumns
IsInverted	vendor/imgui/imgui_internal.h	/^    bool        IsInverted() const                  { return Min.x > Max.x || Min.y > Max.y; }$/;"	f	struct:ImRect
IsItemActivated	vendor/imgui/imgui.cpp	/^bool ImGui::IsItemActivated()$/;"	f	class:ImGui
IsItemActive	vendor/imgui/imgui.cpp	/^bool ImGui::IsItemActive()$/;"	f	class:ImGui
IsItemClicked	vendor/imgui/imgui.cpp	/^bool ImGui::IsItemClicked(int mouse_button)$/;"	f	class:ImGui
IsItemDeactivated	vendor/imgui/imgui.cpp	/^bool ImGui::IsItemDeactivated()$/;"	f	class:ImGui
IsItemDeactivatedAfterChange	vendor/imgui/imgui.h	/^    static inline bool  IsItemDeactivatedAfterChange()        { return IsItemDeactivatedAfterEdit(); }$/;"	f	namespace:ImGui
IsItemDeactivatedAfterEdit	vendor/imgui/imgui.cpp	/^bool ImGui::IsItemDeactivatedAfterEdit()$/;"	f	class:ImGui
IsItemEdited	vendor/imgui/imgui.cpp	/^bool ImGui::IsItemEdited()$/;"	f	class:ImGui
IsItemFocused	vendor/imgui/imgui.cpp	/^bool ImGui::IsItemFocused()$/;"	f	class:ImGui
IsItemHovered	vendor/imgui/imgui.cpp	/^bool ImGui::IsItemHovered(ImGuiHoveredFlags flags)$/;"	f	class:ImGui
IsItemToggledSelection	vendor/imgui/imgui.cpp	/^bool ImGui::IsItemToggledSelection()$/;"	f	class:ImGui
IsItemVisible	vendor/imgui/imgui.cpp	/^bool ImGui::IsItemVisible()$/;"	f	class:ImGui
IsKeyDown	vendor/imgui/imgui.cpp	/^bool ImGui::IsKeyDown(int user_key_index)$/;"	f	class:ImGui
IsKeyPressed	vendor/imgui/imgui.cpp	/^bool ImGui::IsKeyPressed(int user_key_index, bool repeat)$/;"	f	class:ImGui
IsKeyPressedMap	vendor/imgui/imgui_internal.h	/^    inline bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true)           { const int key_index = GImGui->IO.KeyMap[key]; return (key_index >= 0) ? IsKeyPressed(key_index, repeat) : false; }$/;"	f	namespace:ImGui
IsKeyReleased	vendor/imgui/imgui.cpp	/^bool ImGui::IsKeyReleased(int user_key_index)$/;"	f	class:ImGui
IsLoaded	vendor/imgui/imgui.h	/^    bool                        IsLoaded() const                    { return ContainerAtlas != NULL; }$/;"	f	struct:ImFont
IsMouseClicked	vendor/imgui/imgui.cpp	/^bool ImGui::IsMouseClicked(int button, bool repeat)$/;"	f	class:ImGui
IsMouseDoubleClicked	vendor/imgui/imgui.cpp	/^bool ImGui::IsMouseDoubleClicked(int button)$/;"	f	class:ImGui
IsMouseDown	vendor/imgui/imgui.cpp	/^bool ImGui::IsMouseDown(int button)$/;"	f	class:ImGui
IsMouseDragPastThreshold	vendor/imgui/imgui.cpp	/^bool ImGui::IsMouseDragPastThreshold(int button, float lock_threshold)$/;"	f	class:ImGui
IsMouseDragging	vendor/imgui/imgui.cpp	/^bool ImGui::IsMouseDragging(int button, float lock_threshold)$/;"	f	class:ImGui
IsMouseHoveringRect	vendor/imgui/imgui.cpp	/^bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)$/;"	f	class:ImGui
IsMousePosValid	vendor/imgui/imgui.cpp	/^bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)$/;"	f	class:ImGui
IsMouseReleased	vendor/imgui/imgui.cpp	/^bool ImGui::IsMouseReleased(int button)$/;"	f	class:ImGui
IsNavInputDown	vendor/imgui/imgui_internal.h	/^    inline bool             IsNavInputDown(ImGuiNavInput n)                             { return GImGui->IO.NavInputs[n] > 0.0f; }$/;"	f	namespace:ImGui
IsNavInputPressed	vendor/imgui/imgui_internal.h	/^    inline bool             IsNavInputPressed(ImGuiNavInput n, ImGuiInputReadMode mode) { return GetNavInputAmount(n, mode) > 0.0f; }$/;"	f	namespace:ImGui
IsNavInputPressedAnyOfTwo	vendor/imgui/imgui_internal.h	/^    inline bool             IsNavInputPressedAnyOfTwo(ImGuiNavInput n1, ImGuiNavInput n2, ImGuiInputReadMode mode) { return (GetNavInputAmount(n1, mode) + GetNavInputAmount(n2, mode)) > 0.0f; }$/;"	f	namespace:ImGui
IsPacked	vendor/imgui/imgui.h	/^    bool IsPacked() const           { return X != 0xFFFF; }$/;"	f	struct:ImFontAtlasCustomRect
IsPopupOpen	vendor/imgui/imgui.cpp	/^bool ImGui::IsPopupOpen(ImGuiID id)$/;"	f	class:ImGui
IsPopupOpen	vendor/imgui/imgui.cpp	/^bool ImGui::IsPopupOpen(const char* str_id)$/;"	f	class:ImGui
IsPreview	vendor/imgui/imgui.h	/^    bool IsPreview() const                  { return Preview; }$/;"	f	struct:ImGuiPayload
IsRectVisible	vendor/imgui/imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)$/;"	f	class:ImGui
IsRectVisible	vendor/imgui/imgui.cpp	/^bool ImGui::IsRectVisible(const ImVec2& size)$/;"	f	class:ImGui
IsRootWindowFocused	vendor/imgui/imgui.h	/^    static inline bool  IsRootWindowFocused()                 { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }$/;"	f	namespace:ImGui
IsRootWindowOrAnyChildFocused	vendor/imgui/imgui.h	/^    static inline bool  IsRootWindowOrAnyChildFocused()       { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }$/;"	f	namespace:ImGui
IsRootWindowOrAnyChildHovered	vendor/imgui/imgui.h	/^    static inline bool  IsRootWindowOrAnyChildHovered()       { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }$/;"	f	namespace:ImGui
IsWindowActiveAndVisible	vendor/imgui/imgui.cpp	/^static bool IsWindowActiveAndVisible(ImGuiWindow* window)$/;"	f	file:
IsWindowAppearing	vendor/imgui/imgui.cpp	/^bool ImGui::IsWindowAppearing()$/;"	f	class:ImGui
IsWindowChildOf	vendor/imgui/imgui.cpp	/^bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)$/;"	f	class:ImGui
IsWindowCollapsed	vendor/imgui/imgui.cpp	/^bool ImGui::IsWindowCollapsed()$/;"	f	class:ImGui
IsWindowContentHoverable	vendor/imgui/imgui.cpp	/^static inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)$/;"	f	file:
IsWindowFocused	vendor/imgui/imgui.cpp	/^bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)$/;"	f	class:ImGui
IsWindowHovered	vendor/imgui/imgui.cpp	/^bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)$/;"	f	class:ImGui
IsWindowNavFocusable	vendor/imgui/imgui.cpp	/^bool ImGui::IsWindowNavFocusable(ImGuiWindow* window)$/;"	f	class:ImGui
ItemAdd	vendor/imgui/imgui.cpp	/^bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg)$/;"	f	class:ImGui
ItemFlags	vendor/imgui/imgui_internal.h	/^    ImGuiItemFlags          ItemFlags;              \/\/ == ItemFlagsStack.back() [empty == ImGuiItemFlags_Default]$/;"	m	struct:ImGuiWindowTempData
ItemFlagsStack	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiItemFlags>ItemFlagsStack;$/;"	m	struct:ImGuiWindowTempData
ItemHoverable	vendor/imgui/imgui.cpp	/^bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)$/;"	f	class:ImGui
ItemInnerSpacing	vendor/imgui/imgui.h	/^    ImVec2      ItemInnerSpacing;           \/\/ Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).$/;"	m	struct:ImGuiStyle
ItemSize	vendor/imgui/imgui.cpp	/^void ImGui::ItemSize(const ImRect& bb, float text_offset_y)$/;"	f	class:ImGui
ItemSize	vendor/imgui/imgui.cpp	/^void ImGui::ItemSize(const ImVec2& size, float text_offset_y)$/;"	f	class:ImGui
ItemSpacing	vendor/imgui/imgui.h	/^    ImVec2      ItemSpacing;                \/\/ Horizontal and vertical spacing between widgets\/lines.$/;"	m	struct:ImGuiStyle
ItemWidth	vendor/imgui/imgui_internal.h	/^    float                   ItemWidth;              \/\/ == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window$/;"	m	struct:ImGuiWindowTempData
ItemWidthDefault	vendor/imgui/imgui_internal.h	/^    float                   ItemWidthDefault;$/;"	m	struct:ImGuiWindow
ItemWidthStack	vendor/imgui/imgui_internal.h	/^    ImVector<float>         ItemWidthStack;$/;"	m	struct:ImGuiWindowTempData
Items	vendor/imgui/imgui_demo.cpp	/^    ImVector<char*>       Items;$/;"	m	struct:ExampleAppConsole	file:
ItemsCount	vendor/imgui/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper
ItemsHeight	vendor/imgui/imgui.h	/^    float   ItemsHeight;$/;"	m	struct:ImGuiListClipper
Items_ArrayGetter	vendor/imgui/imgui_widgets.cpp	/^static bool Items_ArrayGetter(void* data, int idx, const char** out_text)$/;"	f	file:
Items_SingleStringGetter	vendor/imgui/imgui_widgets.cpp	/^static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)$/;"	f	file:
KeepAliveID	vendor/imgui/imgui.cpp	/^void ImGui::KeepAliveID(ImGuiID id)$/;"	f	class:ImGui
KeyAlt	vendor/imgui/imgui.h	/^    bool        KeyAlt;                         \/\/ Keyboard modifier pressed: Alt$/;"	m	struct:ImGuiIO
KeyCtrl	vendor/imgui/imgui.h	/^    bool        KeyCtrl;                        \/\/ Keyboard modifier pressed: Control$/;"	m	struct:ImGuiIO
KeyMap	vendor/imgui/imgui.h	/^    int         KeyMap[ImGuiKey_COUNT];         \/\/ <unset>          \/\/ Map of indices into the KeysDown[512] entries array which represent your "native" keyboard state.$/;"	m	struct:ImGuiIO
KeyRepeatDelay	vendor/imgui/imgui.h	/^    float       KeyRepeatDelay;                 \/\/ = 0.250f         \/\/ When holding a key\/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).$/;"	m	struct:ImGuiIO
KeyRepeatRate	vendor/imgui/imgui.h	/^    float       KeyRepeatRate;                  \/\/ = 0.050f         \/\/ When holding a key\/button, rate at which it repeats, in seconds.$/;"	m	struct:ImGuiIO
KeyShift	vendor/imgui/imgui.h	/^    bool        KeyShift;                       \/\/ Keyboard modifier pressed: Shift$/;"	m	struct:ImGuiIO
KeySuper	vendor/imgui/imgui.h	/^    bool        KeySuper;                       \/\/ Keyboard modifier pressed: Cmd\/Super\/Windows$/;"	m	struct:ImGuiIO
KeysDown	vendor/imgui/imgui.h	/^    bool        KeysDown[512];                  \/\/ Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own defines\/enums for keys).$/;"	m	struct:ImGuiIO
KeysDownDuration	vendor/imgui/imgui.h	/^    float       KeysDownDuration[512];          \/\/ Duration the keyboard key has been down (0.0f == just pressed)$/;"	m	struct:ImGuiIO
KeysDownDurationPrev	vendor/imgui/imgui.h	/^    float       KeysDownDurationPrev[512];      \/\/ Previous duration the key has been down$/;"	m	struct:ImGuiIO
LabelText	vendor/imgui/imgui_widgets.cpp	/^void ImGui::LabelText(const char* label, const char* fmt, ...)$/;"	f	class:ImGui
LabelTextV	vendor/imgui/imgui_widgets.cpp	/^void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)$/;"	f	class:ImGui
LastActiveId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 LastActiveId;                       \/\/ Store the last non-zero ActiveId, useful for animation.$/;"	m	struct:ImGuiContext
LastActiveIdTimer	vendor/imgui/imgui_internal.h	/^    float                   LastActiveIdTimer;                  \/\/ Store the last non-zero ActiveId timer since the beginning of activation, useful for animation.$/;"	m	struct:ImGuiContext
LastFrameActive	vendor/imgui/imgui_internal.h	/^    int                     LastFrameActive;                    \/\/ Last frame number the window was Active.$/;"	m	struct:ImGuiWindow
LastFrameSelected	vendor/imgui/imgui_internal.h	/^    int                 LastFrameSelected;      \/\/ This allows us to infer an ordered list of the last activated tabs with little maintenance$/;"	m	struct:ImGuiTabItem
LastFrameVisible	vendor/imgui/imgui_internal.h	/^    int                 LastFrameVisible;$/;"	m	struct:ImGuiTabItem
LastItemDisplayRect	vendor/imgui/imgui_internal.h	/^    ImRect                  LastItemDisplayRect;    \/\/ End-user display rect (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)$/;"	m	struct:ImGuiWindowTempData
LastItemDisplayRect	vendor/imgui/imgui_internal.h	/^    ImRect                  LastItemDisplayRect;$/;"	m	struct:ImGuiItemHoveredDataBackup
LastItemId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 LastItemId;$/;"	m	struct:ImGuiItemHoveredDataBackup
LastItemId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 LastItemId;$/;"	m	struct:ImGuiWindowTempData
LastItemRect	vendor/imgui/imgui_internal.h	/^    ImRect                  LastItemRect;           \/\/ Interaction rect$/;"	m	struct:ImGuiWindowTempData
LastItemRect	vendor/imgui/imgui_internal.h	/^    ImRect                  LastItemRect;$/;"	m	struct:ImGuiItemHoveredDataBackup
LastItemStatusFlags	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags    LastItemStatusFlags;$/;"	m	struct:ImGuiItemHoveredDataBackup
LastItemStatusFlags	vendor/imgui/imgui_internal.h	/^    ImGuiItemStatusFlags    LastItemStatusFlags;$/;"	m	struct:ImGuiWindowTempData
LastTabItemIdx	vendor/imgui/imgui_internal.h	/^    short               LastTabItemIdx;         \/\/ For BeginTabItem()\/EndTabItem()$/;"	m	struct:ImGuiTabBar
LastValidMousePos	vendor/imgui/imgui_internal.h	/^    ImVec2                  LastValidMousePos;$/;"	m	struct:ImGuiContext
Layers	vendor/imgui/imgui_internal.h	/^    ImVector<ImDrawList*>   Layers[2];           \/\/ Global layers for: regular, tooltip$/;"	m	struct:ImDrawDataBuilder
LayoutType	vendor/imgui/imgui_internal.h	/^    ImGuiLayoutType         LayoutType;$/;"	m	struct:ImGuiWindowTempData
LineMaxY	vendor/imgui/imgui_internal.h	/^    float               LineMinY, LineMaxY;$/;"	m	struct:ImGuiColumns
LineMinY	vendor/imgui/imgui_internal.h	/^    float               LineMinY, LineMaxY;$/;"	m	struct:ImGuiColumns
LineOffsets	vendor/imgui/imgui_demo.cpp	/^    ImVector<int>       LineOffsets;        \/\/ Index to lines offset. We maintain this with AddLog() calls, allowing us to have a random access on lines$/;"	m	struct:ExampleAppLog	file:
ListBox	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, bool (*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)$/;"	f	class:ImGui
ListBox	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)$/;"	f	class:ImGui
ListBoxFooter	vendor/imgui/imgui_widgets.cpp	/^void ImGui::ListBoxFooter()$/;"	f	class:ImGui
ListBoxHeader	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)$/;"	f	class:ImGui
ListBoxHeader	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)$/;"	f	class:ImGui
LoadIniSettingsFromDisk	vendor/imgui/imgui.cpp	/^void ImGui::LoadIniSettingsFromDisk(const char* ini_filename)$/;"	f	class:ImGui
LoadIniSettingsFromMemory	vendor/imgui/imgui.cpp	/^void ImGui::LoadIniSettingsFromMemory(const char* ini_data, size_t ini_size)$/;"	f	class:ImGui
Locked	vendor/imgui/imgui.h	/^    bool                        Locked;             \/\/ Marked as Locked by ImGui::NewFrame() so attempt to modify the atlas will assert.$/;"	m	struct:ImFontAtlas
LogBegin	vendor/imgui/imgui.cpp	/^void ImGui::LogBegin(ImGuiLogType type, int auto_open_depth)$/;"	f	class:ImGui
LogBuffer	vendor/imgui/imgui_internal.h	/^    ImGuiTextBuffer         LogBuffer;                          \/\/ Accumulation buffer when log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.$/;"	m	struct:ImGuiContext
LogButtons	vendor/imgui/imgui.cpp	/^void ImGui::LogButtons()$/;"	f	class:ImGui
LogDepthRef	vendor/imgui/imgui_internal.h	/^    int                     LogDepthRef;$/;"	m	struct:ImGuiContext
LogDepthToExpand	vendor/imgui/imgui_internal.h	/^    int                     LogDepthToExpand;$/;"	m	struct:ImGuiContext
LogDepthToExpandDefault	vendor/imgui/imgui_internal.h	/^    int                     LogDepthToExpandDefault;            \/\/ Default\/stored value for LogDepthMaxExpand if not specified in the LogXXX function call.$/;"	m	struct:ImGuiContext
LogEnabled	vendor/imgui/imgui_internal.h	/^    bool                    LogEnabled;$/;"	m	struct:ImGuiContext
LogFile	vendor/imgui/imgui_internal.h	/^    FILE*                   LogFile;                            \/\/ If != NULL log to stdout\/ file$/;"	m	struct:ImGuiContext
LogFilename	vendor/imgui/imgui.h	/^    const char* LogFilename;                    \/\/ = "imgui_log.txt"\/\/ Path to .log file (default parameter to ImGui::LogToFile when no file is specified).$/;"	m	struct:ImGuiIO
LogFinish	vendor/imgui/imgui.cpp	/^void ImGui::LogFinish()$/;"	f	class:ImGui
LogLineFirstItem	vendor/imgui/imgui_internal.h	/^    bool                    LogLineFirstItem;$/;"	m	struct:ImGuiContext
LogLinePosY	vendor/imgui/imgui_internal.h	/^    float                   LogLinePosY;$/;"	m	struct:ImGuiContext
LogRenderedText	vendor/imgui/imgui.cpp	/^void ImGui::LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end)$/;"	f	class:ImGui
LogText	vendor/imgui/imgui.cpp	/^void ImGui::LogText(const char* fmt, ...)$/;"	f	class:ImGui
LogToBuffer	vendor/imgui/imgui.cpp	/^void ImGui::LogToBuffer(int auto_open_depth)$/;"	f	class:ImGui
LogToClipboard	vendor/imgui/imgui.cpp	/^void ImGui::LogToClipboard(int auto_open_depth)$/;"	f	class:ImGui
LogToFile	vendor/imgui/imgui.cpp	/^void ImGui::LogToFile(int auto_open_depth, const char* filename)$/;"	f	class:ImGui
LogToTTY	vendor/imgui/imgui.cpp	/^void ImGui::LogToTTY(int auto_open_depth)$/;"	f	class:ImGui
LogType	vendor/imgui/imgui_internal.h	/^    ImGuiLogType            LogType;$/;"	m	struct:ImGuiContext
LowerBound	vendor/imgui/imgui.cpp	/^static ImGuiStorage::ImGuiStoragePair* LowerBound(ImVector<ImGuiStorage::ImGuiStoragePair>& data, ImGuiID key)$/;"	f	file:
MAP_ANALOG	vendor/imgui/imgui_impl_glfw.cpp	280;"	d	file:
MAP_ANALOG	vendor/imgui/imgui_impl_glfw.cpp	301;"	d	file:
MAP_BUTTON	vendor/imgui/imgui_impl_glfw.cpp	279;"	d	file:
MAP_BUTTON	vendor/imgui/imgui_impl_glfw.cpp	300;"	d	file:
MallocWrapper	vendor/imgui/imgui.cpp	/^static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); IM_UNUSED(size); IM_ASSERT(0); return NULL; }$/;"	f	file:
MallocWrapper	vendor/imgui/imgui.cpp	/^static void*   MallocWrapper(size_t size, void* user_data)    { IM_UNUSED(user_data); return malloc(size); }$/;"	f	file:
Map	vendor/imgui/imgui_internal.h	/^    ImGuiStorage    Map;        \/\/ ID->Index$/;"	m	struct:ImPool
MarkIniSettingsDirty	vendor/imgui/imgui.cpp	/^void ImGui::MarkIniSettingsDirty()$/;"	f	class:ImGui
MarkIniSettingsDirty	vendor/imgui/imgui.cpp	/^void ImGui::MarkIniSettingsDirty(ImGuiWindow* window)$/;"	f	class:ImGui
MarkItemEdited	vendor/imgui/imgui.cpp	/^void ImGui::MarkItemEdited(ImGuiID id)$/;"	f	class:ImGui
Max	vendor/imgui/imgui_internal.h	/^    ImVec2      Max;    \/\/ Lower-right$/;"	m	struct:ImRect
MemAlloc	vendor/imgui/imgui.cpp	/^void* ImGui::MemAlloc(size_t size)$/;"	f	class:ImGui
MemFree	vendor/imgui/imgui.cpp	/^void ImGui::MemFree(void* ptr)$/;"	f	class:ImGui
MenuBarAppending	vendor/imgui/imgui_internal.h	/^    bool                    MenuBarAppending;       \/\/ FIXME: Remove this$/;"	m	struct:ImGuiWindowTempData
MenuBarHeight	vendor/imgui/imgui_internal.h	/^    float       MenuBarHeight() const       { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_MenuBar) ? DC.MenuBarOffset.y + CalcFontSize() + g.Style.FramePadding.y * 2.0f : 0.0f; }$/;"	f	struct:ImGuiWindow
MenuBarOffset	vendor/imgui/imgui_internal.h	/^    ImVec2                  MenuBarOffset;          \/\/ MenuBarOffset.x is sort of equivalent of a per-layer CursorPos.x, saved\/restored as we switch to the menu bar. The only situation when MenuBarOffset.y is > 0 if when (SafeAreaPadding.y > FramePadding.y), often used on TVs.$/;"	m	struct:ImGuiWindowTempData
MenuBarOffsetMinVal	vendor/imgui/imgui_internal.h	/^    ImVec2                      MenuBarOffsetMinVal;    \/\/ *Always on* This is not exposed publicly, so we don't clear it.$/;"	m	struct:ImGuiNextWindowData
MenuBarRect	vendor/imgui/imgui_internal.h	/^    ImRect      MenuBarRect() const         { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }$/;"	f	struct:ImGuiWindow
MenuColumns	vendor/imgui/imgui_internal.h	/^    ImGuiMenuColumns        MenuColumns;                        \/\/ Simplified columns storage for menu items$/;"	m	struct:ImGuiWindow
MenuItem	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled)$/;"	f	class:ImGui
MenuItem	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled)$/;"	f	class:ImGui
Merge	vendor/imgui/imgui_draw.cpp	/^void ImDrawListSplitter::Merge(ImDrawList* draw_list)$/;"	f	class:ImDrawListSplitter
MergeMode	vendor/imgui/imgui.h	/^    bool            MergeMode;              \/\/ false    \/\/ Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.$/;"	m	struct:ImFontConfig
MetricsActiveAllocations	vendor/imgui/imgui.h	/^    int         MetricsActiveAllocations;       \/\/ Number of active allocations, updated by MemAlloc\/MemFree based on current context. May be off if you have multiple imgui contexts.$/;"	m	struct:ImGuiIO
MetricsActiveWindows	vendor/imgui/imgui.h	/^    int         MetricsActiveWindows;           \/\/ Number of active windows$/;"	m	struct:ImGuiIO
MetricsRenderIndices	vendor/imgui/imgui.h	/^    int         MetricsRenderIndices;           \/\/ Indices output during last call to Render() = number of triangles * 3$/;"	m	struct:ImGuiIO
MetricsRenderVertices	vendor/imgui/imgui.h	/^    int         MetricsRenderVertices;          \/\/ Vertices output during last call to Render()$/;"	m	struct:ImGuiIO
MetricsRenderWindows	vendor/imgui/imgui.h	/^    int         MetricsRenderWindows;           \/\/ Number of visible windows$/;"	m	struct:ImGuiIO
MetricsTotalSurface	vendor/imgui/imgui.h	/^    int                         MetricsTotalSurface;\/\/ 4     \/\/ out \/\/            \/\/ Total surface in pixels to get an idea of the font rasterization\/texture cost (not exact, we approximate the cost of padding between glyphs)$/;"	m	struct:ImFont
Min	vendor/imgui/imgui_internal.h	/^    ImVec2      Min;    \/\/ Upper-left$/;"	m	struct:ImRect
MouseClicked	vendor/imgui/imgui.h	/^    bool        MouseClicked[5];                \/\/ Mouse button went from !Down to Down$/;"	m	struct:ImGuiIO
MouseClickedPos	vendor/imgui/imgui.h	/^    ImVec2      MouseClickedPos[5];             \/\/ Position at time of clicking$/;"	m	struct:ImGuiIO
MouseClickedTime	vendor/imgui/imgui.h	/^    double      MouseClickedTime[5];            \/\/ Time of last click (used to figure out double-click)$/;"	m	struct:ImGuiIO
MouseCursor	vendor/imgui/imgui_internal.h	/^    ImGuiMouseCursor        MouseCursor;$/;"	m	struct:ImGuiContext
MouseCursorScale	vendor/imgui/imgui.h	/^    float       MouseCursorScale;           \/\/ Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.$/;"	m	struct:ImGuiStyle
MouseDelta	vendor/imgui/imgui.h	/^    ImVec2      MouseDelta;                     \/\/ Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing\/reappearing mouse won't have a huge delta.$/;"	m	struct:ImGuiIO
MouseDoubleClickMaxDist	vendor/imgui/imgui.h	/^    float       MouseDoubleClickMaxDist;        \/\/ = 6.0f           \/\/ Distance threshold to stay in to validate a double-click, in pixels.$/;"	m	struct:ImGuiIO
MouseDoubleClickTime	vendor/imgui/imgui.h	/^    float       MouseDoubleClickTime;           \/\/ = 0.30f          \/\/ Time for a double-click, in seconds.$/;"	m	struct:ImGuiIO
MouseDoubleClicked	vendor/imgui/imgui.h	/^    bool        MouseDoubleClicked[5];          \/\/ Has mouse button been double-clicked?$/;"	m	struct:ImGuiIO
MouseDown	vendor/imgui/imgui.h	/^    bool        MouseDown[5];                   \/\/ Mouse buttons: 0=left, 1=right, 2=middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.$/;"	m	struct:ImGuiIO
MouseDownDuration	vendor/imgui/imgui.h	/^    float       MouseDownDuration[5];           \/\/ Duration the mouse button has been down (0.0f == just clicked)$/;"	m	struct:ImGuiIO
MouseDownDurationPrev	vendor/imgui/imgui.h	/^    float       MouseDownDurationPrev[5];       \/\/ Previous time the mouse button has been down$/;"	m	struct:ImGuiIO
MouseDownOwned	vendor/imgui/imgui.h	/^    bool        MouseDownOwned[5];              \/\/ Track if button was clicked inside a dear imgui window. We don't request mouse capture from the application if click started outside ImGui bounds.$/;"	m	struct:ImGuiIO
MouseDownWasDoubleClick	vendor/imgui/imgui.h	/^    bool        MouseDownWasDoubleClick[5];     \/\/ Track if button down was a double-click$/;"	m	struct:ImGuiIO
MouseDragMaxDistanceAbs	vendor/imgui/imgui.h	/^    ImVec2      MouseDragMaxDistanceAbs[5];     \/\/ Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point$/;"	m	struct:ImGuiIO
MouseDragMaxDistanceSqr	vendor/imgui/imgui.h	/^    float       MouseDragMaxDistanceSqr[5];     \/\/ Squared maximum distance of how much mouse has traveled from the clicking point$/;"	m	struct:ImGuiIO
MouseDragThreshold	vendor/imgui/imgui.h	/^    float       MouseDragThreshold;             \/\/ = 6.0f           \/\/ Distance threshold before considering we are dragging.$/;"	m	struct:ImGuiIO
MouseDrawCursor	vendor/imgui/imgui.h	/^    bool        MouseDrawCursor;                \/\/ = false          \/\/ Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor). Cannot be easily renamed to 'io.ConfigXXX' because this is frequently used by back-end implementations.$/;"	m	struct:ImGuiIO
MousePos	vendor/imgui/imgui.h	/^    ImVec2      MousePos;                       \/\/ Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)$/;"	m	struct:ImGuiIO
MousePosPrev	vendor/imgui/imgui.h	/^    ImVec2      MousePosPrev;                   \/\/ Previous mouse position (note that MouseDelta is not necessary == MousePos-MousePosPrev, in case either position is invalid)$/;"	m	struct:ImGuiIO
MouseReleased	vendor/imgui/imgui.h	/^    bool        MouseReleased[5];               \/\/ Mouse button went from Down to !Down$/;"	m	struct:ImGuiIO
MouseWheel	vendor/imgui/imgui.h	/^    float       MouseWheel;                     \/\/ Mouse wheel Vertical: 1 unit scrolls about 5 lines text.$/;"	m	struct:ImGuiIO
MouseWheelH	vendor/imgui/imgui.h	/^    float       MouseWheelH;                    \/\/ Mouse wheel Horizontal. Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.$/;"	m	struct:ImGuiIO
MoveId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 MoveId;                             \/\/ == window->GetID("#MOVE")$/;"	m	struct:ImGuiWindow
MovingWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            MovingWindow;                       \/\/ Track the window we clicked on (in order to preserve focus). The actually window that is moved is generally MovingWindow->RootWindow.$/;"	m	struct:ImGuiContext
MultiSelectScopeId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 MultiSelectScopeId;$/;"	m	struct:ImGuiContext
MyDocument	vendor/imgui/imgui_demo.cpp	/^    MyDocument(const char* name, bool open = true, const ImVec4& color = ImVec4(1.0f,1.0f,1.0f,1.0f))$/;"	f	struct:MyDocument
MyDocument	vendor/imgui/imgui_demo.cpp	/^struct MyDocument$/;"	s	file:
NAV_MAP_KEY	vendor/imgui/imgui.cpp	8196;"	d	file:
NAV_MAP_KEY	vendor/imgui/imgui.cpp	8211;"	d	file:
NAV_WINDOWING_HIGHLIGHT_DELAY	vendor/imgui/imgui.cpp	/^static const float NAV_WINDOWING_HIGHLIGHT_DELAY            = 0.20f;    \/\/ Time before the highlight and screen dimming starts fading in$/;"	v	file:
NAV_WINDOWING_LIST_APPEAR_DELAY	vendor/imgui/imgui.cpp	/^static const float NAV_WINDOWING_LIST_APPEAR_DELAY          = 0.15f;    \/\/ Time before the window list starts to appear$/;"	v	file:
Name	vendor/imgui/imgui.h	/^    char            Name[40];               \/\/ Name (strictly to ease debugging)$/;"	m	struct:ImFontConfig
Name	vendor/imgui/imgui_demo.cpp	/^    const char* Name;           \/\/ Document title$/;"	m	struct:MyDocument	file:
Name	vendor/imgui/imgui_internal.h	/^    char*                   Name;$/;"	m	struct:ImGuiWindow
Name	vendor/imgui/imgui_internal.h	/^    char*       Name;$/;"	m	struct:ImGuiWindowSettings
NameBufLen	vendor/imgui/imgui_internal.h	/^    int                     NameBufLen;                         \/\/ Size of buffer storing Name. May be larger than strlen(Name)!$/;"	m	struct:ImGuiWindow
NameOffset	vendor/imgui/imgui_internal.h	/^    int                 NameOffset;             \/\/ When Window==NULL, offset to name within parent ImGuiTabBar::TabsNames$/;"	m	struct:ImGuiTabItem
NavActivateDownId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavActivateDownId;                  \/\/ ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0$/;"	m	struct:ImGuiContext
NavActivateId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavActivateId;                      \/\/ ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()$/;"	m	struct:ImGuiContext
NavActivatePressedId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavActivatePressedId;               \/\/ ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0$/;"	m	struct:ImGuiContext
NavActive	vendor/imgui/imgui.h	/^    bool        NavActive;                      \/\/ Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.$/;"	m	struct:ImGuiIO
NavAnyRequest	vendor/imgui/imgui_internal.h	/^    bool                    NavAnyRequest;                      \/\/ ~~ NavMoveRequest || NavInitRequest$/;"	m	struct:ImGuiContext
NavCalcPreferredRefPos	vendor/imgui/imgui.cpp	/^static ImVec2 ImGui::NavCalcPreferredRefPos()$/;"	f	class:ImGui
NavClampRectToVisibleAreaForMoveDir	vendor/imgui/imgui.cpp	/^static void inline NavClampRectToVisibleAreaForMoveDir(ImGuiDir move_dir, ImRect& r, const ImRect& clip_rect)$/;"	f	file:
NavDisableHighlight	vendor/imgui/imgui_internal.h	/^    bool                    NavDisableHighlight;                \/\/ When user starts using mouse, we hide gamepad\/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)$/;"	m	struct:ImGuiContext
NavDisableMouseHover	vendor/imgui/imgui_internal.h	/^    bool                    NavDisableMouseHover;               \/\/ When user starts using gamepad\/keyboard, we hide mouse hovering highlight until mouse is touched again.$/;"	m	struct:ImGuiContext
NavHasScroll	vendor/imgui/imgui_internal.h	/^    bool                    NavHasScroll;           \/\/ Set when scrolling can be used (ScrollMax > 0.0f)$/;"	m	struct:ImGuiWindowTempData
NavHideHighlightOneFrame	vendor/imgui/imgui_internal.h	/^    bool                    NavHideHighlightOneFrame;$/;"	m	struct:ImGuiWindowTempData
NavId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavId;                              \/\/ Focused item for navigation$/;"	m	struct:ImGuiContext
NavIdIsAlive	vendor/imgui/imgui_internal.h	/^    bool                    NavIdIsAlive;                       \/\/ Nav widget has been seen this frame ~~ NavRefRectRel is valid$/;"	m	struct:ImGuiContext
NavIdTabCounter	vendor/imgui/imgui_internal.h	/^    int                     NavIdTabCounter;                    \/\/ == NavWindow->DC.FocusIdxTabCounter at time of NavId processing$/;"	m	struct:ImGuiContext
NavInitRequest	vendor/imgui/imgui_internal.h	/^    bool                    NavInitRequest;                     \/\/ Init request for appearing window to select first item$/;"	m	struct:ImGuiContext
NavInitRequestFromMove	vendor/imgui/imgui_internal.h	/^    bool                    NavInitRequestFromMove;$/;"	m	struct:ImGuiContext
NavInitResultId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavInitResultId;$/;"	m	struct:ImGuiContext
NavInitResultRectRel	vendor/imgui/imgui_internal.h	/^    ImRect                  NavInitResultRectRel;$/;"	m	struct:ImGuiContext
NavInitWindow	vendor/imgui/imgui.cpp	/^void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)$/;"	f	class:ImGui
NavInputId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavInputId;                         \/\/ ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0$/;"	m	struct:ImGuiContext
NavInputSource	vendor/imgui/imgui_internal.h	/^    ImGuiInputSource        NavInputSource;                     \/\/ Keyboard or Gamepad mode? THIS WILL ONLY BE None or NavGamepad or NavKeyboard.$/;"	m	struct:ImGuiContext
NavInputs	vendor/imgui/imgui.h	/^    float       NavInputs[ImGuiNavInput_COUNT]; \/\/ Gamepad inputs. Cleared back to zero by EndFrame(). Keyboard keys will be auto-mapped and be written here by NewFrame().$/;"	m	struct:ImGuiIO
NavInputsDownDuration	vendor/imgui/imgui.h	/^    float       NavInputsDownDuration[ImGuiNavInput_COUNT];$/;"	m	struct:ImGuiIO
NavInputsDownDurationPrev	vendor/imgui/imgui.h	/^    float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];$/;"	m	struct:ImGuiIO
NavJustMovedToId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavJustMovedToId;                   \/\/ Just navigated to this id (result of a successfully MoveRequest).$/;"	m	struct:ImGuiContext
NavJustMovedToMultiSelectScopeId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavJustMovedToMultiSelectScopeId;   \/\/ Just navigated to this select scope id (result of a successfully MoveRequest).$/;"	m	struct:ImGuiContext
NavJustTabbedId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavJustTabbedId;                    \/\/ Just tabbed to this id.$/;"	m	struct:ImGuiContext
NavLastChildNavWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            NavLastChildNavWindow;              \/\/ When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)$/;"	m	struct:ImGuiWindow
NavLastIds	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavLastIds[ImGuiNavLayer_COUNT];    \/\/ Last known NavId for this window, per layer (0\/1)$/;"	m	struct:ImGuiWindow
NavLayer	vendor/imgui/imgui_internal.h	/^    ImGuiNavLayer           NavLayer;                           \/\/ Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu\/title bar, may expose layers later.$/;"	m	struct:ImGuiContext
NavLayerActiveMask	vendor/imgui/imgui_internal.h	/^    int                     NavLayerActiveMask;     \/\/ Which layer have been written to (result from previous frame)$/;"	m	struct:ImGuiWindowTempData
NavLayerActiveMaskNext	vendor/imgui/imgui_internal.h	/^    int                     NavLayerActiveMaskNext; \/\/ Which layer have been written to (buffer for current frame)$/;"	m	struct:ImGuiWindowTempData
NavLayerCurrent	vendor/imgui/imgui_internal.h	/^    ImGuiNavLayer           NavLayerCurrent;        \/\/ Current layer, 0..31 (we currently only use 0..1)$/;"	m	struct:ImGuiWindowTempData
NavLayerCurrentMask	vendor/imgui/imgui_internal.h	/^    int                     NavLayerCurrentMask;    \/\/ = (1 << NavLayerCurrent) used by ItemAdd prior to clipping.$/;"	m	struct:ImGuiWindowTempData
NavMousePosDirty	vendor/imgui/imgui_internal.h	/^    bool                    NavMousePosDirty;                   \/\/ When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)$/;"	m	struct:ImGuiContext
NavMoveClipDir	vendor/imgui/imgui_internal.h	/^    ImGuiDir                NavMoveClipDir;$/;"	m	struct:ImGuiContext
NavMoveDir	vendor/imgui/imgui_internal.h	/^    ImGuiDir                NavMoveDir, NavMoveDirLast;         \/\/ Direction of the move request (left\/right\/up\/down), direction of the previous move request$/;"	m	struct:ImGuiContext
NavMoveDirLast	vendor/imgui/imgui_internal.h	/^    ImGuiDir                NavMoveDir, NavMoveDirLast;         \/\/ Direction of the move request (left\/right\/up\/down), direction of the previous move request$/;"	m	struct:ImGuiContext
NavMoveFromClampedRefRect	vendor/imgui/imgui_internal.h	/^    bool                    NavMoveFromClampedRefRect;          \/\/ Set by manual scrolling, if we scroll to a point where NavId isn't visible we reset navigation from visible items$/;"	m	struct:ImGuiContext
NavMoveRequest	vendor/imgui/imgui_internal.h	/^    bool                    NavMoveRequest;                     \/\/ Move request for this frame$/;"	m	struct:ImGuiContext
NavMoveRequestButNoResultYet	vendor/imgui/imgui.cpp	/^bool ImGui::NavMoveRequestButNoResultYet()$/;"	f	class:ImGui
NavMoveRequestCancel	vendor/imgui/imgui.cpp	/^void ImGui::NavMoveRequestCancel()$/;"	f	class:ImGui
NavMoveRequestFlags	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveFlags       NavMoveRequestFlags;$/;"	m	struct:ImGuiContext
NavMoveRequestForward	vendor/imgui/imgui.cpp	/^void ImGui::NavMoveRequestForward(ImGuiDir move_dir, ImGuiDir clip_dir, const ImRect& bb_rel, ImGuiNavMoveFlags move_flags)$/;"	f	class:ImGui
NavMoveRequestForward	vendor/imgui/imgui_internal.h	/^    ImGuiNavForward         NavMoveRequestForward;              \/\/ None \/ ForwardQueued \/ ForwardActive (this is used to navigate sibling parent menus from a child menu)$/;"	m	struct:ImGuiContext
NavMoveRequestTryWrapping	vendor/imgui/imgui.cpp	/^void ImGui::NavMoveRequestTryWrapping(ImGuiWindow* window, ImGuiNavMoveFlags move_flags)$/;"	f	class:ImGui
NavMoveResultLocal	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveResult      NavMoveResultLocal;                 \/\/ Best move request candidate within NavWindow$/;"	m	struct:ImGuiContext
NavMoveResultLocalVisibleSet	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveResult      NavMoveResultLocalVisibleSet;       \/\/ Best move request candidate within NavWindow that are mostly visible (when using ImGuiNavMoveFlags_AlsoScoreVisibleSet flag)$/;"	m	struct:ImGuiContext
NavMoveResultOther	vendor/imgui/imgui_internal.h	/^    ImGuiNavMoveResult      NavMoveResultOther;                 \/\/ Best move request candidate within NavWindow's flattened hierarchy (when using ImGuiWindowFlags_NavFlattened flag)$/;"	m	struct:ImGuiContext
NavNextActivateId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 NavNextActivateId;                  \/\/ Set by ActivateItem(), queued until next frame.$/;"	m	struct:ImGuiContext
NavProcessItem	vendor/imgui/imgui.cpp	/^static void ImGui::NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id)$/;"	f	class:ImGui
NavRectRel	vendor/imgui/imgui_internal.h	/^    ImRect                  NavRectRel[ImGuiNavLayer_COUNT];    \/\/ Reference rectangle, in window relative space$/;"	m	struct:ImGuiWindow
NavRestoreLastChildNavWindow	vendor/imgui/imgui.cpp	/^static ImGuiWindow* ImGui::NavRestoreLastChildNavWindow(ImGuiWindow* window)$/;"	f	class:ImGui
NavRestoreLayer	vendor/imgui/imgui.cpp	/^static void NavRestoreLayer(ImGuiNavLayer layer)$/;"	f	file:
NavSaveLastChildNavWindowIntoParent	vendor/imgui/imgui.cpp	/^static void ImGui::NavSaveLastChildNavWindowIntoParent(ImGuiWindow* nav_window)$/;"	f	class:ImGui
NavScoreItem	vendor/imgui/imgui.cpp	/^static bool NavScoreItem(ImGuiNavMoveResult* result, ImRect cand)$/;"	f	file:
NavScoreItemDistInterval	vendor/imgui/imgui.cpp	/^static float inline NavScoreItemDistInterval(float a0, float a1, float b0, float b1)$/;"	f	file:
NavScoringCount	vendor/imgui/imgui_internal.h	/^    int                     NavScoringCount;                    \/\/ Metrics for debugging$/;"	m	struct:ImGuiContext
NavScoringRectScreen	vendor/imgui/imgui_internal.h	/^    ImRect                  NavScoringRectScreen;               \/\/ Rectangle used for scoring, in screen space. Based of window->DC.NavRefRectRel[], modified for directional navigation scoring.$/;"	m	struct:ImGuiContext
NavUpdate	vendor/imgui/imgui.cpp	/^static void ImGui::NavUpdate()$/;"	f	class:ImGui
NavUpdateAnyRequestFlag	vendor/imgui/imgui.cpp	/^static inline void ImGui::NavUpdateAnyRequestFlag()$/;"	f	class:ImGui
NavUpdateMoveResult	vendor/imgui/imgui.cpp	/^static void ImGui::NavUpdateMoveResult()$/;"	f	class:ImGui
NavUpdatePageUpPageDown	vendor/imgui/imgui.cpp	/^static float ImGui::NavUpdatePageUpPageDown(int allowed_dir_flags)$/;"	f	class:ImGui
NavUpdateWindowing	vendor/imgui/imgui.cpp	/^static void ImGui::NavUpdateWindowing()$/;"	f	class:ImGui
NavUpdateWindowingHighlightWindow	vendor/imgui/imgui.cpp	/^static void NavUpdateWindowingHighlightWindow(int focus_change_dir)$/;"	f	file:
NavUpdateWindowingList	vendor/imgui/imgui.cpp	/^void ImGui::NavUpdateWindowingList()$/;"	f	class:ImGui
NavVisible	vendor/imgui/imgui.h	/^    bool        NavVisible;                     \/\/ Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).$/;"	m	struct:ImGuiIO
NavWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            NavWindow;                          \/\/ Focused window for navigation. Could be called 'FocusWindow'$/;"	m	struct:ImGuiContext
NavWindowingHighlightAlpha	vendor/imgui/imgui_internal.h	/^    float                   NavWindowingHighlightAlpha;$/;"	m	struct:ImGuiContext
NavWindowingList	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            NavWindowingList;$/;"	m	struct:ImGuiContext
NavWindowingTarget	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            NavWindowingTarget;                 \/\/ When selecting a window (holding Menu+FocusPrev\/Next, or equivalent of CTRL-TAB) this window is temporarily displayed top-most.$/;"	m	struct:ImGuiContext
NavWindowingTargetAnim	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            NavWindowingTargetAnim;             \/\/ Record of last valid NavWindowingTarget until DimBgRatio and NavWindowingHighlightAlpha becomes 0.0f$/;"	m	struct:ImGuiContext
NavWindowingTimer	vendor/imgui/imgui_internal.h	/^    float                   NavWindowingTimer;$/;"	m	struct:ImGuiContext
NavWindowingToggleLayer	vendor/imgui/imgui_internal.h	/^    bool                    NavWindowingToggleLayer;$/;"	m	struct:ImGuiContext
NewFrame	vendor/imgui/imgui.cpp	/^void ImGui::NewFrame()$/;"	f	class:ImGui
NewFrameSanityChecks	vendor/imgui/imgui.cpp	/^static void NewFrameSanityChecks()$/;"	f	file:
NewLine	vendor/imgui/imgui_widgets.cpp	/^void ImGui::NewLine()$/;"	f	class:ImGui
NextColumn	vendor/imgui/imgui_widgets.cpp	/^void ImGui::NextColumn()$/;"	f	class:ImGui
NextItemData	vendor/imgui/imgui_internal.h	/^    ImGuiNextItemData       NextItemData;                       \/\/ Storage for SetNextItem** functions$/;"	m	struct:ImGuiContext
NextSelectedTabId	vendor/imgui/imgui_internal.h	/^    ImGuiID             NextSelectedTabId;$/;"	m	struct:ImGuiTabBar
NextWidth	vendor/imgui/imgui_internal.h	/^    float       Width, NextWidth;$/;"	m	struct:ImGuiMenuColumns
NextWidths	vendor/imgui/imgui_internal.h	/^    float       Pos[3], NextWidths[3];$/;"	m	struct:ImGuiMenuColumns
NextWindowData	vendor/imgui/imgui_internal.h	/^    ImGuiNextWindowData     NextWindowData;                     \/\/ Storage for SetNextWindow** functions$/;"	m	struct:ImGuiContext
NotifyOfDocumentsClosedElsewhere	vendor/imgui/imgui_demo.cpp	/^static void NotifyOfDocumentsClosedElsewhere(ExampleAppDocuments& app)$/;"	f	file:
OffMaxX	vendor/imgui/imgui_internal.h	/^    float               OffMinX, OffMaxX;       \/\/ Offsets from HostWorkRect.Min.x$/;"	m	struct:ImGuiColumns
OffMinX	vendor/imgui/imgui_internal.h	/^    float               OffMinX, OffMaxX;       \/\/ Offsets from HostWorkRect.Min.x$/;"	m	struct:ImGuiColumns
Offset	vendor/imgui/imgui.cpp	/^    ImU32           Offset;$/;"	m	struct:ImGuiStyleVarInfo	file:
Offset	vendor/imgui/imgui_internal.h	/^    float               Offset;                 \/\/ Position relative to beginning of tab$/;"	m	struct:ImGuiTabItem
OffsetMax	vendor/imgui/imgui_internal.h	/^    float               OffsetMax;              \/\/ Distance from BarRect.Min.x, locked during layout$/;"	m	struct:ImGuiTabBar
OffsetNextTab	vendor/imgui/imgui_internal.h	/^    float               OffsetNextTab;          \/\/ Distance from BarRect.Min.x, incremented with each BeginTabItem() call, not used if ImGuiTabBarFlags_Reorderable if set.$/;"	m	struct:ImGuiTabBar
OffsetNorm	vendor/imgui/imgui_internal.h	/^    float               OffsetNorm;         \/\/ Column start offset, normalized 0.0 (far left) -> 1.0 (far right)$/;"	m	struct:ImGuiColumnData
OffsetNormBeforeResize	vendor/imgui/imgui_internal.h	/^    float               OffsetNormBeforeResize;$/;"	m	struct:ImGuiColumnData
OnKeyPressed	vendor/imgui/imgui_widgets.cpp	/^void ImGuiInputTextState::OnKeyPressed(int key)$/;"	f	class:ImGuiInputTextState
Open	vendor/imgui/imgui_demo.cpp	/^    bool        Open;           \/\/ Set when the document is open (in this demo, we keep an array of all available documents to simplify the demo)$/;"	m	struct:MyDocument	file:
OpenCond	vendor/imgui/imgui_internal.h	/^    ImGuiCond                   OpenCond;$/;"	m	struct:ImGuiNextItemData
OpenFrameCount	vendor/imgui/imgui_internal.h	/^    int                 OpenFrameCount; \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupData
OpenMousePos	vendor/imgui/imgui_internal.h	/^    ImVec2              OpenMousePos;   \/\/ Set on OpenPopup(), copy of mouse position at the time of opening popup$/;"	m	struct:ImGuiPopupData
OpenParentId	vendor/imgui/imgui_internal.h	/^    ImGuiID             OpenParentId;   \/\/ Set on OpenPopup(), we need this to differentiate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)$/;"	m	struct:ImGuiPopupData
OpenPopup	vendor/imgui/imgui.cpp	/^void ImGui::OpenPopup(const char* str_id)$/;"	f	class:ImGui
OpenPopupEx	vendor/imgui/imgui.cpp	/^void ImGui::OpenPopupEx(ImGuiID id)$/;"	f	class:ImGui
OpenPopupOnItemClick	vendor/imgui/imgui.cpp	/^bool ImGui::OpenPopupOnItemClick(const char* str_id, int mouse_button)$/;"	f	class:ImGui
OpenPopupPos	vendor/imgui/imgui_internal.h	/^    ImVec2              OpenPopupPos;   \/\/ Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)$/;"	m	struct:ImGuiPopupData
OpenPopupStack	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiPopupData>OpenPopupStack;                     \/\/ Which popups are open (persistent)$/;"	m	struct:ImGuiContext
OpenPrev	vendor/imgui/imgui_demo.cpp	/^    bool        OpenPrev;       \/\/ Copy of Open from last update.$/;"	m	struct:MyDocument	file:
OpenVal	vendor/imgui/imgui_internal.h	/^    bool                        OpenVal;        \/\/ Set by SetNextItemOpen() function.$/;"	m	struct:ImGuiNextItemData
OuterRectClipped	vendor/imgui/imgui_internal.h	/^    ImRect                  OuterRectClipped;                   \/\/ == Window->Rect() just after setup in Begin(). == window->Rect() for root window.$/;"	m	struct:ImGuiWindow
Overlaps	vendor/imgui/imgui_internal.h	/^    bool        Overlaps(const ImRect& r) const     { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }$/;"	f	struct:ImRect
OversampleH	vendor/imgui/imgui.h	/^    int             OversampleH;            \/\/ 3        \/\/ Rasterize at higher quality for sub-pixel positioning. Read https:\/\/github.com\/nothings\/stb\/blob\/master\/tests\/oversample\/README.md for details.$/;"	m	struct:ImFontConfig
OversampleV	vendor/imgui/imgui.h	/^    int             OversampleV;            \/\/ 1        \/\/ Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.$/;"	m	struct:ImFontConfig
PackRange	vendor/imgui/imgui_draw.cpp	/^    stbtt_pack_range    PackRange;          \/\/ Hold the list of codepoints to pack (essentially points to Codepoints.Data)$/;"	m	struct:ImFontBuildSrcData	file:
PackedChars	vendor/imgui/imgui_draw.cpp	/^    stbtt_packedchar*   PackedChars;        \/\/ Output glyphs$/;"	m	struct:ImFontBuildSrcData	file:
Painter	Painter/Painter.h	/^class Painter {$/;"	c
ParentLayoutType	vendor/imgui/imgui_internal.h	/^    ImGuiLayoutType         ParentLayoutType;       \/\/ Layout type of parent window at the time of Begin()$/;"	m	struct:ImGuiWindowTempData
ParentWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            ParentWindow;                       \/\/ If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.$/;"	m	struct:ImGuiWindow
ParseShader	Shader/Shader.cpp	/^ShaderProgramSource Shader::ParseShader(){$/;"	f	class:Shader
PassFilter	vendor/imgui/imgui.cpp	/^bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const$/;"	f	class:ImGuiTextFilter
PatchFormatStringFloatToInt	vendor/imgui/imgui_widgets.cpp	/^static const char* PatchFormatStringFloatToInt(const char* fmt)$/;"	f	file:
PathArcTo	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments)$/;"	f	class:ImDrawList
PathArcToFast	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)$/;"	f	class:ImDrawList
PathBezierCurveTo	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)$/;"	f	class:ImDrawList
PathBezierToCasteljau	vendor/imgui/imgui_draw.cpp	/^static void PathBezierToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)$/;"	f	file:
PathClear	vendor/imgui/imgui.h	/^    inline    void  PathClear()                                                 { _Path.Size = 0; }$/;"	f	struct:ImDrawList
PathFillConvex	vendor/imgui/imgui.h	/^    inline    void  PathFillConvex(ImU32 col)                                   { AddConvexPolyFilled(_Path.Data, _Path.Size, col); _Path.Size = 0; }  \/\/ Note: Anti-aliased filling requires points to be in clockwise order.$/;"	f	struct:ImDrawList
PathLineTo	vendor/imgui/imgui.h	/^    inline    void  PathLineTo(const ImVec2& pos)                               { _Path.push_back(pos); }$/;"	f	struct:ImDrawList
PathLineToMergeDuplicate	vendor/imgui/imgui.h	/^    inline    void  PathLineToMergeDuplicate(const ImVec2& pos)                 { if (_Path.Size == 0 || memcmp(&_Path.Data[_Path.Size-1], &pos, 8) != 0) _Path.push_back(pos); }$/;"	f	struct:ImDrawList
PathRect	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, ImDrawCornerFlags rounding_corners)$/;"	f	class:ImDrawList
PathStroke	vendor/imgui/imgui.h	/^    inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f)  { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); _Path.Size = 0; }$/;"	f	struct:ImDrawList
PixelSnapH	vendor/imgui/imgui.h	/^    bool            PixelSnapH;             \/\/ false    \/\/ Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH\/V to 1.$/;"	m	struct:ImFontConfig
PlatformImeLastPos	vendor/imgui/imgui_internal.h	/^    ImVec2                  PlatformImeLastPos;$/;"	m	struct:ImGuiContext
PlatformImePos	vendor/imgui/imgui_internal.h	/^    ImVec2                  PlatformImePos;                     \/\/ Cursor position request & last passed to the OS Input Method Editor$/;"	m	struct:ImGuiContext
PlotEx	vendor/imgui/imgui_widgets.cpp	/^void ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 frame_size)$/;"	f	class:ImGui
PlotHistogram	vendor/imgui/imgui_widgets.cpp	/^void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui
PlotHistogram	vendor/imgui/imgui_widgets.cpp	/^void ImGui::PlotHistogram(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui
PlotLines	vendor/imgui/imgui_widgets.cpp	/^void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)$/;"	f	class:ImGui
PlotLines	vendor/imgui/imgui_widgets.cpp	/^void ImGui::PlotLines(const char* label, float (*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)$/;"	f	class:ImGui
Plot_ArrayGetter	vendor/imgui/imgui_widgets.cpp	/^static float Plot_ArrayGetter(void* data, int idx)$/;"	f	file:
PopAllowKeyboardFocus	vendor/imgui/imgui.cpp	/^void ImGui::PopAllowKeyboardFocus()$/;"	f	class:ImGui
PopButtonRepeat	vendor/imgui/imgui.cpp	/^void ImGui::PopButtonRepeat()$/;"	f	class:ImGui
PopClipRect	vendor/imgui/imgui.cpp	/^void ImGui::PopClipRect()$/;"	f	class:ImGui
PopClipRect	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PopClipRect()$/;"	f	class:ImDrawList
PopColumnsBackground	vendor/imgui/imgui_widgets.cpp	/^void ImGui::PopColumnsBackground()$/;"	f	class:ImGui
PopFont	vendor/imgui/imgui.cpp	/^void  ImGui::PopFont()$/;"	f	class:ImGui
PopID	vendor/imgui/imgui.cpp	/^void ImGui::PopID()$/;"	f	class:ImGui
PopItemFlag	vendor/imgui/imgui.cpp	/^void ImGui::PopItemFlag()$/;"	f	class:ImGui
PopItemWidth	vendor/imgui/imgui.cpp	/^void ImGui::PopItemWidth()$/;"	f	class:ImGui
PopStyleColor	vendor/imgui/imgui.cpp	/^void ImGui::PopStyleColor(int count)$/;"	f	class:ImGui
PopStyleVar	vendor/imgui/imgui.cpp	/^void ImGui::PopStyleVar(int count)$/;"	f	class:ImGui
PopTextWrapPos	vendor/imgui/imgui.cpp	/^void ImGui::PopTextWrapPos()$/;"	f	class:ImGui
PopTextureID	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PopTextureID()$/;"	f	class:ImDrawList
PopupBorderSize	vendor/imgui/imgui.h	/^    float       PopupBorderSize;            \/\/ Thickness of border around popup\/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU\/GPU costly).$/;"	m	struct:ImGuiStyle
PopupId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 PopupId;                            \/\/ ID in the popup stack when this window is used as a popup\/menu (because we use generic Name\/ID for recycling)$/;"	m	struct:ImGuiWindow
PopupId	vendor/imgui/imgui_internal.h	/^    ImGuiID             PopupId;        \/\/ Set on OpenPopup()$/;"	m	struct:ImGuiPopupData
PopupRounding	vendor/imgui/imgui.h	/^    float       PopupRounding;              \/\/ Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)$/;"	m	struct:ImGuiStyle
Pos	vendor/imgui/imgui.h	/^    ImVec2  Pos;            \/\/ Read-only.   Window position, for reference.$/;"	m	struct:ImGuiSizeCallbackData
Pos	vendor/imgui/imgui_internal.h	/^    ImVec2                  Pos;                                \/\/ Position (always rounded-up to nearest pixel)$/;"	m	struct:ImGuiWindow
Pos	vendor/imgui/imgui_internal.h	/^    ImVec2      Pos;$/;"	m	struct:ImGuiWindowSettings
Pos	vendor/imgui/imgui_internal.h	/^    float       Pos[3], NextWidths[3];$/;"	m	struct:ImGuiMenuColumns
PosCond	vendor/imgui/imgui_internal.h	/^    ImGuiCond                   PosCond;$/;"	m	struct:ImGuiNextWindowData
PosPivotVal	vendor/imgui/imgui_internal.h	/^    ImVec2                      PosPivotVal;$/;"	m	struct:ImGuiNextWindowData
PosVal	vendor/imgui/imgui_internal.h	/^    ImVec2                      PosVal;$/;"	m	struct:ImGuiNextWindowData
PrevFrameVisible	vendor/imgui/imgui_internal.h	/^    int                 PrevFrameVisible;$/;"	m	struct:ImGuiTabBar
PrevLineSize	vendor/imgui/imgui_internal.h	/^    ImVec2                  PrevLineSize;$/;"	m	struct:ImGuiWindowTempData
PrevLineTextBaseOffset	vendor/imgui/imgui_internal.h	/^    float                   PrevLineTextBaseOffset;$/;"	m	struct:ImGuiWindowTempData
Preview	vendor/imgui/imgui.h	/^    bool            Preview;            \/\/ Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)$/;"	m	struct:ImGuiPayload
PrimQuadUV	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)$/;"	f	class:ImDrawList
PrimRect	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)$/;"	f	class:ImDrawList
PrimRectUV	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)$/;"	f	class:ImDrawList
PrimReserve	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PrimReserve(int idx_count, int vtx_count)$/;"	f	class:ImDrawList
PrimVtx	vendor/imgui/imgui.h	/^    inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col)     { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }$/;"	f	struct:ImDrawList
PrimWriteIdx	vendor/imgui/imgui.h	/^    inline    void  PrimWriteIdx(ImDrawIdx idx)                                 { *_IdxWritePtr = idx; _IdxWritePtr++; }$/;"	f	struct:ImDrawList
PrimWriteVtx	vendor/imgui/imgui.h	/^    inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col){ _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }$/;"	f	struct:ImDrawList
PrintFmt	vendor/imgui/imgui_internal.h	/^    const char* PrintFmt;       \/\/ Default printf format for the type$/;"	m	struct:ImGuiDataTypeInfo
PrivateClipboard	vendor/imgui/imgui_internal.h	/^    ImVector<char>          PrivateClipboard;                   \/\/ If no custom clipboard handler is defined$/;"	m	struct:ImGuiContext
ProgressBar	vendor/imgui/imgui_widgets.cpp	/^void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)$/;"	f	class:ImGui
Ptr	vendor/imgui/imgui_internal.h	/^    void*           Ptr;                \/\/ Either field can be set, not both. e.g. Dock node tab bars are loose while BeginTabBar() ones are in a pool.$/;"	m	struct:ImGuiPtrOrIndex
Push	VertexBufferLayout/VertexBufferLayout.cpp	/^void VertexBufferLayout::Push(unsigned int type, unsigned int count){$/;"	f	class:VertexBufferLayout
PushAllowKeyboardFocus	vendor/imgui/imgui.cpp	/^void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)$/;"	f	class:ImGui
PushButtonRepeat	vendor/imgui/imgui.cpp	/^void ImGui::PushButtonRepeat(bool repeat)$/;"	f	class:ImGui
PushClipRect	vendor/imgui/imgui.cpp	/^void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)$/;"	f	class:ImGui
PushClipRect	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)$/;"	f	class:ImDrawList
PushClipRectFullScreen	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PushClipRectFullScreen()$/;"	f	class:ImDrawList
PushColumnClipRect	vendor/imgui/imgui_widgets.cpp	/^void ImGui::PushColumnClipRect(int column_index)$/;"	f	class:ImGui
PushColumnsBackground	vendor/imgui/imgui_widgets.cpp	/^void ImGui::PushColumnsBackground()$/;"	f	class:ImGui
PushFont	vendor/imgui/imgui.cpp	/^void ImGui::PushFont(ImFont* font)$/;"	f	class:ImGui
PushID	vendor/imgui/imgui.cpp	/^void ImGui::PushID(const char* str_id)$/;"	f	class:ImGui
PushID	vendor/imgui/imgui.cpp	/^void ImGui::PushID(const char* str_id_begin, const char* str_id_end)$/;"	f	class:ImGui
PushID	vendor/imgui/imgui.cpp	/^void ImGui::PushID(const void* ptr_id)$/;"	f	class:ImGui
PushID	vendor/imgui/imgui.cpp	/^void ImGui::PushID(int int_id)$/;"	f	class:ImGui
PushItemFlag	vendor/imgui/imgui.cpp	/^void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)$/;"	f	class:ImGui
PushItemWidth	vendor/imgui/imgui.cpp	/^void ImGui::PushItemWidth(float item_width)$/;"	f	class:ImGui
PushMultiItemsWidths	vendor/imgui/imgui.cpp	/^void ImGui::PushMultiItemsWidths(int components, float w_full)$/;"	f	class:ImGui
PushOverrideID	vendor/imgui/imgui.cpp	/^void ImGui::PushOverrideID(ImGuiID id)$/;"	f	class:ImGui
PushStyleColor	vendor/imgui/imgui.cpp	/^void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)$/;"	f	class:ImGui
PushStyleColor	vendor/imgui/imgui.cpp	/^void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)$/;"	f	class:ImGui
PushStyleVar	vendor/imgui/imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)$/;"	f	class:ImGui
PushStyleVar	vendor/imgui/imgui.cpp	/^void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)$/;"	f	class:ImGui
PushTextWrapPos	vendor/imgui/imgui.cpp	/^void ImGui::PushTextWrapPos(float wrap_pos_x)$/;"	f	class:ImGui
PushTextureID	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::PushTextureID(ImTextureID texture_id)$/;"	f	class:ImDrawList
RadioButton	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::RadioButton(const char* label, bool active)$/;"	f	class:ImGui
RadioButton	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::RadioButton(const char* label, int* v, int v_button)$/;"	f	class:ImGui
RasterizerFlags	vendor/imgui/imgui.h	/^    unsigned int    RasterizerFlags;        \/\/ 0x00     \/\/ Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.$/;"	m	struct:ImFontConfig
RasterizerMultiply	vendor/imgui/imgui.h	/^    float           RasterizerMultiply;     \/\/ 1.0f     \/\/ Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.$/;"	m	struct:ImFontConfig
ReadLineFn	vendor/imgui/imgui_internal.h	/^    void        (*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line); \/\/ Read: Called for every line of text within an ini entry$/;"	m	struct:ImGuiSettingsHandler
ReadOpenFn	vendor/imgui/imgui_internal.h	/^    void*       (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);              \/\/ Read: Called when entering into a new ini entry e.g. "[Window][Name]"$/;"	m	struct:ImGuiSettingsHandler
Rect	vendor/imgui/imgui_internal.h	/^    ImRect      Rect() const                { return ImRect(Pos.x, Pos.y, Pos.x+Size.x, Pos.y+Size.y); }$/;"	f	struct:ImGuiWindow
RectRel	vendor/imgui/imgui_internal.h	/^    ImRect        RectRel;      \/\/ Best candidate bounding box in window relative space$/;"	m	struct:ImGuiNavMoveResult
Rects	vendor/imgui/imgui_draw.cpp	/^    stbrp_rect*         Rects;              \/\/ Rectangle to pack. We first fill in their size and the packer will give us their position.$/;"	m	struct:ImFontBuildSrcData	file:
RefFrame	vendor/imgui/imgui.h	/^    mutable int RefFrame;$/;"	m	struct:ImGuiOnceUponAFrame
Remove	vendor/imgui/imgui_internal.h	/^    void        Remove(ImGuiID key, ImPoolIdx idx)  { Data[idx].~T(); *(int*)&Data[idx] = FreeIdx; FreeIdx = idx; Map.SetInt(key, -1); }$/;"	f	struct:ImPool
Remove	vendor/imgui/imgui_internal.h	/^    void        Remove(ImGuiID key, const T* p)     { Remove(key, GetIndex(p)); }$/;"	f	struct:ImPool
Render	vendor/imgui/imgui.cpp	/^void ImGui::Render()$/;"	f	class:ImGui
RenderArrow	vendor/imgui/imgui.cpp	/^void ImGui::RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImU32 col, ImGuiDir dir, float scale)$/;"	f	class:ImGui
RenderArrow	vendor/imgui/imgui_internal.h	/^    inline void RenderArrow(ImVec2 pos, ImGuiDir dir, float scale=1.0f) { ImGuiWindow* window = GetCurrentWindow(); RenderArrow(window->DrawList, pos, GetColorU32(ImGuiCol_Text), dir, scale); }$/;"	f	namespace:ImGui
RenderArrowPointingAt	vendor/imgui/imgui_draw.cpp	/^void ImGui::RenderArrowPointingAt(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)$/;"	f	class:ImGui
RenderArrowsForVerticalBar	vendor/imgui/imgui_widgets.cpp	/^static void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w)$/;"	f	file:
RenderBullet	vendor/imgui/imgui.cpp	/^void ImGui::RenderBullet(ImDrawList* draw_list, ImVec2 pos, ImU32 col)$/;"	f	class:ImGui
RenderBullet	vendor/imgui/imgui_internal.h	/^    inline void RenderBullet(ImVec2 pos)                                { ImGuiWindow* window = GetCurrentWindow(); RenderBullet(window->DrawList, pos, GetColorU32(ImGuiCol_Text)); }$/;"	f	namespace:ImGui
RenderChar	vendor/imgui/imgui_draw.cpp	/^void ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, ImWchar c) const$/;"	f	class:ImFont
RenderCheckMark	vendor/imgui/imgui.cpp	/^void ImGui::RenderCheckMark(ImVec2 pos, ImU32 col, float sz)$/;"	f	class:ImGui
RenderColorRectWithAlphaCheckerboard	vendor/imgui/imgui_widgets.cpp	/^void ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, int rounding_corners_flags)$/;"	f	class:ImGui
RenderDrawListsFn	vendor/imgui/imgui.h	/^    void        (*RenderDrawListsFn)(ImDrawData* data);$/;"	m	struct:ImGuiIO
RenderDrawListsFnUnused	vendor/imgui/imgui.h	/^    void*       RenderDrawListsFnUnused;$/;"	m	struct:ImGuiIO
RenderFrame	vendor/imgui/imgui.cpp	/^void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)$/;"	f	class:ImGui
RenderFrameBorder	vendor/imgui/imgui.cpp	/^void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)$/;"	f	class:ImGui
RenderMouseCursor	vendor/imgui/imgui_draw.cpp	/^void ImGui::RenderMouseCursor(ImDrawList* draw_list, ImVec2 pos, float scale, ImGuiMouseCursor mouse_cursor)$/;"	f	class:ImGui
RenderNavHighlight	vendor/imgui/imgui.cpp	/^void ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)$/;"	f	class:ImGui
RenderPixelEllipsis	vendor/imgui/imgui_draw.cpp	/^void ImGui::RenderPixelEllipsis(ImDrawList* draw_list, ImVec2 pos, ImU32 col, int count)$/;"	f	class:ImGui
RenderRectFilledRangeH	vendor/imgui/imgui_draw.cpp	/^void ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)$/;"	f	class:ImGui
RenderText	vendor/imgui/imgui.cpp	/^void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)$/;"	f	class:ImGui
RenderText	vendor/imgui/imgui_draw.cpp	/^void ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const$/;"	f	class:ImFont
RenderTextClipped	vendor/imgui/imgui.cpp	/^void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)$/;"	f	class:ImGui
RenderTextClippedEx	vendor/imgui/imgui.cpp	/^void ImGui::RenderTextClippedEx(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_display_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)$/;"	f	class:ImGui
RenderTextEllipsis	vendor/imgui/imgui.cpp	/^void    ImGui::RenderTextEllipsis(ImDrawList* draw_list, const ImVec2& pos_min, const ImVec2& pos_max, float clip_max_x, float ellipsis_max_x, const char* text, const char* text_end_full, const ImVec2* text_size_if_known)$/;"	f	class:ImGui
RenderTextWrapped	vendor/imgui/imgui.cpp	/^void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)$/;"	f	class:ImGui
RenderWindowDecorations	vendor/imgui/imgui.cpp	/^void ImGui::RenderWindowDecorations(ImGuiWindow* window, const ImRect& title_bar_rect, bool title_bar_is_highlight, int resize_grip_count, const ImU32 resize_grip_col[4], float resize_grip_draw_size)$/;"	f	class:ImGui
RenderWindowOuterBorders	vendor/imgui/imgui.cpp	/^static void ImGui::RenderWindowOuterBorders(ImGuiWindow* window)$/;"	f	class:ImGui
RenderWindowTitleBarContents	vendor/imgui/imgui.cpp	/^void ImGui::RenderWindowTitleBarContents(ImGuiWindow* window, const ImRect& title_bar_rect, const char* name, bool* p_open)$/;"	f	class:ImGui
Renderer	Renderer/Renderer.h	/^class Renderer{$/;"	c
ReorderRequestDir	vendor/imgui/imgui_internal.h	/^    ImS8                ReorderRequestDir;$/;"	m	struct:ImGuiTabBar
ReorderRequestTabId	vendor/imgui/imgui_internal.h	/^    ImGuiID             ReorderRequestTabId;$/;"	m	struct:ImGuiTabBar
Reserve	vendor/imgui/imgui_internal.h	/^    void        Reserve(int capacity)               { Data.reserve(capacity); Map.Data.reserve(capacity); }$/;"	f	struct:ImPool
ResetMouseDragDelta	vendor/imgui/imgui.cpp	/^void ImGui::ResetMouseDragDelta(int button)$/;"	f	class:ImGui
Resize	vendor/imgui/imgui_internal.h	/^    void            Resize(int sz)          { Storage.resize((sz + 31) >> 5); memset(Storage.Data, 0, (size_t)Storage.Size * sizeof(Storage.Data[0])); }$/;"	f	struct:ImBoolVector
ResizeBorderHeld	vendor/imgui/imgui_internal.h	/^    signed char             ResizeBorderHeld;                   \/\/ Current border being held for resize (-1: none, otherwise 0-3)$/;"	m	struct:ImGuiWindow
Restore	vendor/imgui/imgui_internal.h	/^    void Restore() const    { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }$/;"	f	struct:ImGuiItemHoveredDataBackup
RootWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            RootWindow;                         \/\/ Point to ourself or first ancestor that is not a child window.$/;"	m	struct:ImGuiWindow
RootWindowForNav	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            RootWindowForNav;                   \/\/ Point to ourself or first ancestor which doesn't have the NavFlattened flag.$/;"	m	struct:ImGuiWindow
RootWindowForTitleBarHighlight	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            RootWindowForTitleBarHighlight;     \/\/ Point to ourself or first ancestor which will display TitleBgActive color when this window is active.$/;"	m	struct:ImGuiWindow
RoundScalarWithFormatT	vendor/imgui/imgui_widgets.cpp	/^TYPE ImGui::RoundScalarWithFormatT(const char* format, ImGuiDataType data_type, TYPE v)$/;"	f	class:ImGui
STBIDEF	vendor/stb_image/stb_image.h	345;"	d
STBIDEF	vendor/stb_image/stb_image.h	347;"	d
STBI_ASSERT	vendor/stb_image/stb_image.h	545;"	d
STBI_EXTERN	vendor/stb_image/stb_image.h	549;"	d
STBI_EXTERN	vendor/stb_image/stb_image.h	551;"	d
STBI_FREE	vendor/stb_image/stb_image.h	609;"	d
STBI_HAS_LROTL	vendor/stb_image/stb_image.h	589;"	d
STBI_INCLUDE_STB_IMAGE_H	vendor/stb_image/stb_image.h	111;"	d
STBI_MALLOC	vendor/stb_image/stb_image.h	607;"	d
STBI_NEON	vendor/stb_image/stb_image.h	704;"	d
STBI_NOTUSED	vendor/stb_image/stb_image.h	583;"	d
STBI_NOTUSED	vendor/stb_image/stb_image.h	585;"	d
STBI_NO_BMP	vendor/stb_image/stb_image.h	502;"	d
STBI_NO_GIF	vendor/stb_image/stb_image.h	511;"	d
STBI_NO_HDR	vendor/stb_image/stb_image.h	514;"	d
STBI_NO_JPEG	vendor/stb_image/stb_image.h	496;"	d
STBI_NO_PIC	vendor/stb_image/stb_image.h	517;"	d
STBI_NO_PNG	vendor/stb_image/stb_image.h	499;"	d
STBI_NO_PNM	vendor/stb_image/stb_image.h	520;"	d
STBI_NO_PSD	vendor/stb_image/stb_image.h	505;"	d
STBI_NO_SIMD	vendor/stb_image/stb_image.h	631;"	d
STBI_NO_SIMD	vendor/stb_image/stb_image.h	646;"	d
STBI_NO_TGA	vendor/stb_image/stb_image.h	508;"	d
STBI_NO_ZLIB	vendor/stb_image/stb_image.h	525;"	d
STBI_ORDER_BGR	vendor/stb_image/stb_image.h	/^   STBI_ORDER_BGR$/;"	e	enum:__anon57
STBI_ORDER_RGB	vendor/stb_image/stb_image.h	/^   STBI_ORDER_RGB,$/;"	e	enum:__anon57
STBI_REALLOC	vendor/stb_image/stb_image.h	608;"	d
STBI_REALLOC_SIZED	vendor/stb_image/stb_image.h	613;"	d
STBI_SIMD_ALIGN	vendor/stb_image/stb_image.h	676;"	d
STBI_SIMD_ALIGN	vendor/stb_image/stb_image.h	687;"	d
STBI_SIMD_ALIGN	vendor/stb_image/stb_image.h	710;"	d
STBI_SIMD_ALIGN	vendor/stb_image/stb_image.h	714;"	d
STBI_SSE2	vendor/stb_image/stb_image.h	650;"	d
STBI_VERSION	vendor/stb_image/stb_image.h	323;"	d
STBI__BYTECAST	vendor/stb_image/stb_image.h	1562;"	d
STBI__CASE	vendor/stb_image/stb_image.h	1600;"	d
STBI__CASE	vendor/stb_image/stb_image.h	1618;"	d
STBI__CASE	vendor/stb_image/stb_image.h	1649;"	d
STBI__CASE	vendor/stb_image/stb_image.h	1667;"	d
STBI__CASE	vendor/stb_image/stb_image.h	4477;"	d
STBI__CASE	vendor/stb_image/stb_image.h	4490;"	d
STBI__CASE	vendor/stb_image/stb_image.h	4494;"	d
STBI__CASE	vendor/stb_image/stb_image.h	4507;"	d
STBI__COMBO	vendor/stb_image/stb_image.h	1599;"	d
STBI__COMBO	vendor/stb_image/stb_image.h	1648;"	d
STBI__F_avg	vendor/stb_image/stb_image.h	/^   STBI__F_avg=3,$/;"	e	enum:__anon68
STBI__F_avg_first	vendor/stb_image/stb_image.h	/^   STBI__F_avg_first,$/;"	e	enum:__anon68
STBI__F_none	vendor/stb_image/stb_image.h	/^   STBI__F_none=0,$/;"	e	enum:__anon68
STBI__F_paeth	vendor/stb_image/stb_image.h	/^   STBI__F_paeth=4,$/;"	e	enum:__anon68
STBI__F_paeth_first	vendor/stb_image/stb_image.h	/^   STBI__F_paeth_first$/;"	e	enum:__anon68
STBI__F_sub	vendor/stb_image/stb_image.h	/^   STBI__F_sub=1,$/;"	e	enum:__anon68
STBI__F_up	vendor/stb_image/stb_image.h	/^   STBI__F_up=2,$/;"	e	enum:__anon68
STBI__HDR_BUFLEN	vendor/stb_image/stb_image.h	6703;"	d
STBI__IDCT_1D	vendor/stb_image/stb_image.h	2233;"	d
STBI__MARKER_none	vendor/stb_image/stb_image.h	2718;"	d
STBI__PNG_TYPE	vendor/stb_image/stb_image.h	4795;"	d
STBI__RESTART	vendor/stb_image/stb_image.h	2735;"	d
STBI__SCAN_header	vendor/stb_image/stb_image.h	/^   STBI__SCAN_header$/;"	e	enum:__anon59
STBI__SCAN_load	vendor/stb_image/stb_image.h	/^   STBI__SCAN_load=0,$/;"	e	enum:__anon59
STBI__SCAN_type	vendor/stb_image/stb_image.h	/^   STBI__SCAN_type,$/;"	e	enum:__anon59
STBI__X64_TARGET	vendor/stb_image/stb_image.h	618;"	d
STBI__X86_TARGET	vendor/stb_image/stb_image.h	620;"	d
STBI__ZFAST_BITS	vendor/stb_image/stb_image.h	3855;"	d
STBI__ZFAST_MASK	vendor/stb_image/stb_image.h	3856;"	d
STBI_default	vendor/stb_image/stb_image.h	/^   STBI_default = 0, \/\/ only used for desired_channels$/;"	e	enum:__anon54
STBI_grey	vendor/stb_image/stb_image.h	/^   STBI_grey       = 1,$/;"	e	enum:__anon54
STBI_grey_alpha	vendor/stb_image/stb_image.h	/^   STBI_grey_alpha = 2,$/;"	e	enum:__anon54
STBI_rgb	vendor/stb_image/stb_image.h	/^   STBI_rgb        = 3,$/;"	e	enum:__anon54
STBI_rgb_alpha	vendor/stb_image/stb_image.h	/^   STBI_rgb_alpha  = 4$/;"	e	enum:__anon54
STBRP_ASSERT	vendor/imgui/imgui_draw.cpp	121;"	d	file:
STBRP_ASSERT	vendor/imgui/imstb_rectpack.h	211;"	d
STBRP_DEF	vendor/imgui/imstb_rectpack.h	69;"	d
STBRP_DEF	vendor/imgui/imstb_rectpack.h	71;"	d
STBRP_HEURISTIC_Skyline_BF_sortHeight	vendor/imgui/imstb_rectpack.h	/^   STBRP_HEURISTIC_Skyline_BF_sortHeight$/;"	e	enum:__anon26
STBRP_HEURISTIC_Skyline_BL_sortHeight	vendor/imgui/imstb_rectpack.h	/^   STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,$/;"	e	enum:__anon26
STBRP_HEURISTIC_Skyline_default	vendor/imgui/imstb_rectpack.h	/^   STBRP_HEURISTIC_Skyline_default=0,$/;"	e	enum:__anon26
STBRP_SORT	vendor/imgui/imgui_draw.cpp	122;"	d	file:
STBRP_SORT	vendor/imgui/imstb_rectpack.h	206;"	d
STBRP_STATIC	vendor/imgui/imgui_draw.cpp	120;"	d	file:
STBRP__CDECL	vendor/imgui/imstb_rectpack.h	217;"	d
STBRP__CDECL	vendor/imgui/imstb_rectpack.h	220;"	d
STBRP__INIT_skyline	vendor/imgui/imstb_rectpack.h	/^   STBRP__INIT_skyline = 1$/;"	e	enum:__anon27
STBRP__MAXVAL	vendor/imgui/imstb_rectpack.h	544;"	d
STBRP__MAXVAL	vendor/imgui/imstb_rectpack.h	546;"	d
STBRP__NOTUSED	vendor/imgui/imstb_rectpack.h	216;"	d
STBRP__NOTUSED	vendor/imgui/imstb_rectpack.h	219;"	d
STBTT_DEF	vendor/imgui/imstb_truetype.h	504;"	d
STBTT_DEF	vendor/imgui/imstb_truetype.h	506;"	d
STBTT_FIX	vendor/imgui/imstb_truetype.h	2740;"	d
STBTT_FIXMASK	vendor/imgui/imstb_truetype.h	2741;"	d
STBTT_FIXSHIFT	vendor/imgui/imstb_truetype.h	2739;"	d
STBTT_GPOS_TODO_assert	vendor/imgui/imstb_truetype.h	2426;"	d
STBTT_MACSTYLE_BOLD	vendor/imgui/imstb_truetype.h	1010;"	d
STBTT_MACSTYLE_DONTCARE	vendor/imgui/imstb_truetype.h	1009;"	d
STBTT_MACSTYLE_ITALIC	vendor/imgui/imstb_truetype.h	1011;"	d
STBTT_MACSTYLE_NONE	vendor/imgui/imstb_truetype.h	1013;"	d
STBTT_MACSTYLE_UNDERSCORE	vendor/imgui/imstb_truetype.h	1012;"	d
STBTT_MAC_EID_ARABIC	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon40
STBTT_MAC_EID_CHINESE_TRAD	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon40
STBTT_MAC_EID_GREEK	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_EID_CHINESE_TRAD =2,   STBTT_MAC_EID_GREEK        =6,$/;"	e	enum:__anon40
STBTT_MAC_EID_HEBREW	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon40
STBTT_MAC_EID_JAPANESE	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_EID_JAPANESE     =1,   STBTT_MAC_EID_HEBREW       =5,$/;"	e	enum:__anon40
STBTT_MAC_EID_KOREAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon40
STBTT_MAC_EID_ROMAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_EID_ROMAN        =0,   STBTT_MAC_EID_ARABIC       =4,$/;"	e	enum:__anon40
STBTT_MAC_EID_RUSSIAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_EID_KOREAN       =3,   STBTT_MAC_EID_RUSSIAN      =7$/;"	e	enum:__anon40
STBTT_MAC_LANG_ARABIC	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon42
STBTT_MAC_LANG_CHINESE_SIMPLIFIED	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon42
STBTT_MAC_LANG_CHINESE_TRAD	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon42
STBTT_MAC_LANG_DUTCH	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon42
STBTT_MAC_LANG_ENGLISH	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon42
STBTT_MAC_LANG_FRENCH	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon42
STBTT_MAC_LANG_GERMAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon42
STBTT_MAC_LANG_HEBREW	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_HEBREW       =10,   STBTT_MAC_LANG_CHINESE_SIMPLIFIED =33,$/;"	e	enum:__anon42
STBTT_MAC_LANG_ITALIAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_ITALIAN      =3 ,   STBTT_MAC_LANG_CHINESE_TRAD =19$/;"	e	enum:__anon42
STBTT_MAC_LANG_JAPANESE	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_ENGLISH      =0 ,   STBTT_MAC_LANG_JAPANESE     =11,$/;"	e	enum:__anon42
STBTT_MAC_LANG_KOREAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_ARABIC       =12,   STBTT_MAC_LANG_KOREAN       =23,$/;"	e	enum:__anon42
STBTT_MAC_LANG_RUSSIAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_DUTCH        =4 ,   STBTT_MAC_LANG_RUSSIAN      =32,$/;"	e	enum:__anon42
STBTT_MAC_LANG_SPANISH	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_FRENCH       =1 ,   STBTT_MAC_LANG_SPANISH      =6 ,$/;"	e	enum:__anon42
STBTT_MAC_LANG_SWEDISH	vendor/imgui/imstb_truetype.h	/^   STBTT_MAC_LANG_GERMAN       =2 ,   STBTT_MAC_LANG_SWEDISH      =5 ,$/;"	e	enum:__anon42
STBTT_MAX_OVERSAMPLE	vendor/imgui/imstb_truetype.h	1092;"	d
STBTT_MS_EID_SHIFTJIS	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_EID_SHIFTJIS      =2,$/;"	e	enum:__anon39
STBTT_MS_EID_SYMBOL	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_EID_SYMBOL        =0,$/;"	e	enum:__anon39
STBTT_MS_EID_UNICODE_BMP	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_EID_UNICODE_BMP   =1,$/;"	e	enum:__anon39
STBTT_MS_EID_UNICODE_FULL	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_EID_UNICODE_FULL  =10$/;"	e	enum:__anon39
STBTT_MS_LANG_CHINESE	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon41
STBTT_MS_LANG_DUTCH	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon41
STBTT_MS_LANG_ENGLISH	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon41
STBTT_MS_LANG_FRENCH	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon41
STBTT_MS_LANG_GERMAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon41
STBTT_MS_LANG_HEBREW	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon41
STBTT_MS_LANG_ITALIAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_ENGLISH     =0x0409,   STBTT_MS_LANG_ITALIAN     =0x0410,$/;"	e	enum:__anon41
STBTT_MS_LANG_JAPANESE	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_CHINESE     =0x0804,   STBTT_MS_LANG_JAPANESE    =0x0411,$/;"	e	enum:__anon41
STBTT_MS_LANG_KOREAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_DUTCH       =0x0413,   STBTT_MS_LANG_KOREAN      =0x0412,$/;"	e	enum:__anon41
STBTT_MS_LANG_RUSSIAN	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_FRENCH      =0x040c,   STBTT_MS_LANG_RUSSIAN     =0x0419,$/;"	e	enum:__anon41
STBTT_MS_LANG_SPANISH	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_GERMAN      =0x0407,   STBTT_MS_LANG_SPANISH     =0x0409,$/;"	e	enum:__anon41
STBTT_MS_LANG_SWEDISH	vendor/imgui/imstb_truetype.h	/^   STBTT_MS_LANG_HEBREW      =0x040d,   STBTT_MS_LANG_SWEDISH     =0x041D$/;"	e	enum:__anon41
STBTT_PLATFORM_ID_ISO	vendor/imgui/imstb_truetype.h	/^   STBTT_PLATFORM_ID_ISO       =2,$/;"	e	enum:__anon37
STBTT_PLATFORM_ID_MAC	vendor/imgui/imstb_truetype.h	/^   STBTT_PLATFORM_ID_MAC       =1,$/;"	e	enum:__anon37
STBTT_PLATFORM_ID_MICROSOFT	vendor/imgui/imstb_truetype.h	/^   STBTT_PLATFORM_ID_MICROSOFT =3$/;"	e	enum:__anon37
STBTT_PLATFORM_ID_UNICODE	vendor/imgui/imstb_truetype.h	/^   STBTT_PLATFORM_ID_UNICODE   =0,$/;"	e	enum:__anon37
STBTT_POINT_SIZE	vendor/imgui/imstb_truetype.h	603;"	d
STBTT_RASTERIZER_VERSION	vendor/imgui/imstb_truetype.h	1102;"	d
STBTT_STATIC	vendor/imgui/imgui_draw.cpp	143;"	d	file:
STBTT_UNICODE_EID_ISO_10646	vendor/imgui/imstb_truetype.h	/^   STBTT_UNICODE_EID_ISO_10646      =2,$/;"	e	enum:__anon38
STBTT_UNICODE_EID_UNICODE_1_0	vendor/imgui/imstb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_0    =0,$/;"	e	enum:__anon38
STBTT_UNICODE_EID_UNICODE_1_1	vendor/imgui/imstb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_1_1    =1,$/;"	e	enum:__anon38
STBTT_UNICODE_EID_UNICODE_2_0_BMP	vendor/imgui/imstb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_BMP=3,$/;"	e	enum:__anon38
STBTT_UNICODE_EID_UNICODE_2_0_FULL	vendor/imgui/imstb_truetype.h	/^   STBTT_UNICODE_EID_UNICODE_2_0_FULL=4$/;"	e	enum:__anon38
STBTT__COMPARE	vendor/imgui/imstb_truetype.h	3237;"	d
STBTT__CSCTX_INIT	vendor/imgui/imstb_truetype.h	1877;"	d
STBTT__CSERR	vendor/imgui/imstb_truetype.h	1986;"	d
STBTT__CSERR	vendor/imgui/imstb_truetype.h	2234;"	d
STBTT__NOTUSED	vendor/imgui/imstb_truetype.h	1106;"	d
STBTT__NOTUSED	vendor/imgui/imstb_truetype.h	1108;"	d
STBTT__OVER_MASK	vendor/imgui/imstb_truetype.h	3850;"	d
STBTT_acos	vendor/imgui/imstb_truetype.h	461;"	d
STBTT_assert	vendor/imgui/imgui_draw.cpp	136;"	d	file:
STBTT_assert	vendor/imgui/imstb_truetype.h	478;"	d
STBTT_cos	vendor/imgui/imstb_truetype.h	460;"	d
STBTT_fabs	vendor/imgui/imgui_draw.cpp	140;"	d	file:
STBTT_fabs	vendor/imgui/imstb_truetype.h	466;"	d
STBTT_fmod	vendor/imgui/imgui_draw.cpp	137;"	d	file:
STBTT_fmod	vendor/imgui/imstb_truetype.h	455;"	d
STBTT_free	vendor/imgui/imgui_draw.cpp	135;"	d	file:
STBTT_free	vendor/imgui/imstb_truetype.h	473;"	d
STBTT_iceil	vendor/imgui/imgui_draw.cpp	142;"	d	file:
STBTT_iceil	vendor/imgui/imstb_truetype.h	444;"	d
STBTT_ifloor	vendor/imgui/imgui_draw.cpp	141;"	d	file:
STBTT_ifloor	vendor/imgui/imstb_truetype.h	443;"	d
STBTT_malloc	vendor/imgui/imgui_draw.cpp	134;"	d	file:
STBTT_malloc	vendor/imgui/imstb_truetype.h	472;"	d
STBTT_max	vendor/imgui/imstb_truetype.h	4226;"	d
STBTT_memcpy	vendor/imgui/imstb_truetype.h	488;"	d
STBTT_memset	vendor/imgui/imstb_truetype.h	489;"	d
STBTT_min	vendor/imgui/imstb_truetype.h	4225;"	d
STBTT_pow	vendor/imgui/imgui_draw.cpp	139;"	d	file:
STBTT_pow	vendor/imgui/imstb_truetype.h	450;"	d
STBTT_sqrt	vendor/imgui/imgui_draw.cpp	138;"	d	file:
STBTT_sqrt	vendor/imgui/imstb_truetype.h	449;"	d
STBTT_strlen	vendor/imgui/imstb_truetype.h	483;"	d
STBTT_vcubic	vendor/imgui/imstb_truetype.h	/^      STBTT_vcubic$/;"	e	enum:__anon34
STBTT_vcurve	vendor/imgui/imstb_truetype.h	/^      STBTT_vcurve,$/;"	e	enum:__anon34
STBTT_vline	vendor/imgui/imstb_truetype.h	/^      STBTT_vline,$/;"	e	enum:__anon34
STBTT_vmove	vendor/imgui/imstb_truetype.h	/^      STBTT_vmove=1,$/;"	e	enum:__anon34
STB_IMAGE_IMPLEMENTATION	vendor/stb_image/stb_image.cpp	1;"	d	file:
STB_INCLUDE_STB_RECT_PACK_H	vendor/imgui/imstb_rectpack.h	64;"	d
STB_RECT_PACK_IMPLEMENTATION	vendor/imgui/imgui_draw.cpp	123;"	d	file:
STB_RECT_PACK_VERSION	vendor/imgui/imstb_rectpack.h	66;"	d
STB_SPRINTF_IMPLEMENTATION	vendor/imgui/imgui.cpp	1465;"	d	file:
STB_TEXTEDIT_CHARTYPE	vendor/imgui/imgui_internal.h	115;"	d
STB_TEXTEDIT_CHARTYPE	vendor/imgui/imgui_internal.h	117;"	d
STB_TEXTEDIT_CHARTYPE	vendor/imgui/imstb_textedit.h	295;"	d
STB_TEXTEDIT_DELETECHARS	vendor/imgui/imgui_widgets.cpp	/^static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)$/;"	f	namespace:ImStb
STB_TEXTEDIT_GETCHAR	vendor/imgui/imgui_widgets.cpp	/^static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx)                      { return obj->TextW[idx]; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_GETWIDTH	vendor/imgui/imgui_widgets.cpp	/^static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx)  { ImWchar c = obj->TextW[line_start_idx + char_idx]; if (c == '\\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; ImGuiContext& g = *GImGui; return g.Font->GetCharAdvance(c) * (g.FontSize \/ g.Font->FontSize); }$/;"	f	namespace:ImStb
STB_TEXTEDIT_GETWIDTH_NEWLINE	vendor/imgui/imgui_internal.h	118;"	d
STB_TEXTEDIT_IMPLEMENTATION	vendor/imgui/imgui_widgets.cpp	3217;"	d	file:
STB_TEXTEDIT_INSERTCHARS	vendor/imgui/imgui_widgets.cpp	/^static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)$/;"	f	namespace:ImStb
STB_TEXTEDIT_KEYTOTEXT	vendor/imgui/imgui_widgets.cpp	/^static int     STB_TEXTEDIT_KEYTOTEXT(int key)                                                    { return key >= 0x10000 ? 0 : key; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_KEYTYPE	vendor/imgui/imstb_textedit.h	724;"	d
STB_TEXTEDIT_K_BACKSPACE	vendor/imgui/imgui_widgets.cpp	3210;"	d	file:
STB_TEXTEDIT_K_DELETE	vendor/imgui/imgui_widgets.cpp	3209;"	d	file:
STB_TEXTEDIT_K_DOWN	vendor/imgui/imgui_widgets.cpp	3204;"	d	file:
STB_TEXTEDIT_K_LEFT	vendor/imgui/imgui_widgets.cpp	3201;"	d	file:
STB_TEXTEDIT_K_LINEEND	vendor/imgui/imgui_widgets.cpp	3206;"	d	file:
STB_TEXTEDIT_K_LINESTART	vendor/imgui/imgui_widgets.cpp	3205;"	d	file:
STB_TEXTEDIT_K_REDO	vendor/imgui/imgui_widgets.cpp	3212;"	d	file:
STB_TEXTEDIT_K_RIGHT	vendor/imgui/imgui_widgets.cpp	3202;"	d	file:
STB_TEXTEDIT_K_SHIFT	vendor/imgui/imgui_widgets.cpp	3215;"	d	file:
STB_TEXTEDIT_K_TEXTEND	vendor/imgui/imgui_widgets.cpp	3208;"	d	file:
STB_TEXTEDIT_K_TEXTSTART	vendor/imgui/imgui_widgets.cpp	3207;"	d	file:
STB_TEXTEDIT_K_UNDO	vendor/imgui/imgui_widgets.cpp	3211;"	d	file:
STB_TEXTEDIT_K_UP	vendor/imgui/imgui_widgets.cpp	3203;"	d	file:
STB_TEXTEDIT_K_WORDLEFT	vendor/imgui/imgui_widgets.cpp	3213;"	d	file:
STB_TEXTEDIT_K_WORDRIGHT	vendor/imgui/imgui_widgets.cpp	3214;"	d	file:
STB_TEXTEDIT_LAYOUTROW	vendor/imgui/imgui_widgets.cpp	/^static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)$/;"	f	namespace:ImStb
STB_TEXTEDIT_MOVEWORDLEFT	vendor/imgui/imgui_widgets.cpp	3151;"	d	file:
STB_TEXTEDIT_MOVEWORDLEFT	vendor/imgui/imstb_textedit.h	663;"	d
STB_TEXTEDIT_MOVEWORDLEFT_IMPL	vendor/imgui/imgui_widgets.cpp	/^static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)   { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_MOVEWORDRIGHT	vendor/imgui/imgui_widgets.cpp	3152;"	d	file:
STB_TEXTEDIT_MOVEWORDRIGHT	vendor/imgui/imstb_textedit.h	679;"	d
STB_TEXTEDIT_MOVEWORDRIGHT_IMPL	vendor/imgui/imgui_widgets.cpp	/^static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_MOVEWORDRIGHT_IMPL	vendor/imgui/imgui_widgets.cpp	/^static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx)  { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_NEWLINE	vendor/imgui/imgui_widgets.cpp	/^static ImWchar STB_TEXTEDIT_NEWLINE = '\\n';$/;"	m	namespace:ImStb	file:
STB_TEXTEDIT_POSITIONTYPE	vendor/imgui/imstb_textedit.h	298;"	d
STB_TEXTEDIT_STRING	vendor/imgui/imgui_internal.h	114;"	d
STB_TEXTEDIT_STRING	vendor/imgui/imgui_internal.h	116;"	d
STB_TEXTEDIT_STRINGLEN	vendor/imgui/imgui_widgets.cpp	/^static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj)                             { return obj->CurLenW; }$/;"	f	namespace:ImStb
STB_TEXTEDIT_UNDOCHARCOUNT	vendor/imgui/imgui_internal.h	120;"	d
STB_TEXTEDIT_UNDOCHARCOUNT	vendor/imgui/imstb_textedit.h	292;"	d
STB_TEXTEDIT_UNDOSTATECOUNT	vendor/imgui/imgui_internal.h	119;"	d
STB_TEXTEDIT_UNDOSTATECOUNT	vendor/imgui/imstb_textedit.h	289;"	d
STB_TEXTEDIT_memmove	vendor/imgui/imstb_textedit.h	386;"	d
STB_TEXT_HAS_SELECTION	vendor/imgui/imstb_textedit.h	572;"	d
STB_TRUETYPE_IMPLEMENTATION	vendor/imgui/imgui_draw.cpp	144;"	d	file:
STB_TexteditState	vendor/imgui/imstb_textedit.h	/^} STB_TexteditState;$/;"	t	typeref:struct:__anon50
SameLine	vendor/imgui/imgui.cpp	/^void ImGui::SameLine(float offset_from_start_x, float spacing_w)$/;"	f	class:ImGui
SaveIniSettingsToDisk	vendor/imgui/imgui.cpp	/^void ImGui::SaveIniSettingsToDisk(const char* ini_filename)$/;"	f	class:ImGui
SaveIniSettingsToMemory	vendor/imgui/imgui.cpp	/^const char* ImGui::SaveIniSettingsToMemory(size_t* out_size)$/;"	f	class:ImGui
Scale	vendor/imgui/imgui.h	/^    float                       Scale;              \/\/ 4     \/\/ in  \/\/ = 1.f      \/\/ Base font scale, multiplied by the per-window font scale which you can adjust with SetWindowFontScale()$/;"	m	struct:ImFont
ScaleAllSizes	vendor/imgui/imgui.cpp	/^void ImGuiStyle::ScaleAllSizes(float scale_factor)$/;"	f	class:ImGuiStyle
ScaleClipRects	vendor/imgui/imgui_draw.cpp	/^void ImDrawData::ScaleClipRects(const ImVec2& fb_scale)$/;"	f	class:ImDrawData
ScanFmt	vendor/imgui/imgui_internal.h	/^    const char* ScanFmt;        \/\/ Default scanf format for the type$/;"	m	struct:ImGuiDataTypeInfo
Scroll	vendor/imgui/imgui_internal.h	/^    ImVec2                  Scroll;$/;"	m	struct:ImGuiWindow
ScrollMax	vendor/imgui/imgui_internal.h	/^    ImVec2                  ScrollMax;$/;"	m	struct:ImGuiWindow
ScrollTarget	vendor/imgui/imgui_internal.h	/^    ImVec2                  ScrollTarget;                       \/\/ target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)$/;"	m	struct:ImGuiWindow
ScrollTargetCenterRatio	vendor/imgui/imgui_internal.h	/^    ImVec2                  ScrollTargetCenterRatio;            \/\/ 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered$/;"	m	struct:ImGuiWindow
ScrollToBottom	vendor/imgui/imgui_demo.cpp	/^    bool                  ScrollToBottom;$/;"	m	struct:ExampleAppConsole	file:
ScrollToBringRectIntoView	vendor/imgui/imgui.cpp	/^void ImGui::ScrollToBringRectIntoView(ImGuiWindow* window, const ImRect& item_rect)$/;"	f	class:ImGui
ScrollX	vendor/imgui/imgui_internal.h	/^    float                   ScrollX;                \/\/ horizontal scrolling\/offset$/;"	m	struct:ImGuiInputTextState
Scrollbar	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Scrollbar(ImGuiAxis axis)$/;"	f	class:ImGui
ScrollbarClickDeltaToGrabCenter	vendor/imgui/imgui_internal.h	/^    float                   ScrollbarClickDeltaToGrabCenter;    \/\/ Distance between mouse and center of grab box, normalized in parent space. Use storage?$/;"	m	struct:ImGuiContext
ScrollbarEx	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::ScrollbarEx(const ImRect& bb_frame, ImGuiID id, ImGuiAxis axis, float* p_scroll_v, float size_avail_v, float size_contents_v, ImDrawCornerFlags rounding_corners)$/;"	f	class:ImGui
ScrollbarRounding	vendor/imgui/imgui.h	/^    float       ScrollbarRounding;          \/\/ Radius of grab corners for scrollbar.$/;"	m	struct:ImGuiStyle
ScrollbarSize	vendor/imgui/imgui.h	/^    float       ScrollbarSize;              \/\/ Width of the vertical scrollbar, Height of the horizontal scrollbar.$/;"	m	struct:ImGuiStyle
ScrollbarSizes	vendor/imgui/imgui_internal.h	/^    ImVec2                  ScrollbarSizes;                     \/\/ Size taken by scrollbars on each axis$/;"	m	struct:ImGuiWindow
ScrollbarX	vendor/imgui/imgui_internal.h	/^    bool                    ScrollbarX, ScrollbarY;$/;"	m	struct:ImGuiWindow
ScrollbarY	vendor/imgui/imgui_internal.h	/^    bool                    ScrollbarX, ScrollbarY;$/;"	m	struct:ImGuiWindow
ScrollingAnim	vendor/imgui/imgui_internal.h	/^    float               ScrollingAnim;$/;"	m	struct:ImGuiTabBar
ScrollingSpeed	vendor/imgui/imgui_internal.h	/^    float               ScrollingSpeed;$/;"	m	struct:ImGuiTabBar
ScrollingTarget	vendor/imgui/imgui_internal.h	/^    float               ScrollingTarget;$/;"	m	struct:ImGuiTabBar
ScrollingTargetDistToVisibility	vendor/imgui/imgui_internal.h	/^    float               ScrollingTargetDistToVisibility;$/;"	m	struct:ImGuiTabBar
SelectAll	vendor/imgui/imgui_internal.h	/^    void        SelectAll()                 { Stb.select_start = 0; Stb.cursor = Stb.select_end = CurLenW; Stb.has_preferred_x = 0; }$/;"	f	struct:ImGuiInputTextState
SelectScopeId	vendor/imgui/imgui_internal.h	/^    ImGuiID       SelectScopeId;\/\/ Best candidate window current selectable group ID$/;"	m	struct:ImGuiNavMoveResult
Selectable	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui
Selectable	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)$/;"	f	class:ImGui
SelectableTextAlign	vendor/imgui/imgui.h	/^    ImVec2      SelectableTextAlign;        \/\/ Alignment of selectable text when selectable is larger than text. Defaults to (0.0f, 0.0f) (top-left aligned).$/;"	m	struct:ImGuiStyle
SelectedAllMouseLock	vendor/imgui/imgui_internal.h	/^    bool                    SelectedAllMouseLock;   \/\/ after a double-click to select all, we ignore further mouse drags to update selection$/;"	m	struct:ImGuiInputTextState
SelectedTabId	vendor/imgui/imgui_internal.h	/^    ImGuiID             SelectedTabId;          \/\/ Selected tab$/;"	m	struct:ImGuiTabBar
SelectionEnd	vendor/imgui/imgui.h	/^    int                 SelectionEnd;   \/\/                                      \/\/ Read-write   \/\/ [Completion,History,Always]$/;"	m	struct:ImGuiInputTextCallbackData
SelectionStart	vendor/imgui/imgui.h	/^    int                 SelectionStart; \/\/                                      \/\/ Read-write   \/\/ [Completion,History,Always] == to SelectionEnd when no selection)$/;"	m	struct:ImGuiInputTextCallbackData
Separator	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Separator()$/;"	f	class:ImGui
SeparatorEx	vendor/imgui/imgui_widgets.cpp	/^void ImGui::SeparatorEx(ImGuiSeparatorFlags flags)$/;"	f	class:ImGui
SetActiveID	vendor/imgui/imgui.cpp	/^void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)$/;"	f	class:ImGui
SetAllInt	vendor/imgui/imgui.cpp	/^void ImGuiStorage::SetAllInt(int v)$/;"	f	class:ImGuiStorage
SetAllocatorFunctions	vendor/imgui/imgui.cpp	/^void ImGui::SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void (*free_func)(void* ptr, void* user_data), void* user_data)$/;"	f	class:ImGui
SetBit	vendor/imgui/imgui.h	/^    inline void     SetBit(int n)       { int off = (n >> 5); ImU32 mask = 1u << (n & 31); UsedChars[off] |= mask; }               \/\/ Set bit n in the array$/;"	f	struct:ImFontGlyphRangesBuilder
SetBit	vendor/imgui/imgui_internal.h	/^    void            SetBit(int n, bool v)   { int off = (n >> 5); int mask = 1 << (n & 31); if (v) Storage[off] |= mask; else Storage[off] &= ~mask; }$/;"	f	struct:ImBoolVector
SetBool	vendor/imgui/imgui.cpp	/^void ImGuiStorage::SetBool(ImGuiID key, bool val)$/;"	f	class:ImGuiStorage
SetClipboardText	vendor/imgui/imgui.cpp	/^void ImGui::SetClipboardText(const char* text)$/;"	f	class:ImGui
SetClipboardTextFn	vendor/imgui/imgui.h	/^    void        (*SetClipboardTextFn)(void* user_data, const char* text);$/;"	m	struct:ImGuiIO
SetClipboardTextFn_DefaultImpl	vendor/imgui/imgui.cpp	/^static void SetClipboardTextFn_DefaultImpl(void*, const char* text)$/;"	f	file:
SetColorEditOptions	vendor/imgui/imgui_widgets.cpp	/^void ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)$/;"	f	class:ImGui
SetColumnOffset	vendor/imgui/imgui_widgets.cpp	/^void ImGui::SetColumnOffset(int column_index, float offset)$/;"	f	class:ImGui
SetColumnWidth	vendor/imgui/imgui_widgets.cpp	/^void ImGui::SetColumnWidth(int column_index, float width)$/;"	f	class:ImGui
SetCurrentChannel	vendor/imgui/imgui_draw.cpp	/^void ImDrawListSplitter::SetCurrentChannel(ImDrawList* draw_list, int idx)$/;"	f	class:ImDrawListSplitter
SetCurrentContext	vendor/imgui/imgui.cpp	/^void ImGui::SetCurrentContext(ImGuiContext* ctx)$/;"	f	class:ImGui
SetCurrentFont	vendor/imgui/imgui.cpp	/^void ImGui::SetCurrentFont(ImFont* font)$/;"	f	class:ImGui
SetCurrentWindow	vendor/imgui/imgui.cpp	/^static void SetCurrentWindow(ImGuiWindow* window)$/;"	f	file:
SetCursorPos	vendor/imgui/imgui.cpp	/^void ImGui::SetCursorPos(const ImVec2& local_pos)$/;"	f	class:ImGui
SetCursorPosX	vendor/imgui/imgui.cpp	/^void ImGui::SetCursorPosX(float x)$/;"	f	class:ImGui
SetCursorPosY	vendor/imgui/imgui.cpp	/^void ImGui::SetCursorPosY(float y)$/;"	f	class:ImGui
SetCursorPosYAndSetupDummyPrevLine	vendor/imgui/imgui.cpp	/^static void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)$/;"	f	file:
SetCursorScreenPos	vendor/imgui/imgui.cpp	/^void ImGui::SetCursorScreenPos(const ImVec2& pos)$/;"	f	class:ImGui
SetDragDropPayload	vendor/imgui/imgui.cpp	/^bool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)$/;"	f	class:ImGui
SetFallbackChar	vendor/imgui/imgui_draw.cpp	/^void ImFont::SetFallbackChar(ImWchar c)$/;"	f	class:ImFont
SetFloat	vendor/imgui/imgui.cpp	/^void ImGuiStorage::SetFloat(ImGuiID key, float val)$/;"	f	class:ImGuiStorage
SetFocusID	vendor/imgui/imgui.cpp	/^void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)$/;"	f	class:ImGui
SetHSV	vendor/imgui/imgui.h	/^    inline void    SetHSV(float h, float s, float v, float a = 1.0f){ ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }$/;"	f	struct:ImColor
SetHoveredID	vendor/imgui/imgui.cpp	/^void ImGui::SetHoveredID(ImGuiID id)$/;"	f	class:ImGui
SetInt	vendor/imgui/imgui.cpp	/^void ImGuiStorage::SetInt(ImGuiID key, int val)$/;"	f	class:ImGuiStorage
SetItemAllowOverlap	vendor/imgui/imgui.cpp	/^void ImGui::SetItemAllowOverlap()$/;"	f	class:ImGui
SetItemDefaultFocus	vendor/imgui/imgui.cpp	/^void ImGui::SetItemDefaultFocus()$/;"	f	class:ImGui
SetKeyboardFocusHere	vendor/imgui/imgui.cpp	/^void ImGui::SetKeyboardFocusHere(int offset)$/;"	f	class:ImGui
SetMouseCursor	vendor/imgui/imgui.cpp	/^void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)$/;"	f	class:ImGui
SetNavID	vendor/imgui/imgui.cpp	/^void ImGui::SetNavID(ImGuiID id, int nav_layer)$/;"	f	class:ImGui
SetNavIDWithRectRel	vendor/imgui/imgui.cpp	/^void ImGui::SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel)$/;"	f	class:ImGui
SetNextItemOpen	vendor/imgui/imgui_widgets.cpp	/^void ImGui::SetNextItemOpen(bool is_open, ImGuiCond cond)$/;"	f	class:ImGui
SetNextItemWidth	vendor/imgui/imgui.cpp	/^void ImGui::SetNextItemWidth(float item_width)$/;"	f	class:ImGui
SetNextTreeNodeOpen	vendor/imgui/imgui.h	/^    static inline void  SetNextTreeNodeOpen(bool open, ImGuiCond cond = 0) { SetNextItemOpen(open, cond); }$/;"	f	namespace:ImGui
SetNextWindowBgAlpha	vendor/imgui/imgui.cpp	/^void ImGui::SetNextWindowBgAlpha(float alpha)$/;"	f	class:ImGui
SetNextWindowCollapsed	vendor/imgui/imgui.cpp	/^void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)$/;"	f	class:ImGui
SetNextWindowContentSize	vendor/imgui/imgui.cpp	/^void ImGui::SetNextWindowContentSize(const ImVec2& size)$/;"	f	class:ImGui
SetNextWindowContentWidth	vendor/imgui/imgui.h	/^    static inline void  SetNextWindowContentWidth(float w)    { SetNextWindowContentSize(ImVec2(w, 0.0f)); }$/;"	f	namespace:ImGui
SetNextWindowFocus	vendor/imgui/imgui.cpp	/^void ImGui::SetNextWindowFocus()$/;"	f	class:ImGui
SetNextWindowPos	vendor/imgui/imgui.cpp	/^void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)$/;"	f	class:ImGui
SetNextWindowPosCenter	vendor/imgui/imgui.h	/^    static inline void  SetNextWindowPosCenter(ImGuiCond c=0) { ImGuiIO& io = GetIO(); SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), c, ImVec2(0.5f, 0.5f)); }$/;"	f	namespace:ImGui
SetNextWindowSize	vendor/imgui/imgui.cpp	/^void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)$/;"	f	class:ImGui
SetNextWindowSizeConstraints	vendor/imgui/imgui.cpp	/^void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)$/;"	f	class:ImGui
SetScrollFromPosX	vendor/imgui/imgui.cpp	/^void ImGui::SetScrollFromPosX(ImGuiWindow* window, float local_x, float center_x_ratio)$/;"	f	class:ImGui
SetScrollFromPosX	vendor/imgui/imgui.cpp	/^void ImGui::SetScrollFromPosX(float local_x, float center_x_ratio)$/;"	f	class:ImGui
SetScrollFromPosY	vendor/imgui/imgui.cpp	/^void ImGui::SetScrollFromPosY(ImGuiWindow* window, float local_y, float center_y_ratio)$/;"	f	class:ImGui
SetScrollFromPosY	vendor/imgui/imgui.cpp	/^void ImGui::SetScrollFromPosY(float local_y, float center_y_ratio)$/;"	f	class:ImGui
SetScrollHere	vendor/imgui/imgui.h	/^    static inline void  SetScrollHere(float center_ratio=0.5f){ SetScrollHereY(center_ratio); }$/;"	f	namespace:ImGui
SetScrollHereX	vendor/imgui/imgui.cpp	/^void ImGui::SetScrollHereX(float center_x_ratio)$/;"	f	class:ImGui
SetScrollHereY	vendor/imgui/imgui.cpp	/^void ImGui::SetScrollHereY(float center_y_ratio)$/;"	f	class:ImGui
SetScrollX	vendor/imgui/imgui.cpp	/^void ImGui::SetScrollX(ImGuiWindow* window, float new_scroll_x)$/;"	f	class:ImGui
SetScrollX	vendor/imgui/imgui.cpp	/^void ImGui::SetScrollX(float scroll_x)$/;"	f	class:ImGui
SetScrollY	vendor/imgui/imgui.cpp	/^void ImGui::SetScrollY(ImGuiWindow* window, float new_scroll_y)$/;"	f	class:ImGui
SetScrollY	vendor/imgui/imgui.cpp	/^void ImGui::SetScrollY(float scroll_y)$/;"	f	class:ImGui
SetStateStorage	vendor/imgui/imgui.cpp	/^void ImGui::SetStateStorage(ImGuiStorage* tree)$/;"	f	class:ImGui
SetTabItemClosed	vendor/imgui/imgui_widgets.cpp	/^void    ImGui::SetTabItemClosed(const char* label)$/;"	f	class:ImGui
SetTexID	vendor/imgui/imgui.h	/^    void                        SetTexID(ImTextureID id)    { TexID = id; }$/;"	f	struct:ImFontAtlas
SetTooltip	vendor/imgui/imgui.cpp	/^void ImGui::SetTooltip(const char* fmt, ...)$/;"	f	class:ImGui
SetTooltipV	vendor/imgui/imgui.cpp	/^void ImGui::SetTooltipV(const char* fmt, va_list args)$/;"	f	class:ImGui
SetUniform1i	Shader/Shader.cpp	/^void Shader::SetUniform1i(const std::string& name, int value){$/;"	f	class:Shader
SetUniform4f	Shader/Shader.cpp	/^void Shader::SetUniform4f(const std::string& name, float v0, float v1, float v2, float v3){$/;"	f	class:Shader
SetUniformMat4f	Shader/Shader.cpp	/^void Shader::SetUniformMat4f(const std::string& name, const glm::mat4& matrix){$/;"	f	class:Shader
SetVoidPtr	vendor/imgui/imgui.cpp	/^void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)$/;"	f	class:ImGuiStorage
SetWindowCollapsed	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowCollapsed	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowCollapsed	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowCollapsedAllowFlags	vendor/imgui/imgui_internal.h	/^    ImGuiCond               SetWindowCollapsedAllowFlags;       \/\/ store acceptable condition flags for SetNextWindowCollapsed() use.$/;"	m	struct:ImGuiWindow
SetWindowConditionAllowFlags	vendor/imgui/imgui.cpp	/^static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)$/;"	f	file:
SetWindowFocus	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowFocus()$/;"	f	class:ImGui
SetWindowFocus	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowFocus(const char* name)$/;"	f	class:ImGui
SetWindowFontScale	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowFontScale(float scale)$/;"	f	class:ImGui
SetWindowPos	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowPos	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowPos	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowPosAllowFlags	vendor/imgui/imgui_internal.h	/^    ImGuiCond               SetWindowPosAllowFlags;             \/\/ store acceptable condition flags for SetNextWindowPos() use.$/;"	m	struct:ImGuiWindow
SetWindowPosPivot	vendor/imgui/imgui_internal.h	/^    ImVec2                  SetWindowPosPivot;                  \/\/ store window pivot for positioning. ImVec2(0,0) when positioning from top-left corner; ImVec2(0.5f,0.5f) for centering; ImVec2(1,1) for bottom right.$/;"	m	struct:ImGuiWindow
SetWindowPosVal	vendor/imgui/imgui_internal.h	/^    ImVec2                  SetWindowPosVal;                    \/\/ store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)$/;"	m	struct:ImGuiWindow
SetWindowSize	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowSize	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowSize	vendor/imgui/imgui.cpp	/^void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)$/;"	f	class:ImGui
SetWindowSizeAllowFlags	vendor/imgui/imgui_internal.h	/^    ImGuiCond               SetWindowSizeAllowFlags;            \/\/ store acceptable condition flags for SetNextWindowSize() use.$/;"	m	struct:ImGuiWindow
SettingsDirtyTimer	vendor/imgui/imgui_internal.h	/^    float                          SettingsDirtyTimer;          \/\/ Save .ini Settings to memory when time reaches zero$/;"	m	struct:ImGuiContext
SettingsHandlerWindow_ReadLine	vendor/imgui/imgui.cpp	/^static void SettingsHandlerWindow_ReadLine(ImGuiContext* ctx, ImGuiSettingsHandler*, void* entry, const char* line)$/;"	f	file:
SettingsHandlerWindow_ReadOpen	vendor/imgui/imgui.cpp	/^static void* SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)$/;"	f	file:
SettingsHandlerWindow_WriteAll	vendor/imgui/imgui.cpp	/^static void SettingsHandlerWindow_WriteAll(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)$/;"	f	file:
SettingsHandlers	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiSettingsHandler> SettingsHandlers;            \/\/ List of .ini settings handlers$/;"	m	struct:ImGuiContext
SettingsIdx	vendor/imgui/imgui_internal.h	/^    int                     SettingsIdx;                        \/\/ Index into SettingsWindow[] (indices are always valid as we only grow the array from the back)$/;"	m	struct:ImGuiWindow
SettingsIniData	vendor/imgui/imgui_internal.h	/^    ImGuiTextBuffer                SettingsIniData;             \/\/ In memory .ini settings$/;"	m	struct:ImGuiContext
SettingsLoaded	vendor/imgui/imgui_internal.h	/^    bool                           SettingsLoaded;$/;"	m	struct:ImGuiContext
SettingsWindows	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiWindowSettings>  SettingsWindows;             \/\/ ImGuiWindow .ini settings entries (parsed from the last loaded .ini file and maintained on saving)$/;"	m	struct:ImGuiContext
SetupDrawData	vendor/imgui/imgui.cpp	/^static void SetupDrawData(ImVector<ImDrawList*>* draw_lists, ImDrawData* draw_data)$/;"	f	file:
ShadeVertsLinearColorGradientKeepAlpha	vendor/imgui/imgui_draw.cpp	/^void ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)$/;"	f	class:ImGui
ShadeVertsLinearUV	vendor/imgui/imgui_draw.cpp	/^void ImGui::ShadeVertsLinearUV(ImDrawList* draw_list, int vert_start_idx, int vert_end_idx, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)$/;"	f	class:ImGui
Shader	Shader/Shader.cpp	/^Shader::Shader(const std::string& filepath) {$/;"	f	class:Shader
Shader	Shader/Shader.h	/^class Shader {$/;"	c
ShaderProgramSource	Shader/Shader.h	/^struct ShaderProgramSource{$/;"	s
ShowAboutWindow	vendor/imgui/imgui_demo.cpp	/^void ImGui::ShowAboutWindow(bool* p_open)$/;"	f	class:ImGui
ShowAboutWindow	vendor/imgui/imgui_demo.cpp	/^void ImGui::ShowAboutWindow(bool*) {}$/;"	f	class:ImGui
ShowDemoWindow	vendor/imgui/imgui_demo.cpp	/^void ImGui::ShowDemoWindow(bool* p_open)$/;"	f	class:ImGui
ShowDemoWindow	vendor/imgui/imgui_demo.cpp	/^void ImGui::ShowDemoWindow(bool*) {}$/;"	f	class:ImGui
ShowDemoWindowColumns	vendor/imgui/imgui_demo.cpp	/^static void ShowDemoWindowColumns()$/;"	f	file:
ShowDemoWindowLayout	vendor/imgui/imgui_demo.cpp	/^static void ShowDemoWindowLayout()$/;"	f	file:
ShowDemoWindowMisc	vendor/imgui/imgui_demo.cpp	/^static void ShowDemoWindowMisc()$/;"	f	file:
ShowDemoWindowPopups	vendor/imgui/imgui_demo.cpp	/^static void ShowDemoWindowPopups()$/;"	f	file:
ShowDemoWindowWidgets	vendor/imgui/imgui_demo.cpp	/^static void ShowDemoWindowWidgets()$/;"	f	file:
ShowExampleAppAutoResize	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppAutoResize(bool* p_open)$/;"	f	file:
ShowExampleAppConsole	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppConsole(bool* p_open)$/;"	f	file:
ShowExampleAppConstrainedResize	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppConstrainedResize(bool* p_open)$/;"	f	file:
ShowExampleAppCustomRendering	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppCustomRendering(bool* p_open)$/;"	f	file:
ShowExampleAppDocuments	vendor/imgui/imgui_demo.cpp	/^void ShowExampleAppDocuments(bool* p_open)$/;"	f
ShowExampleAppLayout	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppLayout(bool* p_open)$/;"	f	file:
ShowExampleAppLog	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppLog(bool* p_open)$/;"	f	file:
ShowExampleAppLongText	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppLongText(bool* p_open)$/;"	f	file:
ShowExampleAppMainMenuBar	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppMainMenuBar()$/;"	f	file:
ShowExampleAppPropertyEditor	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppPropertyEditor(bool* p_open)$/;"	f	file:
ShowExampleAppSimpleOverlay	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppSimpleOverlay(bool* p_open)$/;"	f	file:
ShowExampleAppWindowTitles	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleAppWindowTitles(bool*)$/;"	f	file:
ShowExampleMenuFile	vendor/imgui/imgui_demo.cpp	/^static void ShowExampleMenuFile()$/;"	f	file:
ShowFontSelector	vendor/imgui/imgui_demo.cpp	/^void ImGui::ShowFontSelector(const char* label)$/;"	f	class:ImGui
ShowMetricsWindow	vendor/imgui/imgui.cpp	/^void ImGui::ShowMetricsWindow(bool* p_open)$/;"	f	class:ImGui
ShowMetricsWindow	vendor/imgui/imgui.cpp	/^void ImGui::ShowMetricsWindow(bool*) { }$/;"	f	class:ImGui
ShowStyleEditor	vendor/imgui/imgui_demo.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle* ref)$/;"	f	class:ImGui
ShowStyleEditor	vendor/imgui/imgui_demo.cpp	/^void ImGui::ShowStyleEditor(ImGuiStyle*) {}$/;"	f	class:ImGui
ShowStyleSelector	vendor/imgui/imgui_demo.cpp	/^bool ImGui::ShowStyleSelector(const char* label)$/;"	f	class:ImGui
ShowTestWindow	vendor/imgui/imgui.h	/^    static inline void  ShowTestWindow()                      { return ShowDemoWindow(); }$/;"	f	namespace:ImGui
ShowUserGuide	vendor/imgui/imgui_demo.cpp	/^void ImGui::ShowUserGuide() {}$/;"	f	class:ImGui
ShowUserGuide	vendor/imgui/imgui_demo.cpp	/^void ImGui::ShowUserGuide()$/;"	f	class:ImGui
ShrinkWidthBuffer	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiShrinkWidthItem>  ShrinkWidthBuffer;$/;"	m	struct:ImGuiContext
ShrinkWidthItemComparer	vendor/imgui/imgui_widgets.cpp	/^static int IMGUI_CDECL ShrinkWidthItemComparer(const void* lhs, const void* rhs)$/;"	f	file:
ShrinkWidths	vendor/imgui/imgui_widgets.cpp	/^void ImGui::ShrinkWidths(ImGuiShrinkWidthItem* items, int count, float width_excess)$/;"	f	class:ImGui
Shutdown	vendor/imgui/imgui.cpp	/^void ImGui::Shutdown(ImGuiContext* context)$/;"	f	class:ImGui
Size	vendor/imgui/imgui.h	/^    int                 Size;$/;"	m	struct:ImVector
Size	vendor/imgui/imgui_internal.h	/^    ImVec2                  Size;                               \/\/ Current size (==SizeFull or collapsed title bar size)$/;"	m	struct:ImGuiWindow
Size	vendor/imgui/imgui_internal.h	/^    ImVec2      Size;$/;"	m	struct:ImGuiWindowSettings
Size	vendor/imgui/imgui_internal.h	/^    size_t      Size;           \/\/ Size in byte$/;"	m	struct:ImGuiDataTypeInfo
SizeCallback	vendor/imgui/imgui_internal.h	/^    ImGuiSizeCallback           SizeCallback;$/;"	m	struct:ImGuiNextWindowData
SizeCallbackUserData	vendor/imgui/imgui_internal.h	/^    void*                       SizeCallbackUserData;$/;"	m	struct:ImGuiNextWindowData
SizeCond	vendor/imgui/imgui_internal.h	/^    ImGuiCond                   SizeCond;$/;"	m	struct:ImGuiNextWindowData
SizeConstraintRect	vendor/imgui/imgui_internal.h	/^    ImRect                      SizeConstraintRect;$/;"	m	struct:ImGuiNextWindowData
SizeFull	vendor/imgui/imgui_internal.h	/^    ImVec2                  SizeFull;                           \/\/ Size when non collapsed$/;"	m	struct:ImGuiWindow
SizePixels	vendor/imgui/imgui.h	/^    float           SizePixels;             \/\/          \/\/ Size in pixels for rasterizer (more or less maps to the resulting font height).$/;"	m	struct:ImFontConfig
SizeVal	vendor/imgui/imgui_internal.h	/^    ImVec2                      SizeVal;$/;"	m	struct:ImGuiNextWindowData
SkipItems	vendor/imgui/imgui_internal.h	/^    bool                    SkipItems;                          \/\/ Set when items can safely be all clipped (e.g. window not visible or collapsed)$/;"	m	struct:ImGuiWindow
SliderAngle	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max, const char* format)$/;"	f	class:ImGui
SliderBehavior	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderBehavior(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)$/;"	f	class:ImGui
SliderBehaviorT	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderBehaviorT(const ImRect& bb, ImGuiID id, ImGuiDataType data_type, TYPE* v, const TYPE v_min, const TYPE v_max, const char* format, float power, ImGuiSliderFlags flags, ImRect* out_grab_bb)$/;"	f	class:ImGui
SliderCalcRatioFromValueT	vendor/imgui/imgui_widgets.cpp	/^float ImGui::SliderCalcRatioFromValueT(ImGuiDataType data_type, TYPE v, TYPE v_min, TYPE v_max, float power, float linear_zero_pos)$/;"	f	class:ImGui
SliderFloat	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* format, float power)$/;"	f	class:ImGui
SliderFloat2	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* format, float power)$/;"	f	class:ImGui
SliderFloat3	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* format, float power)$/;"	f	class:ImGui
SliderFloat4	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* format, float power)$/;"	f	class:ImGui
SliderInt	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* format)$/;"	f	class:ImGui
SliderInt2	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* format)$/;"	f	class:ImGui
SliderInt3	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* format)$/;"	f	class:ImGui
SliderInt4	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* format)$/;"	f	class:ImGui
SliderScalar	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderScalar(const char* label, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)$/;"	f	class:ImGui
SliderScalarN	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SliderScalarN(const char* label, ImGuiDataType data_type, void* v, int components, const void* v_min, const void* v_max, const char* format, float power)$/;"	f	class:ImGui
SmallButton	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SmallButton(const char* label)$/;"	f	class:ImGui
SourceId	vendor/imgui/imgui.h	/^    ImGuiID         SourceId;           \/\/ Source item id$/;"	m	struct:ImGuiPayload
SourceParentId	vendor/imgui/imgui.h	/^    ImGuiID         SourceParentId;     \/\/ Source parent id (if available)$/;"	m	struct:ImGuiPayload
SourceWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*        SourceWindow;   \/\/ Set on OpenPopup() copy of NavWindow at the time of opening the popup$/;"	m	struct:ImGuiPopupData
Spacing	vendor/imgui/imgui_internal.h	/^    float       Spacing;$/;"	m	struct:ImGuiMenuColumns
Spacing	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Spacing()$/;"	f	class:ImGui
Split	vendor/imgui/imgui_draw.cpp	/^void ImDrawListSplitter::Split(ImDrawList* draw_list, int channels_count)$/;"	f	class:ImDrawListSplitter
SplitterBehavior	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::SplitterBehavior(const ImRect& bb, ImGuiID id, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay)$/;"	f	class:ImGui
SrcCount	vendor/imgui/imgui_draw.cpp	/^    int                 SrcCount;           \/\/ Number of source fonts targeting this destination font.$/;"	m	struct:ImFontBuildDstData	file:
SrcRanges	vendor/imgui/imgui_draw.cpp	/^    const ImWchar*      SrcRanges;          \/\/ Ranges as requested by user (user is allowed to request too much, e.g. 0x0020..0xFFFF)$/;"	m	struct:ImFontBuildSrcData	file:
StackSizesBackup	vendor/imgui/imgui_internal.h	/^    short                   StackSizesBackup[6];    \/\/ Store size of various stacks for asserting$/;"	m	struct:ImGuiWindowTempData
StartLockWheelingWindow	vendor/imgui/imgui.cpp	/^static void StartLockWheelingWindow(ImGuiWindow* window)$/;"	f	file:
StartMouseMovingWindow	vendor/imgui/imgui.cpp	/^void ImGui::StartMouseMovingWindow(ImGuiWindow* window)$/;"	f	class:ImGui
StartPosY	vendor/imgui/imgui.h	/^    float   StartPosY;$/;"	m	struct:ImGuiListClipper
StateStorage	vendor/imgui/imgui_internal.h	/^    ImGuiStorage            StateStorage;$/;"	m	struct:ImGuiWindow
StateStorage	vendor/imgui/imgui_internal.h	/^    ImGuiStorage*           StateStorage;$/;"	m	struct:ImGuiWindowTempData
Stb	vendor/imgui/imgui_internal.h	/^    ImStb::STB_TexteditState Stb;                   \/\/ state for stb_textedit.h$/;"	m	struct:ImGuiInputTextState
StbFindState	vendor/imgui/imstb_textedit.h	/^} StbFindState;$/;"	t	typeref:struct:__anon52
StbTexteditRow	vendor/imgui/imstb_textedit.h	/^} StbTexteditRow;$/;"	t	typeref:struct:__anon51
StbUndoRecord	vendor/imgui/imstb_textedit.h	/^} StbUndoRecord;$/;"	t	typeref:struct:__anon48
StbUndoState	vendor/imgui/imstb_textedit.h	/^} StbUndoState;$/;"	t	typeref:struct:__anon49
Step	vendor/imgui/imgui.cpp	/^bool ImGuiListClipper::Step()$/;"	f	class:ImGuiListClipper
StepNo	vendor/imgui/imgui.h	/^    int     ItemsCount, StepNo, DisplayStart, DisplayEnd;$/;"	m	struct:ImGuiListClipper
Storage	vendor/imgui/imgui_internal.h	/^    ImVector<int>   Storage;$/;"	m	struct:ImBoolVector
Strdup	vendor/imgui/imgui_demo.cpp	/^    static char* Strdup(const char *str)                             { size_t len = strlen(str) + 1; void* buf = malloc(len); IM_ASSERT(buf); return (char*)memcpy(buf, (const void*)str, len); }$/;"	f	struct:ExampleAppConsole
Stricmp	vendor/imgui/imgui_demo.cpp	/^    static int   Stricmp(const char* str1, const char* str2)         { int d; while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; } return d; }$/;"	f	struct:ExampleAppConsole
Stride	vendor/imgui/imgui_widgets.cpp	/^    int Stride;$/;"	m	struct:ImGuiPlotArrayGetterData	file:
Strnicmp	vendor/imgui/imgui_demo.cpp	/^    static int   Strnicmp(const char* str1, const char* str2, int n) { int d = 0; while (n > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; n--; } return d; }$/;"	f	struct:ExampleAppConsole
Strtrim	vendor/imgui/imgui_demo.cpp	/^    static void  Strtrim(char* str)                                  { char* str_end = str + strlen(str); while (str_end > str && str_end[-1] == ' ') str_end--; *str_end = 0; }$/;"	f	struct:ExampleAppConsole
Stub	vendor/glm/detail/_swizzle.hpp	/^		struct Stub {};$/;"	s	struct:glm::detail::_swizzle_base2
Style	vendor/imgui/imgui_internal.h	/^    ImGuiStyle              Style;$/;"	m	struct:ImGuiContext
StyleColorsClassic	vendor/imgui/imgui_draw.cpp	/^void ImGui::StyleColorsClassic(ImGuiStyle* dst)$/;"	f	class:ImGui
StyleColorsDark	vendor/imgui/imgui_draw.cpp	/^void ImGui::StyleColorsDark(ImGuiStyle* dst)$/;"	f	class:ImGui
StyleColorsLight	vendor/imgui/imgui_draw.cpp	/^void ImGui::StyleColorsLight(ImGuiStyle* dst)$/;"	f	class:ImGui
StyleModifiers	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiStyleMod> StyleModifiers;                     \/\/ Stack for PushStyleVar()\/PopStyleVar()$/;"	m	struct:ImGuiContext
TabBarCalcMaxTabWidth	vendor/imgui/imgui_widgets.cpp	/^static float ImGui::TabBarCalcMaxTabWidth()$/;"	f	class:ImGui
TabBarCalcTabID	vendor/imgui/imgui_widgets.cpp	/^static ImU32   ImGui::TabBarCalcTabID(ImGuiTabBar* tab_bar, const char* label)$/;"	f	class:ImGui
TabBarCloseTab	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TabBarCloseTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)$/;"	f	class:ImGui
TabBarFindTabByID	vendor/imgui/imgui_widgets.cpp	/^ImGuiTabItem* ImGui::TabBarFindTabByID(ImGuiTabBar* tab_bar, ImGuiID tab_id)$/;"	f	class:ImGui
TabBarLayout	vendor/imgui/imgui_widgets.cpp	/^static void ImGui::TabBarLayout(ImGuiTabBar* tab_bar)$/;"	f	class:ImGui
TabBarQueueChangeTabOrder	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TabBarQueueChangeTabOrder(ImGuiTabBar* tab_bar, const ImGuiTabItem* tab, int dir)$/;"	f	class:ImGui
TabBarRemoveTab	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TabBarRemoveTab(ImGuiTabBar* tab_bar, ImGuiID tab_id)$/;"	f	class:ImGui
TabBarScrollClamp	vendor/imgui/imgui_widgets.cpp	/^static float ImGui::TabBarScrollClamp(ImGuiTabBar* tab_bar, float scrolling)$/;"	f	class:ImGui
TabBarScrollToTab	vendor/imgui/imgui_widgets.cpp	/^static void ImGui::TabBarScrollToTab(ImGuiTabBar* tab_bar, ImGuiTabItem* tab)$/;"	f	class:ImGui
TabBarScrollingButtons	vendor/imgui/imgui_widgets.cpp	/^static ImGuiTabItem* ImGui::TabBarScrollingButtons(ImGuiTabBar* tab_bar)$/;"	f	class:ImGui
TabBarTabListPopupButton	vendor/imgui/imgui_widgets.cpp	/^static ImGuiTabItem* ImGui::TabBarTabListPopupButton(ImGuiTabBar* tab_bar)$/;"	f	class:ImGui
TabBars	vendor/imgui/imgui_internal.h	/^    ImPool<ImGuiTabBar>             TabBars;$/;"	m	struct:ImGuiContext
TabBorderSize	vendor/imgui/imgui.h	/^    float       TabBorderSize;              \/\/ Thickness of border around tabs.$/;"	m	struct:ImGuiStyle
TabItemBackground	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TabItemBackground(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImU32 col)$/;"	f	class:ImGui
TabItemCalcSize	vendor/imgui/imgui_widgets.cpp	/^ImVec2 ImGui::TabItemCalcSize(const char* label, bool has_close_button)$/;"	f	class:ImGui
TabItemComparerByVisibleOffset	vendor/imgui/imgui_widgets.cpp	/^static int IMGUI_CDECL TabItemComparerByVisibleOffset(const void* lhs, const void* rhs)$/;"	f	file:
TabItemEx	vendor/imgui/imgui_widgets.cpp	/^bool    ImGui::TabItemEx(ImGuiTabBar* tab_bar, const char* label, bool* p_open, ImGuiTabItemFlags flags)$/;"	f	class:ImGui
TabItemLabelAndCloseButton	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TabItemLabelAndCloseButton(ImDrawList* draw_list, const ImRect& bb, ImGuiTabItemFlags flags, ImVec2 frame_padding, const char* label, ImGuiID tab_id, ImGuiID close_button_id)$/;"	f	class:ImGui
TabRounding	vendor/imgui/imgui.h	/^    float       TabRounding;                \/\/ Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.$/;"	m	struct:ImGuiStyle
Tabs	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiTabItem> Tabs;$/;"	m	struct:ImGuiTabBar
TabsNames	vendor/imgui/imgui_internal.h	/^    ImGuiTextBuffer     TabsNames;              \/\/ For non-docking tab bar we re-append names in a contiguous buffer.$/;"	m	struct:ImGuiTabBar
TempBuffer	vendor/imgui/imgui_internal.h	/^    char                    TempBuffer[1024*3+1];               \/\/ Temporary text buffer$/;"	m	struct:ImGuiContext
TempInputTextId	vendor/imgui/imgui_internal.h	/^    ImGuiID                 TempInputTextId;                    \/\/ Temporary text input when CTRL+clicking on a slider, etc.$/;"	m	struct:ImGuiContext
TempInputTextIsActive	vendor/imgui/imgui_internal.h	/^    inline bool             TempInputTextIsActive(ImGuiID id) { ImGuiContext& g = *GImGui; return (g.ActiveId == id && g.TempInputTextId == id); }$/;"	f	namespace:ImGui
TempInputTextScalar	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TempInputTextScalar(const ImRect& bb, ImGuiID id, const char* label, ImGuiDataType data_type, void* data_ptr, const char* format)$/;"	f	class:ImGui
TexDesiredWidth	vendor/imgui/imgui.h	/^    int                         TexDesiredWidth;    \/\/ Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.$/;"	m	struct:ImFontAtlas
TexGlyphPadding	vendor/imgui/imgui.h	/^    int                         TexGlyphPadding;    \/\/ Padding between glyphs within texture in pixels. Defaults to 1. If your rendering method doesn't rely on bilinear filtering you may set this to 0.$/;"	m	struct:ImFontAtlas
TexHeight	vendor/imgui/imgui.h	/^    int                         TexHeight;          \/\/ Texture height calculated during Build().$/;"	m	struct:ImFontAtlas
TexID	vendor/imgui/imgui.h	/^    ImTextureID                 TexID;              \/\/ User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.$/;"	m	struct:ImFontAtlas
TexPixelsAlpha8	vendor/imgui/imgui.h	/^    unsigned char*              TexPixelsAlpha8;    \/\/ 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight$/;"	m	struct:ImFontAtlas
TexPixelsRGBA32	vendor/imgui/imgui.h	/^    unsigned int*               TexPixelsRGBA32;    \/\/ 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4$/;"	m	struct:ImFontAtlas
TexUvScale	vendor/imgui/imgui.h	/^    ImVec2                      TexUvScale;         \/\/ = (1.0f\/TexWidth, 1.0f\/TexHeight)$/;"	m	struct:ImFontAtlas
TexUvWhitePixel	vendor/imgui/imgui.h	/^    ImVec2                      TexUvWhitePixel;    \/\/ Texture coordinates to a white pixel$/;"	m	struct:ImFontAtlas
TexUvWhitePixel	vendor/imgui/imgui_internal.h	/^    ImVec2          TexUvWhitePixel;            \/\/ UV of white pixel in the atlas$/;"	m	struct:ImDrawListSharedData
TexWidth	vendor/imgui/imgui.h	/^    int                         TexWidth;           \/\/ Texture width calculated during Build().$/;"	m	struct:ImFontAtlas
Text	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Text(const char* fmt, ...)$/;"	f	class:ImGui
TextA	vendor/imgui/imgui_internal.h	/^    ImVector<char>          TextA;                  \/\/ temporary UTF8 buffer for callbacks and other operations. this is not updated in every code-path! size=capacity.$/;"	m	struct:ImGuiInputTextState
TextAIsValid	vendor/imgui/imgui_internal.h	/^    bool                    TextAIsValid;           \/\/ temporary UTF8 buffer is not initially valid before we make the widget active (until then we pull the data from user argument)$/;"	m	struct:ImGuiInputTextState
TextColored	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)$/;"	f	class:ImGui
TextColoredV	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)$/;"	f	class:ImGui
TextDisabled	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TextDisabled(const char* fmt, ...)$/;"	f	class:ImGui
TextDisabledV	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TextDisabledV(const char* fmt, va_list args)$/;"	f	class:ImGui
TextEditCallback	vendor/imgui/imgui_demo.cpp	/^    int     TextEditCallback(ImGuiInputTextCallbackData* data)$/;"	f	struct:ExampleAppConsole
TextEditCallbackStub	vendor/imgui/imgui_demo.cpp	/^    static int TextEditCallbackStub(ImGuiInputTextCallbackData* data) \/\/ In C++11 you are better off using lambdas for this sort of forwarding callbacks$/;"	f	struct:ExampleAppConsole
TextEx	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TextEx(const char* text, const char* text_end, ImGuiTextFlags flags)$/;"	f	class:ImGui
TextUnformatted	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TextUnformatted(const char* text, const char* text_end)$/;"	f	class:ImGui
TextV	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TextV(const char* fmt, va_list args)$/;"	f	class:ImGui
TextW	vendor/imgui/imgui_internal.h	/^    ImVector<ImWchar>       TextW;                  \/\/ edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.$/;"	m	struct:ImGuiInputTextState
TextWrapPos	vendor/imgui/imgui_internal.h	/^    float                   TextWrapPos;            \/\/ == TextWrapPosStack.back() [empty == -1.0f]$/;"	m	struct:ImGuiWindowTempData
TextWrapPosStack	vendor/imgui/imgui_internal.h	/^    ImVector<float>         TextWrapPosStack;$/;"	m	struct:ImGuiWindowTempData
TextWrapped	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TextWrapped(const char* fmt, ...)$/;"	f	class:ImGui
TextWrappedV	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TextWrappedV(const char* fmt, va_list args)$/;"	f	class:ImGui
Texture	Texture/Texture.cpp	/^Texture::Texture(const std::string& path){$/;"	f	class:Texture
Texture	Texture/Texture.h	/^class Texture {$/;"	c
TextureId	vendor/imgui/imgui.h	/^    ImTextureID     TextureId;              \/\/ User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.$/;"	m	struct:ImDrawCmd
Time	vendor/imgui/imgui_internal.h	/^    double                  Time;$/;"	m	struct:ImGuiContext
TitleBarHeight	vendor/imgui/imgui_internal.h	/^    float       TitleBarHeight() const      { ImGuiContext& g = *GImGui; return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + g.Style.FramePadding.y * 2.0f; }$/;"	f	struct:ImGuiWindow
TitleBarRect	vendor/imgui/imgui_internal.h	/^    ImRect      TitleBarRect() const        { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }$/;"	f	struct:ImGuiWindow
TooltipOverrideCount	vendor/imgui/imgui_internal.h	/^    int                     TooltipOverrideCount;$/;"	m	struct:ImGuiContext
TotalIdxCount	vendor/imgui/imgui.h	/^    int             TotalIdxCount;          \/\/ For convenience, sum of all ImDrawList's IdxBuffer.Size$/;"	m	struct:ImDrawData
TotalVtxCount	vendor/imgui/imgui.h	/^    int             TotalVtxCount;          \/\/ For convenience, sum of all ImDrawList's VtxBuffer.Size$/;"	m	struct:ImDrawData
TouchExtraPadding	vendor/imgui/imgui.h	/^    ImVec2      TouchExtraPadding;          \/\/ Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!$/;"	m	struct:ImGuiStyle
Translate	vendor/imgui/imgui_internal.h	/^    void        Translate(const ImVec2& d)          { Min.x += d.x; Min.y += d.y; Max.x += d.x; Max.y += d.y; }$/;"	f	struct:ImRect
TranslateX	vendor/imgui/imgui_internal.h	/^    void        TranslateX(float dx)                { Min.x += dx; Max.x += dx; }$/;"	f	struct:ImRect
TranslateY	vendor/imgui/imgui_internal.h	/^    void        TranslateY(float dy)                { Min.y += dy; Max.y += dy; }$/;"	f	struct:ImRect
TreeAdvanceToLabelPos	vendor/imgui/imgui.h	/^    static inline void  TreeAdvanceToLabelPos()               { SetCursorPosX(GetCursorPosX() + GetTreeNodeToLabelSpacing()); }$/;"	f	namespace:ImGui
TreeDepth	vendor/imgui/imgui_internal.h	/^    int                     TreeDepth;$/;"	m	struct:ImGuiWindowTempData
TreeNode	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNode(const char* label)$/;"	f	class:ImGui
TreeNode	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)$/;"	f	class:ImGui
TreeNode	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)$/;"	f	class:ImGui
TreeNodeBehavior	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)$/;"	f	class:ImGui
TreeNodeBehaviorIsOpen	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui
TreeNodeEx	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)$/;"	f	class:ImGui
TreeNodeEx	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)$/;"	f	class:ImGui
TreeNodeEx	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)$/;"	f	class:ImGui
TreeNodeExV	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)$/;"	f	class:ImGui
TreeNodeExV	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)$/;"	f	class:ImGui
TreeNodeV	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)$/;"	f	class:ImGui
TreeNodeV	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)$/;"	f	class:ImGui
TreePop	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TreePop()$/;"	f	class:ImGui
TreePush	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TreePush(const char* str_id)$/;"	f	class:ImGui
TreePush	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TreePush(const void* ptr_id)$/;"	f	class:ImGui
TreePushOverrideID	vendor/imgui/imgui_widgets.cpp	/^void ImGui::TreePushOverrideID(ImGuiID id)$/;"	f	class:ImGui
TreeStoreMayJumpToParentOnPop	vendor/imgui/imgui_internal.h	/^    ImU32                   TreeStoreMayJumpToParentOnPop; \/\/ Store a copy of !g.NavIdIsAlive for TreeDepth 0..31.. Could be turned into a ImU64 if necessary.$/;"	m	struct:ImGuiWindowTempData
Type	vendor/imgui/imgui.cpp	/^    ImGuiDataType   Type;$/;"	m	struct:ImGuiStyleVarInfo	file:
TypeHash	vendor/imgui/imgui_internal.h	/^    ImGuiID     TypeHash;       \/\/ == ImHashStr(TypeName)$/;"	m	struct:ImGuiSettingsHandler
TypeName	vendor/imgui/imgui_internal.h	/^    const char* TypeName;       \/\/ Short description stored in .ini file. Disallowed characters: '[' ']'$/;"	m	struct:ImGuiSettingsHandler
U0	vendor/imgui/imgui.h	/^    float           U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFontGlyph
U1	vendor/imgui/imgui.h	/^    float           U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFontGlyph
Unbind	IndexBuffer/IndexBuffer.cpp	/^void IndexBuffer::Unbind() const {$/;"	f	class:IndexBuffer
Unbind	Shader/Shader.cpp	/^void Shader::Unbind() const {$/;"	f	class:Shader
Unbind	Texture/Texture.cpp	/^void Texture::Unbind() const {$/;"	f	class:Texture
Unbind	VertexArray/VertexArray.cpp	/^void VertexArray::Unbind() const {$/;"	f	class:VertexArray
Unbind	VertexBuffer/VertexBuffer.cpp	/^void VertexBuffer::Unbind() const {$/;"	f	class:VertexBuffer
Unindent	vendor/imgui/imgui.cpp	/^void ImGui::Unindent(float indent_w)$/;"	f	class:ImGui
UnpackAccumulativeOffsetsIntoRanges	vendor/imgui/imgui_draw.cpp	/^static void UnpackAccumulativeOffsetsIntoRanges(int base_codepoint, const short* accumulative_offsets, int accumulative_offsets_count, ImWchar* out_ranges)$/;"	f	file:
UnpackBoolVectorToFlatIndexList	vendor/imgui/imgui_draw.cpp	/^static void UnpackBoolVectorToFlatIndexList(const ImBoolVector* in, ImVector<int>* out)$/;"	f	file:
Update	vendor/imgui/imgui_widgets.cpp	/^void ImGuiMenuColumns::Update(int count, float spacing, bool clear)$/;"	f	class:ImGuiMenuColumns
UpdateClipRect	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::UpdateClipRect()$/;"	f	class:ImDrawList
UpdateDebugToolItemPicker	vendor/imgui/imgui.cpp	/^void ImGui::UpdateDebugToolItemPicker()$/;"	f	class:ImGui
UpdateHoveredWindowAndCaptureFlags	vendor/imgui/imgui.cpp	/^void ImGui::UpdateHoveredWindowAndCaptureFlags()$/;"	f	class:ImGui
UpdateManualResize	vendor/imgui/imgui.cpp	/^static bool ImGui::UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4])$/;"	f	class:ImGui
UpdateMouseInputs	vendor/imgui/imgui.cpp	/^static void ImGui::UpdateMouseInputs()$/;"	f	class:ImGui
UpdateMouseMovingWindowEndFrame	vendor/imgui/imgui.cpp	/^void ImGui::UpdateMouseMovingWindowEndFrame()$/;"	f	class:ImGui
UpdateMouseMovingWindowNewFrame	vendor/imgui/imgui.cpp	/^void ImGui::UpdateMouseMovingWindowNewFrame()$/;"	f	class:ImGui
UpdateMouseWheel	vendor/imgui/imgui.cpp	/^void ImGui::UpdateMouseWheel()$/;"	f	class:ImGui
UpdateTextureID	vendor/imgui/imgui_draw.cpp	/^void ImDrawList::UpdateTextureID()$/;"	f	class:ImDrawList
UpdateWindowParentAndRootLinks	vendor/imgui/imgui.cpp	/^void ImGui::UpdateWindowParentAndRootLinks(ImGuiWindow* window, ImGuiWindowFlags flags, ImGuiWindow* parent_window)$/;"	f	class:ImGui
UsedChars	vendor/imgui/imgui.h	/^    ImVector<ImU32> UsedChars;            \/\/ Store 1-bit per Unicode code point (0=unused, 1=used)$/;"	m	struct:ImFontGlyphRangesBuilder
UserCallback	vendor/imgui/imgui.h	/^    ImDrawCallback  UserCallback;           \/\/ If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.$/;"	m	struct:ImDrawCmd
UserCallback	vendor/imgui/imgui_internal.h	/^    ImGuiInputTextCallback  UserCallback;           \/\/ "$/;"	m	struct:ImGuiInputTextState
UserCallbackData	vendor/imgui/imgui.h	/^    void*           UserCallbackData;       \/\/ The draw callback code can access this.$/;"	m	struct:ImDrawCmd
UserCallbackData	vendor/imgui/imgui_internal.h	/^    void*                   UserCallbackData;       \/\/ "$/;"	m	struct:ImGuiInputTextState
UserData	vendor/imgui/imgui.h	/^    void*               UserData;       \/\/ What user passed to InputText()      \/\/ Read-only$/;"	m	struct:ImGuiInputTextCallbackData
UserData	vendor/imgui/imgui.h	/^    void*       UserData;                       \/\/ = NULL           \/\/ Store your own data for retrieval by callbacks.$/;"	m	struct:ImGuiIO
UserData	vendor/imgui/imgui.h	/^    void*   UserData;       \/\/ Read-only.   What user passed to SetNextWindowSizeConstraints()$/;"	m	struct:ImGuiSizeCallbackData
UserData	vendor/imgui/imgui_internal.h	/^    void*       UserData;$/;"	m	struct:ImGuiSettingsHandler
UserFlags	vendor/imgui/imgui_internal.h	/^    ImGuiInputTextFlags     UserFlags;              \/\/ Temporarily set while we call user's callback$/;"	m	struct:ImGuiInputTextState
V0	vendor/imgui/imgui.h	/^    float           U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFontGlyph
V1	vendor/imgui/imgui.h	/^    float           U0, V0, U1, V1;     \/\/ Texture coordinates$/;"	m	struct:ImFontGlyph
VSliderFloat	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* format, float power)$/;"	f	class:ImGui
VSliderInt	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* format)$/;"	f	class:ImGui
VSliderScalar	vendor/imgui/imgui_widgets.cpp	/^bool ImGui::VSliderScalar(const char* label, const ImVec2& size, ImGuiDataType data_type, void* v, const void* v_min, const void* v_max, const char* format, float power)$/;"	f	class:ImGui
Valid	vendor/imgui/imgui.h	/^    bool            Valid;                  \/\/ Only valid after Render() is called and before the next NewFrame() is called.$/;"	m	struct:ImDrawData
Value	vendor/imgui/imgui.h	/^    ImVec4              Value;$/;"	m	struct:ImColor
Value	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Value(const char* prefix, bool b)$/;"	f	class:ImGui
Value	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Value(const char* prefix, float v, const char* float_format)$/;"	f	class:ImGui
Value	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Value(const char* prefix, int v)$/;"	f	class:ImGui
Value	vendor/imgui/imgui_widgets.cpp	/^void ImGui::Value(const char* prefix, unsigned int v)$/;"	f	class:ImGui
Values	vendor/imgui/imgui_widgets.cpp	/^    const float* Values;$/;"	m	struct:ImGuiPlotArrayGetterData	file:
VarIdx	vendor/imgui/imgui_internal.h	/^    ImGuiStyleVar   VarIdx;$/;"	m	struct:ImGuiStyleMod
VertexArray	VertexArray/VertexArray.cpp	/^VertexArray::VertexArray(){$/;"	f	class:VertexArray
VertexArray	VertexArray/VertexArray.h	/^class VertexArray{$/;"	c
VertexBuffer	VertexBuffer/VertexBuffer.cpp	/^VertexBuffer::VertexBuffer(const void* data, unsigned int  size){$/;"	f	class:VertexBuffer
VertexBuffer	VertexBuffer/VertexBuffer.h	/^class VertexBuffer{$/;"	c
VertexBufferLayout	VertexBufferLayout/VertexBufferLayout.h	/^	VertexBufferLayout()$/;"	f	class:VertexBufferLayout
VertexBufferLayout	VertexBufferLayout/VertexBufferLayout.h	/^class VertexBufferLayout{$/;"	c
VertexBufferLayoutElement	VertexBufferLayout/VertexBufferLayout.h	/^struct VertexBufferLayoutElement{$/;"	s
VertexSource	Shader/Shader.h	/^	std::string VertexSource;$/;"	m	struct:ShaderProgramSource
VisibleTabId	vendor/imgui/imgui_internal.h	/^    ImGuiID             VisibleTabId;           \/\/ Can occasionally be != SelectedTabId (e.g. when previewing contents for CTRL+TAB preview)$/;"	m	struct:ImGuiTabBar
VisibleTabWasSubmitted	vendor/imgui/imgui_internal.h	/^    bool                VisibleTabWasSubmitted;$/;"	m	struct:ImGuiTabBar
VtxBuffer	vendor/imgui/imgui.h	/^    ImVector<ImDrawVert>    VtxBuffer;          \/\/ Vertex buffer.$/;"	m	struct:ImDrawList
VtxOffset	vendor/imgui/imgui.h	/^    unsigned int    VtxOffset;              \/\/ Start offset in vertex buffer. Pre-1.71 or without ImGuiBackendFlags_RendererHasVtxOffset: always 0. With ImGuiBackendFlags_RendererHasVtxOffset: may be >0 to support meshes larger than 64K vertices with 16-bits indices.$/;"	m	struct:ImDrawCmd
WIN32_LEAN_AND_MEAN	vendor/imgui/imgui.cpp	9512;"	d	file:
WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER	vendor/imgui/imgui.cpp	/^static const float WINDOWS_MOUSE_WHEEL_SCROLL_LOCK_TIMER    = 2.00f;    \/\/ Lock scrolled window (so it doesn't pick child windows that are scrolling through) for a certaint time, unless mouse moved.$/;"	v	file:
WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER	vendor/imgui/imgui.cpp	/^static const float WINDOWS_RESIZE_FROM_EDGES_FEEDBACK_TIMER = 0.04f;    \/\/ Reduce visual noise by only highlighting the border after a certain time.$/;"	v	file:
WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS	vendor/imgui/imgui.cpp	/^static const float WINDOWS_RESIZE_FROM_EDGES_HALF_THICKNESS = 4.0f;     \/\/ Extend outside and inside windows. Affect FindHoveredWindow().$/;"	v	file:
WantCaptureKeyboard	vendor/imgui/imgui.h	/^    bool        WantCaptureKeyboard;            \/\/ When io.WantCaptureKeyboard is true, imgui will use the keyboard inputs, do not dispatch them to your main game\/application (in both cases, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).$/;"	m	struct:ImGuiIO
WantCaptureKeyboardNextFrame	vendor/imgui/imgui_internal.h	/^    int                     WantCaptureKeyboardNextFrame;$/;"	m	struct:ImGuiContext
WantCaptureMouse	vendor/imgui/imgui.h	/^    bool        WantCaptureMouse;               \/\/ When io.WantCaptureMouse is true, imgui will use the mouse inputs, do not dispatch them to your main game\/application (in both cases, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).$/;"	m	struct:ImGuiIO
WantCaptureMouseNextFrame	vendor/imgui/imgui_internal.h	/^    int                     WantCaptureMouseNextFrame;          \/\/ Explicit capture via CaptureKeyboardFromApp()\/CaptureMouseFromApp() sets those flags$/;"	m	struct:ImGuiContext
WantClose	vendor/imgui/imgui_demo.cpp	/^    bool        WantClose;      \/\/ Set when the document$/;"	m	struct:MyDocument	file:
WantCollapseToggle	vendor/imgui/imgui_internal.h	/^    bool                    WantCollapseToggle;$/;"	m	struct:ImGuiWindow
WantLayout	vendor/imgui/imgui_internal.h	/^    bool                WantLayout;$/;"	m	struct:ImGuiTabBar
WantSaveIniSettings	vendor/imgui/imgui.h	/^    bool        WantSaveIniSettings;            \/\/ When manual .ini load\/save is active (io.IniFilename == NULL), this will be set to notify your application that you can call SaveIniSettingsToMemory() and save yourself. IMPORTANT: You need to clear io.WantSaveIniSettings yourself.$/;"	m	struct:ImGuiIO
WantSetMousePos	vendor/imgui/imgui.h	/^    bool        WantSetMousePos;                \/\/ MousePos has been altered, back-end should reposition mouse on next frame. Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.$/;"	m	struct:ImGuiIO
WantTextInput	vendor/imgui/imgui.h	/^    bool        WantTextInput;                  \/\/ Mobile\/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).$/;"	m	struct:ImGuiIO
WantTextInputNextFrame	vendor/imgui/imgui_internal.h	/^    int                     WantTextInputNextFrame;$/;"	m	struct:ImGuiContext
WasActive	vendor/imgui/imgui_internal.h	/^    bool                    WasActive;$/;"	m	struct:ImGuiWindow
WheelingWindow	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*            WheelingWindow;$/;"	m	struct:ImGuiContext
WheelingWindowRefMousePos	vendor/imgui/imgui_internal.h	/^    ImVec2                  WheelingWindowRefMousePos;$/;"	m	struct:ImGuiContext
WheelingWindowTimer	vendor/imgui/imgui_internal.h	/^    float                   WheelingWindowTimer;$/;"	m	struct:ImGuiContext
Width	vendor/imgui/imgui.h	/^    unsigned short  Width, Height;  \/\/ Input    \/\/ Desired rectangle dimension$/;"	m	struct:ImFontAtlasCustomRect
Width	vendor/imgui/imgui_internal.h	/^    float                       Width;          \/\/ Set by SetNextItemWidth().$/;"	m	struct:ImGuiNextItemData
Width	vendor/imgui/imgui_internal.h	/^    float               Width;                  \/\/ Width currently displayed$/;"	m	struct:ImGuiTabItem
Width	vendor/imgui/imgui_internal.h	/^    float           Width;$/;"	m	struct:ImGuiShrinkWidthItem
Width	vendor/imgui/imgui_internal.h	/^    float       Width, NextWidth;$/;"	m	struct:ImGuiMenuColumns
WidthContents	vendor/imgui/imgui_internal.h	/^    float               WidthContents;          \/\/ Width of actual contents, stored during BeginTabItem() call$/;"	m	struct:ImGuiTabItem
Window	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*        Window;         \/\/ Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()$/;"	m	struct:ImGuiPopupData
Window	vendor/imgui/imgui_internal.h	/^    ImGuiWindow*  Window;       \/\/ Best candidate window$/;"	m	struct:ImGuiNavMoveResult
WindowBorderSize	vendor/imgui/imgui.h	/^    float       WindowBorderSize;           \/\/ Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU\/GPU costly).$/;"	m	struct:ImGuiStyle
WindowBorderSize	vendor/imgui/imgui_internal.h	/^    float                   WindowBorderSize;                   \/\/ Window border size at the time of begin.$/;"	m	struct:ImGuiWindow
WindowMenuButtonPosition	vendor/imgui/imgui.h	/^    ImGuiDir    WindowMenuButtonPosition;   \/\/ Side of the collapsing\/docking button in the title bar (left\/right). Defaults to ImGuiDir_Left.$/;"	m	struct:ImGuiStyle
WindowMinSize	vendor/imgui/imgui.h	/^    ImVec2      WindowMinSize;              \/\/ Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().$/;"	m	struct:ImGuiStyle
WindowPadding	vendor/imgui/imgui.h	/^    ImVec2      WindowPadding;              \/\/ Padding within a window.$/;"	m	struct:ImGuiStyle
WindowPadding	vendor/imgui/imgui_internal.h	/^    ImVec2                  WindowPadding;                      \/\/ Window padding at the time of begin.$/;"	m	struct:ImGuiWindow
WindowRounding	vendor/imgui/imgui.h	/^    float       WindowRounding;             \/\/ Radius of window corners rounding. Set to 0.0f to have rectangular windows.$/;"	m	struct:ImGuiStyle
WindowRounding	vendor/imgui/imgui_internal.h	/^    float                   WindowRounding;                     \/\/ Window rounding at the time of begin.$/;"	m	struct:ImGuiWindow
WindowTitleAlign	vendor/imgui/imgui.h	/^    ImVec2      WindowTitleAlign;           \/\/ Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.$/;"	m	struct:ImGuiStyle
Windows	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiWindow*>  Windows;                            \/\/ Windows, sorted in display order, back to front$/;"	m	struct:ImGuiContext
WindowsActiveCount	vendor/imgui/imgui_internal.h	/^    int                     WindowsActiveCount;$/;"	m	struct:ImGuiContext
WindowsById	vendor/imgui/imgui_internal.h	/^    ImGuiStorage            WindowsById;$/;"	m	struct:ImGuiContext
WindowsFocusOrder	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiWindow*>  WindowsFocusOrder;                  \/\/ Windows, sorted in focus order, back to front$/;"	m	struct:ImGuiContext
WindowsSortBuffer	vendor/imgui/imgui_internal.h	/^    ImVector<ImGuiWindow*>  WindowsSortBuffer;$/;"	m	struct:ImGuiContext
WorkRect	vendor/imgui/imgui_internal.h	/^    ImRect                  WorkRect;                           \/\/ Cover the whole scrolling region, shrunk by WindowPadding*1.0f on each side. This is meant to replace ContentsRegionRect over time (from 1.71+ onward).$/;"	m	struct:ImGuiWindow
WriteAccessed	vendor/imgui/imgui_internal.h	/^    bool                    WriteAccessed;                      \/\/ Set to true when any widget access the current window$/;"	m	struct:ImGuiWindow
WriteAllFn	vendor/imgui/imgui_internal.h	/^    void        (*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);      \/\/ Write: Output every entries into 'out_buf'$/;"	m	struct:ImGuiSettingsHandler
X	vendor/imgui/imgui.h	/^    unsigned short  X, Y;           \/\/ Output   \/\/ Packed position in Atlas$/;"	m	struct:ImFontAtlasCustomRect
X0	vendor/imgui/imgui.h	/^    float           X0, Y0, X1, Y1;     \/\/ Glyph corners$/;"	m	struct:ImFontGlyph
X1	vendor/imgui/imgui.h	/^    float           X0, Y0, X1, Y1;     \/\/ Glyph corners$/;"	m	struct:ImFontGlyph
Y	vendor/imgui/imgui.h	/^    unsigned short  X, Y;           \/\/ Output   \/\/ Packed position in Atlas$/;"	m	struct:ImFontAtlasCustomRect
Y0	vendor/imgui/imgui.h	/^    float           X0, Y0, X1, Y1;     \/\/ Glyph corners$/;"	m	struct:ImFontGlyph
Y1	vendor/imgui/imgui.h	/^    float           X0, Y0, X1, Y1;     \/\/ Glyph corners$/;"	m	struct:ImFontGlyph
YCbCr_to_RGB_kernel	vendor/stb_image/stb_image.h	/^   void (*YCbCr_to_RGB_kernel)(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step);$/;"	m	struct:__anon61
_CRT_SECURE_NO_WARNINGS	vendor/imgui/imgui.cpp	982;"	d	file:
_CRT_SECURE_NO_WARNINGS	vendor/imgui/imgui_demo.cpp	57;"	d	file:
_CRT_SECURE_NO_WARNINGS	vendor/imgui/imgui_draw.cpp	26;"	d	file:
_CRT_SECURE_NO_WARNINGS	vendor/imgui/imgui_impl_opengl3.cpp	63;"	d	file:
_CRT_SECURE_NO_WARNINGS	vendor/imgui/imgui_widgets.cpp	32;"	d	file:
_Channels	vendor/imgui/imgui.h	/^    ImVector<ImDrawChannel>     _Channels;   \/\/ Draw channels (not resized down so _Count might be < Channels.Size)$/;"	m	struct:ImDrawListSplitter
_ClipRectStack	vendor/imgui/imgui.h	/^    ImVector<ImVec4>        _ClipRectStack;     \/\/ [Internal]$/;"	m	struct:ImDrawList
_CmdBuffer	vendor/imgui/imgui.h	/^    ImVector<ImDrawCmd>         _CmdBuffer;$/;"	m	struct:ImDrawChannel
_Count	vendor/imgui/imgui.h	/^    int                         _Count;      \/\/ Number of active channels (1+)$/;"	m	struct:ImDrawListSplitter
_Current	vendor/imgui/imgui.h	/^    int                         _Current;    \/\/ Current channel number (0)$/;"	m	struct:ImDrawListSplitter
_Data	vendor/imgui/imgui.h	/^    const ImDrawListSharedData* _Data;          \/\/ Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)$/;"	m	struct:ImDrawList
_IdxBuffer	vendor/imgui/imgui.h	/^    ImVector<ImDrawIdx>         _IdxBuffer;$/;"	m	struct:ImDrawChannel
_IdxWritePtr	vendor/imgui/imgui.h	/^    ImDrawIdx*              _IdxWritePtr;       \/\/ [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList
_OwnerName	vendor/imgui/imgui.h	/^    const char*             _OwnerName;         \/\/ Pointer to owner window's name for debugging$/;"	m	struct:ImDrawList
_Path	vendor/imgui/imgui.h	/^    ImVector<ImVec2>        _Path;              \/\/ [Internal] current path building$/;"	m	struct:ImDrawList
_Splitter	vendor/imgui/imgui.h	/^    ImDrawListSplitter      _Splitter;          \/\/ [Internal] for channels api$/;"	m	struct:ImDrawList
_TextureIdStack	vendor/imgui/imgui.h	/^    ImVector<ImTextureID>   _TextureIdStack;    \/\/ [Internal]$/;"	m	struct:ImDrawList
_VtxCurrentIdx	vendor/imgui/imgui.h	/^    unsigned int            _VtxCurrentIdx;     \/\/ [Internal] Generally == VtxBuffer.Size unless we are past 64K vertices, in which case this gets reset to 0.$/;"	m	struct:ImDrawList
_VtxCurrentOffset	vendor/imgui/imgui.h	/^    unsigned int            _VtxCurrentOffset;  \/\/ [Internal] Always 0 unless 'Flags & ImDrawListFlags_AllowVtxOffset'.$/;"	m	struct:ImDrawList
_VtxWritePtr	vendor/imgui/imgui.h	/^    ImDrawVert*             _VtxWritePtr;       \/\/ [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)$/;"	m	struct:ImDrawList
__STB_INCLUDE_STB_TRUETYPE_H__	vendor/imgui/imstb_truetype.h	501;"	d
_apply_op	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER void _apply_op(vec<N, T, Q> const& that, const U& op)$/;"	f	struct:glm::detail::_swizzle_base2
_buffer	vendor/glm/detail/_swizzle.hpp	/^		char    _buffer[1];$/;"	m	struct:glm::detail::_swizzle_base0
_grow_capacity	vendor/imgui/imgui.h	/^    inline int          _grow_capacity(int sz) const        { int new_capacity = Capacity ? (Capacity + Capacity\/2) : 8; return new_capacity > sz ? new_capacity : sz; }$/;"	f	struct:ImVector
_swizzle	vendor/glm/detail/_swizzle.hpp	/^	struct _swizzle : public _swizzle_base2<N, T, Q, E0, E1, E2, E3, (E0 == E1 || E0 == E2 || E0 == E3 || E1 == E2 || E1 == E3 || E2 == E3)>$/;"	s	namespace:glm::detail
_swizzle_base0	vendor/glm/detail/_swizzle.hpp	/^	struct _swizzle_base0$/;"	s	namespace:glm::detail
_swizzle_base1	vendor/glm/detail/_swizzle.hpp	/^	struct _swizzle_base1 : public _swizzle_base0<T, N>$/;"	s	namespace:glm::detail
_swizzle_base1	vendor/glm/detail/_swizzle.hpp	/^	struct _swizzle_base1<2, T, Q, E0,E1,-1,-2, Aligned> : public _swizzle_base0<T, 2>$/;"	s	namespace:glm::detail
_swizzle_base1	vendor/glm/detail/_swizzle.hpp	/^	struct _swizzle_base1<3, T, Q, E0,E1,E2,-1, Aligned> : public _swizzle_base0<T, 3>$/;"	s	namespace:glm::detail
_swizzle_base1	vendor/glm/detail/_swizzle.hpp	/^	struct _swizzle_base1<4, T, Q, E0,E1,E2,E3, Aligned> : public _swizzle_base0<T, 4>$/;"	s	namespace:glm::detail
_swizzle_base2	vendor/glm/detail/_swizzle.hpp	/^	struct _swizzle_base2 : public _swizzle_base1<N, T, Q, E0,E1,E2,E3, detail::is_aligned<Q>::value>$/;"	s	namespace:glm::detail
_swizzle_base2	vendor/glm/detail/_swizzle.hpp	/^	struct _swizzle_base2<N, T, Q, E0,E1,E2,E3, 1> : public _swizzle_base1<N, T, Q, E0,E1,E2,E3, detail::is_aligned<Q>::value>$/;"	s	namespace:glm::detail
a	vendor/glm/detail/type_vec4.hpp	/^				struct { T r, g, b, a; };$/;"	m	struct:glm::vec::__anon18::__anon20
a	vendor/glm/detail/type_vec4.hpp	/^			union { T w, a, q; };$/;"	m	union:glm::vec::__anon25
active_head	vendor/imgui/imstb_rectpack.h	/^   stbrp_node *active_head;$/;"	m	struct:stbrp_context
align	vendor/imgui/imstb_rectpack.h	/^   int align;$/;"	m	struct:stbrp_context
aligned	vendor/glm/detail/qualifier.hpp	/^			aligned = aligned_highp, \/\/\/< By default aligned qualifier is also high precision$/;"	e	enum:glm::qualifier
aligned_bvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_bvec1			aligned_bvec1;$/;"	t	namespace:glm
aligned_bvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_bvec1			aligned_bvec1;$/;"	t	namespace:glm
aligned_bvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_bvec1		aligned_bvec1;$/;"	t	namespace:glm
aligned_bvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_bvec2			aligned_bvec2;$/;"	t	namespace:glm
aligned_bvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_bvec2			aligned_bvec2;$/;"	t	namespace:glm
aligned_bvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_bvec2		aligned_bvec2;$/;"	t	namespace:glm
aligned_bvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_bvec3			aligned_bvec3;$/;"	t	namespace:glm
aligned_bvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_bvec3			aligned_bvec3;$/;"	t	namespace:glm
aligned_bvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_bvec3		aligned_bvec3;$/;"	t	namespace:glm
aligned_bvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_bvec4			aligned_bvec4;$/;"	t	namespace:glm
aligned_bvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_bvec4			aligned_bvec4;$/;"	t	namespace:glm
aligned_bvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_bvec4		aligned_bvec4;$/;"	t	namespace:glm
aligned_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat2			aligned_dmat2;$/;"	t	namespace:glm
aligned_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat2			aligned_dmat2;$/;"	t	namespace:glm
aligned_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat2		aligned_dmat2;$/;"	t	namespace:glm
aligned_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat2x2		aligned_dmat2x2;$/;"	t	namespace:glm
aligned_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat2x2		aligned_dmat2x2;$/;"	t	namespace:glm
aligned_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat2x2		aligned_dmat2x2;$/;"	t	namespace:glm
aligned_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat2x3		aligned_dmat2x3;$/;"	t	namespace:glm
aligned_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat2x3		aligned_dmat2x3;$/;"	t	namespace:glm
aligned_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat2x3		aligned_dmat2x3;$/;"	t	namespace:glm
aligned_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat2x4		aligned_dmat2x4;$/;"	t	namespace:glm
aligned_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat2x4		aligned_dmat2x4;$/;"	t	namespace:glm
aligned_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat2x4		aligned_dmat2x4;$/;"	t	namespace:glm
aligned_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat3			aligned_dmat3;$/;"	t	namespace:glm
aligned_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat3			aligned_dmat3;$/;"	t	namespace:glm
aligned_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat3		aligned_dmat3;$/;"	t	namespace:glm
aligned_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat3x2		aligned_dmat3x2;$/;"	t	namespace:glm
aligned_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat3x2		aligned_dmat3x2;$/;"	t	namespace:glm
aligned_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat3x2		aligned_dmat3x2;$/;"	t	namespace:glm
aligned_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat3x3		aligned_dmat3x3;$/;"	t	namespace:glm
aligned_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat3x3		aligned_dmat3x3;$/;"	t	namespace:glm
aligned_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat3x3		aligned_dmat3x3;$/;"	t	namespace:glm
aligned_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat3x4		aligned_dmat3x4;$/;"	t	namespace:glm
aligned_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat3x4		aligned_dmat3x4;$/;"	t	namespace:glm
aligned_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat3x4		aligned_dmat3x4;$/;"	t	namespace:glm
aligned_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat4			aligned_dmat4;$/;"	t	namespace:glm
aligned_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat4			aligned_dmat4;$/;"	t	namespace:glm
aligned_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat4		aligned_dmat4;$/;"	t	namespace:glm
aligned_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat4x2		aligned_dmat4x2;$/;"	t	namespace:glm
aligned_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat4x2		aligned_dmat4x2;$/;"	t	namespace:glm
aligned_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat4x2		aligned_dmat4x2;$/;"	t	namespace:glm
aligned_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat4x3		aligned_dmat4x3;$/;"	t	namespace:glm
aligned_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat4x3		aligned_dmat4x3;$/;"	t	namespace:glm
aligned_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat4x3		aligned_dmat4x3;$/;"	t	namespace:glm
aligned_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dmat4x4		aligned_dmat4x4;$/;"	t	namespace:glm
aligned_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dmat4x4		aligned_dmat4x4;$/;"	t	namespace:glm
aligned_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dmat4x4		aligned_dmat4x4;$/;"	t	namespace:glm
aligned_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dvec1			aligned_dvec1;$/;"	t	namespace:glm
aligned_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dvec1			aligned_dvec1;$/;"	t	namespace:glm
aligned_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dvec1		aligned_dvec1;$/;"	t	namespace:glm
aligned_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dvec2			aligned_dvec2;$/;"	t	namespace:glm
aligned_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dvec2			aligned_dvec2;$/;"	t	namespace:glm
aligned_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dvec2		aligned_dvec2;$/;"	t	namespace:glm
aligned_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dvec3			aligned_dvec3;$/;"	t	namespace:glm
aligned_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dvec3			aligned_dvec3;$/;"	t	namespace:glm
aligned_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dvec3		aligned_dvec3;$/;"	t	namespace:glm
aligned_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_dvec4			aligned_dvec4;$/;"	t	namespace:glm
aligned_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_dvec4			aligned_dvec4;$/;"	t	namespace:glm
aligned_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_dvec4		aligned_dvec4;$/;"	t	namespace:glm
aligned_highp	vendor/glm/detail/qualifier.hpp	/^			aligned_highp, \/\/\/< Typed data is aligned in memory allowing SIMD optimizations and operations are executed with high precision in term of ULPs$/;"	e	enum:glm::qualifier
aligned_highp_bvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, bool, aligned_highp>		aligned_highp_bvec1;$/;"	t	namespace:glm
aligned_highp_bvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, bool, aligned_highp>		aligned_highp_bvec2;$/;"	t	namespace:glm
aligned_highp_bvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, bool, aligned_highp>		aligned_highp_bvec3;$/;"	t	namespace:glm
aligned_highp_bvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, bool, aligned_highp>		aligned_highp_bvec4;$/;"	t	namespace:glm
aligned_highp_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, aligned_highp>	aligned_highp_dmat2;$/;"	t	namespace:glm
aligned_highp_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, aligned_highp>	aligned_highp_dmat2x2;$/;"	t	namespace:glm
aligned_highp_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, double, aligned_highp>	aligned_highp_dmat2x3;$/;"	t	namespace:glm
aligned_highp_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, double, aligned_highp>	aligned_highp_dmat2x4;$/;"	t	namespace:glm
aligned_highp_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, aligned_highp>	aligned_highp_dmat3;$/;"	t	namespace:glm
aligned_highp_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, double, aligned_highp>	aligned_highp_dmat3x2;$/;"	t	namespace:glm
aligned_highp_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, aligned_highp>	aligned_highp_dmat3x3;$/;"	t	namespace:glm
aligned_highp_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, double, aligned_highp>	aligned_highp_dmat3x4;$/;"	t	namespace:glm
aligned_highp_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, aligned_highp>	aligned_highp_dmat4;$/;"	t	namespace:glm
aligned_highp_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, double, aligned_highp>	aligned_highp_dmat4x2;$/;"	t	namespace:glm
aligned_highp_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, double, aligned_highp>	aligned_highp_dmat4x3;$/;"	t	namespace:glm
aligned_highp_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, aligned_highp>	aligned_highp_dmat4x4;$/;"	t	namespace:glm
aligned_highp_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, double, aligned_highp>	aligned_highp_dvec1;$/;"	t	namespace:glm
aligned_highp_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, double, aligned_highp>	aligned_highp_dvec2;$/;"	t	namespace:glm
aligned_highp_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, double, aligned_highp>	aligned_highp_dvec3;$/;"	t	namespace:glm
aligned_highp_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, double, aligned_highp>	aligned_highp_dvec4;$/;"	t	namespace:glm
aligned_highp_ivec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, int, aligned_highp>		aligned_highp_ivec1;$/;"	t	namespace:glm
aligned_highp_ivec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, int, aligned_highp>		aligned_highp_ivec2;$/;"	t	namespace:glm
aligned_highp_ivec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, int, aligned_highp>		aligned_highp_ivec3;$/;"	t	namespace:glm
aligned_highp_ivec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, int, aligned_highp>		aligned_highp_ivec4;$/;"	t	namespace:glm
aligned_highp_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, aligned_highp>		aligned_highp_mat2;$/;"	t	namespace:glm
aligned_highp_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, aligned_highp>		aligned_highp_mat2x2;$/;"	t	namespace:glm
aligned_highp_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, float, aligned_highp>		aligned_highp_mat2x3;$/;"	t	namespace:glm
aligned_highp_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, float, aligned_highp>		aligned_highp_mat2x4;$/;"	t	namespace:glm
aligned_highp_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, aligned_highp>		aligned_highp_mat3;$/;"	t	namespace:glm
aligned_highp_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, float, aligned_highp>		aligned_highp_mat3x2;$/;"	t	namespace:glm
aligned_highp_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, aligned_highp>		aligned_highp_mat3x3;$/;"	t	namespace:glm
aligned_highp_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, float, aligned_highp>		aligned_highp_mat3x4;$/;"	t	namespace:glm
aligned_highp_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, aligned_highp>		aligned_highp_mat4;$/;"	t	namespace:glm
aligned_highp_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, float, aligned_highp>		aligned_highp_mat4x2;$/;"	t	namespace:glm
aligned_highp_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, float, aligned_highp>		aligned_highp_mat4x3;$/;"	t	namespace:glm
aligned_highp_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, aligned_highp>		aligned_highp_mat4x4;$/;"	t	namespace:glm
aligned_highp_uvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, uint, aligned_highp>		aligned_highp_uvec1;$/;"	t	namespace:glm
aligned_highp_uvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, uint, aligned_highp>		aligned_highp_uvec2;$/;"	t	namespace:glm
aligned_highp_uvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, uint, aligned_highp>		aligned_highp_uvec3;$/;"	t	namespace:glm
aligned_highp_uvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, uint, aligned_highp>		aligned_highp_uvec4;$/;"	t	namespace:glm
aligned_highp_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, float, aligned_highp>	aligned_highp_vec1;$/;"	t	namespace:glm
aligned_highp_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, float, aligned_highp>	aligned_highp_vec2;$/;"	t	namespace:glm
aligned_highp_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, float, aligned_highp>	aligned_highp_vec3;$/;"	t	namespace:glm
aligned_highp_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, float, aligned_highp>	aligned_highp_vec4;$/;"	t	namespace:glm
aligned_ivec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_ivec1			aligned_ivec1;$/;"	t	namespace:glm
aligned_ivec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_ivec1			aligned_ivec1;$/;"	t	namespace:glm
aligned_ivec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_ivec1		aligned_ivec1;$/;"	t	namespace:glm
aligned_ivec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_ivec2			aligned_ivec2;$/;"	t	namespace:glm
aligned_ivec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_ivec2			aligned_ivec2;$/;"	t	namespace:glm
aligned_ivec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_ivec2		aligned_ivec2;$/;"	t	namespace:glm
aligned_ivec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_ivec3			aligned_ivec3;$/;"	t	namespace:glm
aligned_ivec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_ivec3			aligned_ivec3;$/;"	t	namespace:glm
aligned_ivec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_ivec3		aligned_ivec3;$/;"	t	namespace:glm
aligned_ivec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_ivec4			aligned_ivec4;$/;"	t	namespace:glm
aligned_ivec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_ivec4			aligned_ivec4;$/;"	t	namespace:glm
aligned_ivec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_ivec4		aligned_ivec4;$/;"	t	namespace:glm
aligned_lowp	vendor/glm/detail/qualifier.hpp	/^			aligned_lowp, \/\/ \/\/\/< Typed data is aligned in memory allowing SIMD optimizations and operations are executed with high precision in term of ULPs to maximize performance$/;"	e	enum:glm::qualifier
aligned_lowp_bvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, bool, aligned_lowp>		aligned_lowp_bvec1;$/;"	t	namespace:glm
aligned_lowp_bvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, bool, aligned_lowp>		aligned_lowp_bvec2;$/;"	t	namespace:glm
aligned_lowp_bvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, bool, aligned_lowp>		aligned_lowp_bvec3;$/;"	t	namespace:glm
aligned_lowp_bvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, bool, aligned_lowp>		aligned_lowp_bvec4;$/;"	t	namespace:glm
aligned_lowp_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, aligned_lowp>		aligned_lowp_dmat2;$/;"	t	namespace:glm
aligned_lowp_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, aligned_lowp>		aligned_lowp_dmat2x2;$/;"	t	namespace:glm
aligned_lowp_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, double, aligned_lowp>		aligned_lowp_dmat2x3;$/;"	t	namespace:glm
aligned_lowp_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, double, aligned_lowp>		aligned_lowp_dmat2x4;$/;"	t	namespace:glm
aligned_lowp_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, aligned_lowp>		aligned_lowp_dmat3;$/;"	t	namespace:glm
aligned_lowp_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, double, aligned_lowp>		aligned_lowp_dmat3x2;$/;"	t	namespace:glm
aligned_lowp_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, aligned_lowp>		aligned_lowp_dmat3x3;$/;"	t	namespace:glm
aligned_lowp_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, double, aligned_lowp>		aligned_lowp_dmat3x4;$/;"	t	namespace:glm
aligned_lowp_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, aligned_lowp>		aligned_lowp_dmat4;$/;"	t	namespace:glm
aligned_lowp_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, double, aligned_lowp>		aligned_lowp_dmat4x2;$/;"	t	namespace:glm
aligned_lowp_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, double, aligned_lowp>		aligned_lowp_dmat4x3;$/;"	t	namespace:glm
aligned_lowp_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, aligned_lowp>		aligned_lowp_dmat4x4;$/;"	t	namespace:glm
aligned_lowp_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, double, aligned_lowp>	aligned_lowp_dvec1;$/;"	t	namespace:glm
aligned_lowp_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, double, aligned_lowp>	aligned_lowp_dvec2;$/;"	t	namespace:glm
aligned_lowp_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, double, aligned_lowp>	aligned_lowp_dvec3;$/;"	t	namespace:glm
aligned_lowp_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, double, aligned_lowp>	aligned_lowp_dvec4;$/;"	t	namespace:glm
aligned_lowp_ivec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, int, aligned_lowp>		aligned_lowp_ivec1;$/;"	t	namespace:glm
aligned_lowp_ivec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, int, aligned_lowp>		aligned_lowp_ivec2;$/;"	t	namespace:glm
aligned_lowp_ivec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, int, aligned_lowp>		aligned_lowp_ivec3;$/;"	t	namespace:glm
aligned_lowp_ivec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, int, aligned_lowp>		aligned_lowp_ivec4;$/;"	t	namespace:glm
aligned_lowp_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, aligned_lowp>		aligned_lowp_mat2;$/;"	t	namespace:glm
aligned_lowp_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, aligned_lowp>		aligned_lowp_mat2x2;$/;"	t	namespace:glm
aligned_lowp_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, float, aligned_lowp>		aligned_lowp_mat2x3;$/;"	t	namespace:glm
aligned_lowp_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, float, aligned_lowp>		aligned_lowp_mat2x4;$/;"	t	namespace:glm
aligned_lowp_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, aligned_lowp>		aligned_lowp_mat3;$/;"	t	namespace:glm
aligned_lowp_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, float, aligned_lowp>		aligned_lowp_mat3x2;$/;"	t	namespace:glm
aligned_lowp_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, aligned_lowp>		aligned_lowp_mat3x3;$/;"	t	namespace:glm
aligned_lowp_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, float, aligned_lowp>		aligned_lowp_mat3x4;$/;"	t	namespace:glm
aligned_lowp_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, aligned_lowp>		aligned_lowp_mat4;$/;"	t	namespace:glm
aligned_lowp_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, float, aligned_lowp>		aligned_lowp_mat4x2;$/;"	t	namespace:glm
aligned_lowp_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, float, aligned_lowp>		aligned_lowp_mat4x3;$/;"	t	namespace:glm
aligned_lowp_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, aligned_lowp>		aligned_lowp_mat4x4;$/;"	t	namespace:glm
aligned_lowp_uvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, uint, aligned_lowp>		aligned_lowp_uvec1;$/;"	t	namespace:glm
aligned_lowp_uvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, uint, aligned_lowp>		aligned_lowp_uvec2;$/;"	t	namespace:glm
aligned_lowp_uvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, uint, aligned_lowp>		aligned_lowp_uvec3;$/;"	t	namespace:glm
aligned_lowp_uvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, uint, aligned_lowp>		aligned_lowp_uvec4;$/;"	t	namespace:glm
aligned_lowp_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, float, aligned_lowp>		aligned_lowp_vec1;$/;"	t	namespace:glm
aligned_lowp_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, float, aligned_lowp>		aligned_lowp_vec2;$/;"	t	namespace:glm
aligned_lowp_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, float, aligned_lowp>		aligned_lowp_vec3;$/;"	t	namespace:glm
aligned_lowp_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, float, aligned_lowp>		aligned_lowp_vec4;$/;"	t	namespace:glm
aligned_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat2			aligned_mat2;$/;"	t	namespace:glm
aligned_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat2			aligned_mat2;$/;"	t	namespace:glm
aligned_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat2		aligned_mat2;$/;"	t	namespace:glm
aligned_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat2x2		aligned_mat2x2;$/;"	t	namespace:glm
aligned_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat2x2			aligned_mat2x2;$/;"	t	namespace:glm
aligned_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat2x2		aligned_mat2x2;$/;"	t	namespace:glm
aligned_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat2x3		aligned_mat2x3;$/;"	t	namespace:glm
aligned_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat2x3			aligned_mat2x3;$/;"	t	namespace:glm
aligned_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat2x3		aligned_mat2x3;$/;"	t	namespace:glm
aligned_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat2x4		aligned_mat2x4;$/;"	t	namespace:glm
aligned_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat2x4			aligned_mat2x4;$/;"	t	namespace:glm
aligned_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat2x4		aligned_mat2x4;$/;"	t	namespace:glm
aligned_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat3			aligned_mat3;$/;"	t	namespace:glm
aligned_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat3			aligned_mat3;$/;"	t	namespace:glm
aligned_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat3		aligned_mat3;$/;"	t	namespace:glm
aligned_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat3x2		aligned_mat3x2;$/;"	t	namespace:glm
aligned_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat3x2			aligned_mat3x2;$/;"	t	namespace:glm
aligned_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat3x2		aligned_mat3x2;$/;"	t	namespace:glm
aligned_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat3x3		aligned_mat3x3;$/;"	t	namespace:glm
aligned_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat3x3			aligned_mat3x3;$/;"	t	namespace:glm
aligned_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat3x3		aligned_mat3x3;$/;"	t	namespace:glm
aligned_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat3x4		aligned_mat3x4;$/;"	t	namespace:glm
aligned_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat3x4			aligned_mat3x4;$/;"	t	namespace:glm
aligned_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat3x4		aligned_mat3x4;$/;"	t	namespace:glm
aligned_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat4			aligned_mat4;$/;"	t	namespace:glm
aligned_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat4			aligned_mat4;$/;"	t	namespace:glm
aligned_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat4		aligned_mat4;$/;"	t	namespace:glm
aligned_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat4x2		aligned_mat4x2;$/;"	t	namespace:glm
aligned_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat4x2			aligned_mat4x2;$/;"	t	namespace:glm
aligned_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat4x2		aligned_mat4x2;$/;"	t	namespace:glm
aligned_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat4x3		aligned_mat4x3;$/;"	t	namespace:glm
aligned_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat4x3			aligned_mat4x3;$/;"	t	namespace:glm
aligned_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat4x3		aligned_mat4x3;$/;"	t	namespace:glm
aligned_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_mat4x4		aligned_mat4x4;$/;"	t	namespace:glm
aligned_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_mat4x4			aligned_mat4x4;$/;"	t	namespace:glm
aligned_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_mat4x4		aligned_mat4x4;$/;"	t	namespace:glm
aligned_mediump	vendor/glm/detail/qualifier.hpp	/^			aligned_mediump, \/\/\/< Typed data is aligned in memory allowing SIMD optimizations and operations are executed with high precision in term of ULPs for higher performance$/;"	e	enum:glm::qualifier
aligned_mediump_bvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, bool, aligned_mediump>	aligned_mediump_bvec1;$/;"	t	namespace:glm
aligned_mediump_bvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, bool, aligned_mediump>	aligned_mediump_bvec2;$/;"	t	namespace:glm
aligned_mediump_bvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, bool, aligned_mediump>	aligned_mediump_bvec3;$/;"	t	namespace:glm
aligned_mediump_bvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, bool, aligned_mediump>	aligned_mediump_bvec4;$/;"	t	namespace:glm
aligned_mediump_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, aligned_mediump>	aligned_mediump_dmat2;$/;"	t	namespace:glm
aligned_mediump_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, aligned_mediump>	aligned_mediump_dmat2x2;$/;"	t	namespace:glm
aligned_mediump_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, double, aligned_mediump>	aligned_mediump_dmat2x3;$/;"	t	namespace:glm
aligned_mediump_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, double, aligned_mediump>	aligned_mediump_dmat2x4;$/;"	t	namespace:glm
aligned_mediump_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, aligned_mediump>	aligned_mediump_dmat3;$/;"	t	namespace:glm
aligned_mediump_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, double, aligned_mediump>	aligned_mediump_dmat3x2;$/;"	t	namespace:glm
aligned_mediump_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, aligned_mediump>	aligned_mediump_dmat3x3;$/;"	t	namespace:glm
aligned_mediump_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, double, aligned_mediump>	aligned_mediump_dmat3x4;$/;"	t	namespace:glm
aligned_mediump_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, aligned_mediump>	aligned_mediump_dmat4;$/;"	t	namespace:glm
aligned_mediump_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, double, aligned_mediump>	aligned_mediump_dmat4x2;$/;"	t	namespace:glm
aligned_mediump_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, double, aligned_mediump>	aligned_mediump_dmat4x3;$/;"	t	namespace:glm
aligned_mediump_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, aligned_mediump>	aligned_mediump_dmat4x4;$/;"	t	namespace:glm
aligned_mediump_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, double, aligned_mediump>	aligned_mediump_dvec1;$/;"	t	namespace:glm
aligned_mediump_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, double, aligned_mediump>	aligned_mediump_dvec2;$/;"	t	namespace:glm
aligned_mediump_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, double, aligned_mediump>	aligned_mediump_dvec3;$/;"	t	namespace:glm
aligned_mediump_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, double, aligned_mediump>	aligned_mediump_dvec4;$/;"	t	namespace:glm
aligned_mediump_ivec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, int, aligned_mediump>	aligned_mediump_ivec1;$/;"	t	namespace:glm
aligned_mediump_ivec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, int, aligned_mediump>	aligned_mediump_ivec2;$/;"	t	namespace:glm
aligned_mediump_ivec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, int, aligned_mediump>	aligned_mediump_ivec3;$/;"	t	namespace:glm
aligned_mediump_ivec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, int, aligned_mediump>	aligned_mediump_ivec4;$/;"	t	namespace:glm
aligned_mediump_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, aligned_mediump>	aligned_mediump_mat2;$/;"	t	namespace:glm
aligned_mediump_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, aligned_mediump>	aligned_mediump_mat2x2;$/;"	t	namespace:glm
aligned_mediump_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, float, aligned_mediump>	aligned_mediump_mat2x3;$/;"	t	namespace:glm
aligned_mediump_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, float, aligned_mediump>	aligned_mediump_mat2x4;$/;"	t	namespace:glm
aligned_mediump_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, aligned_mediump>	aligned_mediump_mat3;$/;"	t	namespace:glm
aligned_mediump_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, float, aligned_mediump>	aligned_mediump_mat3x2;$/;"	t	namespace:glm
aligned_mediump_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, aligned_mediump>	aligned_mediump_mat3x3;$/;"	t	namespace:glm
aligned_mediump_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, float, aligned_mediump>	aligned_mediump_mat3x4;$/;"	t	namespace:glm
aligned_mediump_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, aligned_mediump>	aligned_mediump_mat4;$/;"	t	namespace:glm
aligned_mediump_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, float, aligned_mediump>	aligned_mediump_mat4x2;$/;"	t	namespace:glm
aligned_mediump_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, float, aligned_mediump>	aligned_mediump_mat4x3;$/;"	t	namespace:glm
aligned_mediump_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, aligned_mediump>	aligned_mediump_mat4x4;$/;"	t	namespace:glm
aligned_mediump_uvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, uint, aligned_mediump>	aligned_mediump_uvec1;$/;"	t	namespace:glm
aligned_mediump_uvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, uint, aligned_mediump>	aligned_mediump_uvec2;$/;"	t	namespace:glm
aligned_mediump_uvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, uint, aligned_mediump>	aligned_mediump_uvec3;$/;"	t	namespace:glm
aligned_mediump_uvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, uint, aligned_mediump>	aligned_mediump_uvec4;$/;"	t	namespace:glm
aligned_mediump_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, float, aligned_mediump>	aligned_mediump_vec1;$/;"	t	namespace:glm
aligned_mediump_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, float, aligned_mediump>	aligned_mediump_vec2;$/;"	t	namespace:glm
aligned_mediump_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, float, aligned_mediump>	aligned_mediump_vec3;$/;"	t	namespace:glm
aligned_mediump_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, float, aligned_mediump>	aligned_mediump_vec4;$/;"	t	namespace:glm
aligned_uvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_uvec1			aligned_uvec1;$/;"	t	namespace:glm
aligned_uvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_uvec1			aligned_uvec1;$/;"	t	namespace:glm
aligned_uvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_uvec1		aligned_uvec1;$/;"	t	namespace:glm
aligned_uvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_uvec2			aligned_uvec2;$/;"	t	namespace:glm
aligned_uvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_uvec2			aligned_uvec2;$/;"	t	namespace:glm
aligned_uvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_uvec2		aligned_uvec2;$/;"	t	namespace:glm
aligned_uvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_uvec3			aligned_uvec3;$/;"	t	namespace:glm
aligned_uvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_uvec3			aligned_uvec3;$/;"	t	namespace:glm
aligned_uvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_uvec3		aligned_uvec3;$/;"	t	namespace:glm
aligned_uvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_uvec4			aligned_uvec4;$/;"	t	namespace:glm
aligned_uvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_uvec4			aligned_uvec4;$/;"	t	namespace:glm
aligned_uvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_uvec4		aligned_uvec4;$/;"	t	namespace:glm
aligned_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_vec1			aligned_vec1;$/;"	t	namespace:glm
aligned_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_vec1			aligned_vec1;$/;"	t	namespace:glm
aligned_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_vec1		aligned_vec1;$/;"	t	namespace:glm
aligned_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_vec2			aligned_vec2;$/;"	t	namespace:glm
aligned_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_vec2			aligned_vec2;$/;"	t	namespace:glm
aligned_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_vec2		aligned_vec2;$/;"	t	namespace:glm
aligned_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_vec3			aligned_vec3;$/;"	t	namespace:glm
aligned_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_vec3			aligned_vec3;$/;"	t	namespace:glm
aligned_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_vec3		aligned_vec3;$/;"	t	namespace:glm
aligned_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_highp_vec4 			aligned_vec4;$/;"	t	namespace:glm
aligned_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_lowp_vec4			aligned_vec4;$/;"	t	namespace:glm
aligned_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef aligned_mediump_vec4		aligned_vec4;$/;"	t	namespace:glm
all_a	vendor/stb_image/stb_image.h	/^   unsigned int mr,mg,mb,ma, all_a;$/;"	m	struct:__anon69
alloca	vendor/imgui/imgui_draw.cpp	42;"	d	file:
app14_color_transform	vendor/stb_image/stb_image.h	/^   int            app14_color_transform; \/\/ Adobe APP14 tag$/;"	m	struct:__anon61
append	vendor/imgui/imgui.cpp	/^void ImGuiTextBuffer::append(const char* str, const char* str_end)$/;"	f	class:ImGuiTextBuffer
appendf	vendor/imgui/imgui.cpp	/^void ImGuiTextBuffer::appendf(const char* fmt, ...)$/;"	f	class:ImGuiTextBuffer
appendfv	vendor/imgui/imgui.cpp	/^void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)$/;"	f	class:ImGuiTextBuffer
array_of_unicode_codepoints	vendor/imgui/imstb_truetype.h	/^   int *array_of_unicode_codepoints;       \/\/ if non-zero, then this is an array of unicode codepoints$/;"	m	struct:__anon33
atan2	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER T atan2(T x, T y){return atan(x, y);}																\/\/!< \\brief Arc tangent. Returns an angle whose tangent is y\/x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [-PI, PI]. Results are undefined if x and y are both 0. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
atan2	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<2, T, Q> atan2(const vec<2, T, Q>& x, const vec<2, T, Q>& y){return atan(x, y);}	\/\/!< \\brief Arc tangent. Returns an angle whose tangent is y\/x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [-PI, PI]. Results are undefined if x and y are both 0. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
atan2	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<3, T, Q> atan2(const vec<3, T, Q>& x, const vec<3, T, Q>& y){return atan(x, y);}	\/\/!< \\brief Arc tangent. Returns an angle whose tangent is y\/x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [-PI, PI]. Results are undefined if x and y are both 0. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
atan2	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<4, T, Q> atan2(const vec<4, T, Q>& x, const vec<4, T, Q>& y){return atan(x, y);}	\/\/!< \\brief Arc tangent. Returns an angle whose tangent is y\/x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [-PI, PI]. Results are undefined if x and y are both 0. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
b	vendor/glm/detail/type_vec3.hpp	/^				struct{ T r, g, b; };$/;"	m	struct:glm::vec::__anon3::__anon5
b	vendor/glm/detail/type_vec3.hpp	/^			union { T z, b, p; };$/;"	m	union:glm::vec::__anon9
b	vendor/glm/detail/type_vec4.hpp	/^				struct { T r, g, b, a; };$/;"	m	struct:glm::vec::__anon18::__anon20
b	vendor/glm/detail/type_vec4.hpp	/^			union { T z, b, p; };$/;"	m	union:glm::vec::__anon24
b	vendor/imgui/imgui.h	/^        const char*     b;$/;"	m	struct:ImGuiTextFilter::ImGuiTextRange
back	vendor/imgui/imgui.h	/^    inline T&           back()                              { IM_ASSERT(Size > 0); return Data[Size - 1]; }$/;"	f	struct:ImVector
back	vendor/imgui/imgui.h	/^    inline const T&     back() const                        { IM_ASSERT(Size > 0); return Data[Size - 1]; }$/;"	f	struct:ImVector
background	vendor/stb_image/stb_image.h	/^   stbi_uc *background;          \/\/ The current "background" as far as a gif is concerned$/;"	m	struct:__anon72
base_type	vendor/glm/detail/_swizzle.hpp	/^		typedef _swizzle_base2<N, T, Q, E0, E1, E2, E3, (E0 == E1 || E0 == E2 || E0 == E3 || E1 == E2 || E1 == E3 || E2 == E3)> base_type;$/;"	t	struct:glm::detail::_swizzle
baseline_y_delta	vendor/imgui/imstb_textedit.h	/^   float baseline_y_delta;  \/\/ position of baseline relative to previous row's baseline$/;"	m	struct:__anon51
basic_format_saver	vendor/glm/gtx/io.hpp	/^		class basic_format_saver$/;"	c	namespace:glm::io
basic_state_saver	vendor/glm/gtx/io.hpp	/^		class basic_state_saver {$/;"	c	namespace:glm::io
begin	vendor/glm/gtx/range.hpp	/^	inline typename genType::value_type * begin(genType& v)$/;"	f	namespace:glm
begin	vendor/glm/gtx/range.hpp	/^	inline typename genType::value_type const * begin(genType const& v)$/;"	f	class:glm::genType
begin	vendor/imgui/imgui.h	/^    const char*         begin() const           { return Buf.Data ? &Buf.front() : EmptyString; }$/;"	f	struct:ImGuiTextBuffer
begin	vendor/imgui/imgui.h	/^    inline T*           begin()                             { return Data; }$/;"	f	struct:ImVector
begin	vendor/imgui/imgui.h	/^    inline const T*     begin() const                       { return Data; }$/;"	f	struct:ImVector
bgindex	vendor/stb_image/stb_image.h	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:__anon72
bits_per_channel	vendor/stb_image/stb_image.h	/^   int bits_per_channel;$/;"	m	struct:__anon58
bool1	vendor/glm/gtx/compatibility.hpp	/^	typedef bool						bool1;			\/\/!< \\brief boolean type with 1 component. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool1x1	vendor/glm/gtx/compatibility.hpp	/^	typedef bool						bool1x1;		\/\/!< \\brief boolean matrix with 1 x 1 component. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool2	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<2, bool, highp>			bool2;			\/\/!< \\brief boolean type with 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool2x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 2, bool, highp>		bool2x2;		\/\/!< \\brief boolean matrix with 2 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool2x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 3, bool, highp>		bool2x3;		\/\/!< \\brief boolean matrix with 2 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool2x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 4, bool, highp>		bool2x4;		\/\/!< \\brief boolean matrix with 2 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool3	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<3, bool, highp>			bool3;			\/\/!< \\brief boolean type with 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool3x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 2, bool, highp>		bool3x2;		\/\/!< \\brief boolean matrix with 3 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool3x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 3, bool, highp>		bool3x3;		\/\/!< \\brief boolean matrix with 3 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool3x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 4, bool, highp>		bool3x4;		\/\/!< \\brief boolean matrix with 3 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool4	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<4, bool, highp>			bool4;			\/\/!< \\brief boolean type with 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool4x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 2, bool, highp>		bool4x2;		\/\/!< \\brief boolean matrix with 4 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool4x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 3, bool, highp>		bool4x3;		\/\/!< \\brief boolean matrix with 4 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool4x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 4, bool, highp>		bool4x4;		\/\/!< \\brief boolean matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
bool_type	vendor/glm/detail/type_vec1.hpp	/^		typedef vec<1, bool, Q> bool_type;$/;"	t	struct:glm::vec
bool_type	vendor/glm/detail/type_vec2.hpp	/^		typedef vec<2, bool, Q> bool_type;$/;"	t	struct:glm::vec
bool_type	vendor/glm/detail/type_vec3.hpp	/^		typedef vec<3, bool, Q> bool_type;$/;"	t	struct:glm::vec
bool_type	vendor/glm/detail/type_vec4.hpp	/^		typedef vec<4, bool, Q> bool_type;$/;"	t	struct:glm::vec
bottom_y	vendor/imgui/imstb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon45
bounds	vendor/imgui/imstb_truetype.h	/^   int bounds;$/;"	m	struct:__anon43
bpp	Texture/Texture.h	/^	int 			bpp;$/;"	m	class:Texture
bpp	vendor/stb_image/stb_image.h	/^   int bpp, offset, hsz;$/;"	m	struct:__anon69
bss_	vendor/glm/gtx/io.hpp	/^			basic_state_saver<CTy> const bss_;$/;"	m	class:glm::io::basic_format_saver
buffer_start	vendor/stb_image/stb_image.h	/^   stbi_uc buffer_start[128];$/;"	m	struct:__anon56
buflen	vendor/stb_image/stb_image.h	/^   int buflen;$/;"	m	struct:__anon56
bvec1	vendor/glm/ext/vector_bool1.hpp	/^	typedef vec<1, bool, defaultp>		bvec1;$/;"	t	namespace:glm
bvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, bool, defaultp>	bvec1;$/;"	t	namespace:glm
bvec2	vendor/glm/ext/vector_bool2.hpp	/^	typedef vec<2, bool, defaultp>		bvec2;$/;"	t	namespace:glm
bvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, bool, defaultp>	bvec2;$/;"	t	namespace:glm
bvec3	vendor/glm/ext/vector_bool3.hpp	/^	typedef vec<3, bool, defaultp>		bvec3;$/;"	t	namespace:glm
bvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, bool, defaultp>	bvec3;$/;"	t	namespace:glm
bvec4	vendor/glm/ext/vector_bool4.hpp	/^	typedef vec<4, bool, defaultp>		bvec4;$/;"	t	namespace:glm
bvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, bool, defaultp>	bvec4;$/;"	t	namespace:glm
byte	vendor/glm/gtx/raw_data.hpp	/^	typedef detail::uint8		byte;$/;"	t	namespace:glm
c_str	vendor/imgui/imgui.h	/^    const char*         c_str() const           { return Buf.Data ? Buf.Data : EmptyString; }$/;"	f	struct:ImGuiTextBuffer
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER GLM_CONSTEXPR static vec<1, R, Q> call(R (*Func) (T x), vec<1, T, Q> const& v)$/;"	f	struct:glm::detail::functor1
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER GLM_CONSTEXPR static vec<2, R, Q> call(R (*Func) (T x), vec<2, T, Q> const& v)$/;"	f	struct:glm::detail::functor1
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER GLM_CONSTEXPR static vec<3, R, Q> call(R (*Func) (T x), vec<3, T, Q> const& v)$/;"	f	struct:glm::detail::functor1
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER GLM_CONSTEXPR static vec<4, R, Q> call(R (*Func) (T x), vec<4, T, Q> const& v)$/;"	f	struct:glm::detail::functor1
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, T b)$/;"	f	struct:glm::detail::functor2_vec_sca
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER static vec<1, T, Q> call(T (*Func) (T x, T y), vec<1, T, Q> const& a, vec<1, T, Q> const& b)$/;"	f	struct:glm::detail::functor2
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, T b)$/;"	f	struct:glm::detail::functor2_vec_sca
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER static vec<2, T, Q> call(T (*Func) (T x, T y), vec<2, T, Q> const& a, vec<2, T, Q> const& b)$/;"	f	struct:glm::detail::functor2
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, T b)$/;"	f	struct:glm::detail::functor2_vec_sca
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER static vec<3, T, Q> call(T (*Func) (T x, T y), vec<3, T, Q> const& a, vec<3, T, Q> const& b)$/;"	f	struct:glm::detail::functor2
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, T b)$/;"	f	struct:glm::detail::functor2_vec_sca
call	vendor/glm/detail/_vectorize.hpp	/^		GLM_FUNC_QUALIFIER static vec<4, T, Q> call(T (*Func) (T x, T y), vec<4, T, Q> const& a, vec<4, T, Q> const& b)$/;"	f	struct:glm::detail::functor2
call	vendor/glm/detail/compute_common.hpp	/^		GLM_FUNC_QUALIFIER GLM_CONSTEXPR static float call(float x)$/;"	f	struct:glm::detail::compute_abs
call	vendor/glm/detail/compute_common.hpp	/^		GLM_FUNC_QUALIFIER GLM_CONSTEXPR static genFIType call(genFIType x)$/;"	f	struct:glm::detail::compute_abs
call	vendor/glm/detail/compute_vector_relational.hpp	/^		GLM_FUNC_QUALIFIER GLM_CONSTEXPR static bool call(T a, T b)$/;"	f	struct:glm::detail::compute_equal
capacity	vendor/imgui/imgui.h	/^    inline int          capacity() const                    { return Capacity; }$/;"	f	struct:ImVector
cdata	vendor/imgui/imstb_truetype.h	/^stbtt_bakedchar cdata[96]; \/\/ ASCII 32..126 is 95 glyphs$/;"	v
cff	vendor/imgui/imstb_truetype.h	/^   stbtt__buf cff;                    \/\/ cff font data$/;"	m	struct:stbtt_fontinfo
channel	vendor/stb_image/stb_image.h	/^   stbi_uc size,type,channel;$/;"	m	struct:__anon70
channel_order	vendor/stb_image/stb_image.h	/^   int channel_order;$/;"	m	struct:__anon58
char_storage	vendor/imgui/imstb_textedit.h	/^   int                        char_storage;$/;"	m	struct:__anon48
char_type	vendor/glm/gtx/io.hpp	/^			typedef CTy char_type;$/;"	t	class:glm::io::format_punct
char_type	vendor/glm/gtx/io.hpp	/^			typedef typename state_type::char_type char_type;$/;"	t	class:glm::io::basic_state_saver
chardata_for_range	vendor/imgui/imstb_truetype.h	/^   stbtt_packedchar *chardata_for_range; \/\/ output$/;"	m	struct:__anon33
charstrings	vendor/imgui/imstb_truetype.h	/^   stbtt__buf charstrings;            \/\/ the charstring index$/;"	m	struct:stbtt_fontinfo
clear	vendor/imgui/imgui.h	/^    inline void         clear()                             { if (Data) { Size = Capacity = 0; IM_FREE(Data); Data = NULL; } }$/;"	f	struct:ImVector
clear	vendor/imgui/imgui.h	/^    void                clear()                 { Buf.clear(); }$/;"	f	struct:ImGuiTextBuffer
code	vendor/stb_image/stb_image.h	/^   stbi__uint16 code[256];$/;"	m	struct:__anon60
code_bits	vendor/stb_image/stb_image.h	/^   int            code_bits;   \/\/ number of valid bits$/;"	m	struct:__anon61
code_buffer	vendor/stb_image/stb_image.h	/^   stbi__uint32   code_buffer; \/\/ jpeg entropy-coded buffer$/;"	m	struct:__anon61
code_buffer	vendor/stb_image/stb_image.h	/^   stbi__uint32 code_buffer;$/;"	m	struct:__anon65
codes	vendor/stb_image/stb_image.h	/^   stbi__gif_lzw codes[8192];$/;"	m	struct:__anon72
coeff	vendor/stb_image/stb_image.h	/^      short   *coeff;   \/\/ progressive only$/;"	m	struct:__anon61::__anon62
coeff_h	vendor/stb_image/stb_image.h	/^      int      coeff_w, coeff_h; \/\/ number of 8x8 coefficient blocks$/;"	m	struct:__anon61::__anon62
coeff_w	vendor/stb_image/stb_image.h	/^      int      coeff_w, coeff_h; \/\/ number of 8x8 coefficient blocks$/;"	m	struct:__anon61::__anon62
col	vendor/imgui/imgui.h	/^    ImU32   col;$/;"	m	struct:ImDrawVert
col_type	vendor/glm/detail/type_mat2x2.hpp	/^		typedef vec<2, T, Q> col_type;$/;"	t	struct:glm::mat
col_type	vendor/glm/detail/type_mat2x3.hpp	/^		typedef vec<3, T, Q> col_type;$/;"	t	struct:glm::mat
col_type	vendor/glm/detail/type_mat2x4.hpp	/^		typedef vec<4, T, Q> col_type;$/;"	t	struct:glm::mat
col_type	vendor/glm/detail/type_mat3x2.hpp	/^		typedef vec<2, T, Q> col_type;$/;"	t	struct:glm::mat
col_type	vendor/glm/detail/type_mat3x3.hpp	/^		typedef vec<3, T, Q> col_type;$/;"	t	struct:glm::mat
col_type	vendor/glm/detail/type_mat3x4.hpp	/^		typedef vec<4, T, Q> col_type;$/;"	t	struct:glm::mat
col_type	vendor/glm/detail/type_mat4x2.hpp	/^		typedef vec<2, T, Q> col_type;$/;"	t	struct:glm::mat
col_type	vendor/glm/detail/type_mat4x3.hpp	/^		typedef vec<3, T, Q> col_type;$/;"	t	struct:glm::mat
col_type	vendor/glm/detail/type_mat4x4.hpp	/^		typedef vec<4, T, Q> col_type;$/;"	t	struct:glm::mat
color_table	vendor/stb_image/stb_image.h	/^   stbi_uc *color_table;$/;"	m	struct:__anon72
cols	vendor/glm/gtx/type_trait.hpp	/^		static length_t const cols = 0;$/;"	m	struct:glm::type
cols	vendor/glm/gtx/type_trait.hpp	/^		static length_t const cols = C;$/;"	m	struct:glm::type
column_major	vendor/glm/gtx/io.hpp	/^		enum order_type { column_major, row_major};$/;"	e	enum:glm::io::order_type
components	vendor/glm/gtx/range.hpp	/^	inline length_t components(genType const& m)$/;"	f	namespace:glm
components	vendor/glm/gtx/range.hpp	/^	inline length_t components(vec<1, T, Q> const& v)$/;"	f	namespace:glm
components	vendor/glm/gtx/range.hpp	/^	inline length_t components(vec<2, T, Q> const& v)$/;"	f	namespace:glm
components	vendor/glm/gtx/range.hpp	/^	inline length_t components(vec<3, T, Q> const& v)$/;"	f	namespace:glm
components	vendor/glm/gtx/range.hpp	/^	inline length_t components(vec<4, T, Q> const& v)$/;"	f	namespace:glm
components	vendor/glm/gtx/type_trait.hpp	/^		static length_t const components = 0;$/;"	m	struct:glm::type
components	vendor/glm/gtx/type_trait.hpp	/^		static length_t const components = 4;$/;"	m	struct:glm::type
components	vendor/glm/gtx/type_trait.hpp	/^		static length_t const components = 8;$/;"	m	struct:glm::type
components	vendor/glm/gtx/type_trait.hpp	/^		static length_t const components = C;$/;"	m	struct:glm::type
components	vendor/glm/gtx/type_trait.hpp	/^		static length_t const components = L;$/;"	m	struct:glm::type
compute_abs	vendor/glm/detail/compute_common.hpp	/^	struct compute_abs$/;"	s	namespace:glm::detail
compute_abs	vendor/glm/detail/compute_common.hpp	/^	struct compute_abs<float, true>$/;"	s	namespace:glm::detail
compute_abs	vendor/glm/detail/compute_common.hpp	/^	struct compute_abs<genFIType, false>$/;"	s	namespace:glm::detail
compute_abs	vendor/glm/detail/compute_common.hpp	/^	struct compute_abs<genFIType, true>$/;"	s	namespace:glm::detail
compute_equal	vendor/glm/detail/compute_vector_relational.hpp	/^	struct compute_equal$/;"	s	namespace:glm::detail
const_iterator	vendor/imgui/imgui.h	/^    typedef const value_type*   const_iterator;$/;"	t	struct:ImVector
contains	vendor/imgui/imgui.h	/^    inline bool         contains(const T& v) const          { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }$/;"	f	struct:ImVector
count	IndexBuffer/IndexBuffer.h	/^	unsigned int count;$/;"	m	class:IndexBuffer
count	VertexBufferLayout/VertexBufferLayout.h	/^	unsigned int count;$/;"	m	struct:VertexBufferLayoutElement
countof	vendor/glm/detail/setup.hpp	/^		constexpr std::size_t countof(T const (&)[N])$/;"	f	namespace:glm
cur_x	vendor/stb_image/stb_image.h	/^   int cur_x, cur_y;$/;"	m	struct:__anon72
cur_y	vendor/stb_image/stb_image.h	/^   int cur_x, cur_y;$/;"	m	struct:__anon72
cursor	vendor/imgui/imstb_textedit.h	/^   int cursor;$/;"	m	struct:__anon50
cursor	vendor/imgui/imstb_truetype.h	/^   int cursor;$/;"	m	struct:__anon29
cursor_at_end_of_line	vendor/imgui/imstb_textedit.h	/^   unsigned char cursor_at_end_of_line; \/\/ not implemented yet$/;"	m	struct:__anon50
cx	vendor/imgui/imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon35
cx1	vendor/imgui/imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon35
cy	vendor/imgui/imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon35
cy1	vendor/imgui/imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon35
data	vendor/glm/detail/qualifier.hpp	/^				T data[L];$/;"	m	struct:glm::detail::storage::type
data	vendor/glm/detail/qualifier.hpp	/^			T data[L];$/;"	m	struct:glm::detail::storage::type
data	vendor/glm/detail/type_quat.hpp	/^				typename detail::storage<4, T, detail::is_aligned<Q>::value>::type data;$/;"	m	union:glm::qua::__anon16
data	vendor/glm/detail/type_vec1.hpp	/^				typename detail::storage<1, T, detail::is_aligned<Q>::value>::type data;$/;"	m	union:glm::vec::__anon1
data	vendor/glm/detail/type_vec2.hpp	/^				typename detail::storage<2, T, detail::is_aligned<Q>::value>::type data;$/;"	m	union:glm::vec::__anon10
data	vendor/glm/detail/type_vec3.hpp	/^				typename detail::storage<3, T, detail::is_aligned<Q>::value>::type data;$/;"	m	union:glm::vec::__anon3
data	vendor/glm/detail/type_vec4.hpp	/^				typename detail::storage<4, T, detail::is_aligned<Q>::value>::type data;$/;"	m	union:glm::vec::__anon18
data	vendor/imgui/imstb_truetype.h	/^   unsigned char  * data;              \/\/ pointer to .ttf file$/;"	m	struct:stbtt_fontinfo
data	vendor/imgui/imstb_truetype.h	/^   unsigned char *data;$/;"	m	struct:__anon29
data	vendor/stb_image/stb_image.h	/^      stbi_uc *data;$/;"	m	struct:__anon61::__anon62
dc_pred	vendor/stb_image/stb_image.h	/^      int dc_pred;$/;"	m	struct:__anon61::__anon62
dct_bfly32o	vendor/stb_image/stb_image.h	2368;"	d
dct_bfly32o	vendor/stb_image/stb_image.h	2502;"	d
dct_bfly32o	vendor/stb_image/stb_image.h	2554;"	d
dct_bfly32o	vendor/stb_image/stb_image.h	2712;"	d
dct_const	vendor/stb_image/stb_image.h	2340;"	d
dct_const	vendor/stb_image/stb_image.h	2497;"	d
dct_interleave16	vendor/stb_image/stb_image.h	2385;"	d
dct_interleave16	vendor/stb_image/stb_image.h	2504;"	d
dct_interleave8	vendor/stb_image/stb_image.h	2379;"	d
dct_interleave8	vendor/stb_image/stb_image.h	2503;"	d
dct_long_mac	vendor/stb_image/stb_image.h	2535;"	d
dct_long_mac	vendor/stb_image/stb_image.h	2708;"	d
dct_long_mul	vendor/stb_image/stb_image.h	2531;"	d
dct_long_mul	vendor/stb_image/stb_image.h	2707;"	d
dct_pass	vendor/stb_image/stb_image.h	2390;"	d
dct_pass	vendor/stb_image/stb_image.h	2505;"	d
dct_pass	vendor/stb_image/stb_image.h	2562;"	d
dct_pass	vendor/stb_image/stb_image.h	2713;"	d
dct_rot	vendor/stb_image/stb_image.h	2344;"	d
dct_rot	vendor/stb_image/stb_image.h	2498;"	d
dct_trn16	vendor/stb_image/stb_image.h	2622;"	d
dct_trn16	vendor/stb_image/stb_image.h	2644;"	d
dct_trn32	vendor/stb_image/stb_image.h	2623;"	d
dct_trn32	vendor/stb_image/stb_image.h	2645;"	d
dct_trn64	vendor/stb_image/stb_image.h	2624;"	d
dct_trn64	vendor/stb_image/stb_image.h	2646;"	d
dct_trn8_16	vendor/stb_image/stb_image.h	2668;"	d
dct_trn8_16	vendor/stb_image/stb_image.h	2703;"	d
dct_trn8_32	vendor/stb_image/stb_image.h	2669;"	d
dct_trn8_32	vendor/stb_image/stb_image.h	2704;"	d
dct_trn8_8	vendor/stb_image/stb_image.h	2667;"	d
dct_trn8_8	vendor/stb_image/stb_image.h	2702;"	d
dct_wadd	vendor/stb_image/stb_image.h	2358;"	d
dct_wadd	vendor/stb_image/stb_image.h	2500;"	d
dct_wadd	vendor/stb_image/stb_image.h	2544;"	d
dct_wadd	vendor/stb_image/stb_image.h	2710;"	d
dct_widen	vendor/stb_image/stb_image.h	2353;"	d
dct_widen	vendor/stb_image/stb_image.h	2499;"	d
dct_widen	vendor/stb_image/stb_image.h	2539;"	d
dct_widen	vendor/stb_image/stb_image.h	2709;"	d
dct_wsub	vendor/stb_image/stb_image.h	2363;"	d
dct_wsub	vendor/stb_image/stb_image.h	2501;"	d
dct_wsub	vendor/stb_image/stb_image.h	2549;"	d
dct_wsub	vendor/stb_image/stb_image.h	2711;"	d
ddualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef highp_ddualquat			ddualquat;$/;"	t	namespace:glm
ddualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef lowp_ddualquat			ddualquat;$/;"	t	namespace:glm
ddualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef mediump_ddualquat		ddualquat;$/;"	t	namespace:glm
defaultp	vendor/glm/detail/qualifier.hpp	/^			defaultp = aligned_highp$/;"	e	enum:glm::qualifier
delay	vendor/stb_image/stb_image.h	/^   int delay;$/;"	m	struct:__anon72
delete_length	vendor/imgui/imstb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  delete_length;$/;"	m	struct:__anon48
delim_left	vendor/glm/gtx/io.hpp	/^			char_type  delim_left;$/;"	m	class:glm::io::format_punct
delim_right	vendor/glm/gtx/io.hpp	/^			char_type  delim_right;$/;"	m	class:glm::io::format_punct
delimeter	vendor/glm/gtx/io.hpp	/^		struct delimeter$/;"	s	namespace:glm::io
delta	vendor/stb_image/stb_image.h	/^   int    delta[17];   \/\/ old 'firstsymbol' - old 'firstcode'$/;"	m	struct:__anon60
depth	vendor/stb_image/stb_image.h	/^   int depth;$/;"	m	struct:__anon67
dequant	vendor/stb_image/stb_image.h	/^   stbi__uint16 dequant[4][64];$/;"	m	struct:__anon61
detail	vendor/glm/detail/_noise.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/detail/_swizzle.hpp	/^	namespace detail$/;"	n	namespace:glm
detail	vendor/glm/detail/_swizzle.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/detail/_vectorize.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/detail/compute_common.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/detail/compute_vector_relational.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/detail/qualifier.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/detail/setup.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/detail/type_float.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/detail/type_half.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/ext/scalar_int_sized.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/ext/scalar_uint_sized.hpp	/^namespace detail$/;"	n	namespace:glm
detail	vendor/glm/matrix.hpp	/^namespace detail$/;"	n	namespace:glm
direction	vendor/imgui/imstb_truetype.h	/^   float direction;$/;"	m	struct:stbtt__active_edge
direction	vendor/imgui/imstb_truetype.h	/^   int direction;$/;"	m	struct:stbtt__active_edge
dmat2	vendor/glm/ext/matrix_double2x2.hpp	/^	typedef mat<2, 2, double, defaultp>		dmat2;$/;"	t	namespace:glm
dmat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, defaultp>	dmat2;$/;"	t	namespace:glm
dmat2x2	vendor/glm/ext/matrix_double2x2.hpp	/^	typedef mat<2, 2, double, defaultp>		dmat2x2;$/;"	t	namespace:glm
dmat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, double, defaultp>	dmat2x2;$/;"	t	namespace:glm
dmat2x3	vendor/glm/ext/matrix_double2x3.hpp	/^	typedef mat<2, 3, double, defaultp>		dmat2x3;$/;"	t	namespace:glm
dmat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, double, defaultp>	dmat2x3;$/;"	t	namespace:glm
dmat2x4	vendor/glm/ext/matrix_double2x4.hpp	/^	typedef mat<2, 4, double, defaultp>		dmat2x4;$/;"	t	namespace:glm
dmat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, double, defaultp>	dmat2x4;$/;"	t	namespace:glm
dmat3	vendor/glm/ext/matrix_double3x3.hpp	/^	typedef mat<3, 3, double, defaultp>		dmat3;$/;"	t	namespace:glm
dmat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, defaultp>	dmat3;$/;"	t	namespace:glm
dmat3x2	vendor/glm/ext/matrix_double3x2.hpp	/^	typedef mat<3, 2, double, defaultp>		dmat3x2;$/;"	t	namespace:glm
dmat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, double, defaultp>	dmat3x2;$/;"	t	namespace:glm
dmat3x3	vendor/glm/ext/matrix_double3x3.hpp	/^	typedef mat<3, 3, double, defaultp>		dmat3x3;$/;"	t	namespace:glm
dmat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, double, defaultp>	dmat3x3;$/;"	t	namespace:glm
dmat3x4	vendor/glm/ext/matrix_double3x4.hpp	/^	typedef mat<3, 4, double, defaultp>		dmat3x4;$/;"	t	namespace:glm
dmat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, double, defaultp>	dmat3x4;$/;"	t	namespace:glm
dmat4	vendor/glm/ext/matrix_double4x4.hpp	/^	typedef mat<4, 4, double, defaultp>		dmat4;$/;"	t	namespace:glm
dmat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, defaultp>	dmat4;$/;"	t	namespace:glm
dmat4x2	vendor/glm/ext/matrix_double4x2.hpp	/^	typedef mat<4, 2, double, defaultp>		dmat4x2;$/;"	t	namespace:glm
dmat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, double, defaultp>	dmat4x2;$/;"	t	namespace:glm
dmat4x3	vendor/glm/ext/matrix_double4x3.hpp	/^	typedef mat<4, 3, double, defaultp>		dmat4x3;$/;"	t	namespace:glm
dmat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, double, defaultp>	dmat4x3;$/;"	t	namespace:glm
dmat4x4	vendor/glm/ext/matrix_double4x4.hpp	/^	typedef mat<4, 4, double, defaultp>		dmat4x4;$/;"	t	namespace:glm
dmat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, double, defaultp>	dmat4x4;$/;"	t	namespace:glm
double1	vendor/glm/gtx/compatibility.hpp	/^	typedef double						double1;		\/\/!< \\brief double-qualifier floating-point vector with 1 component. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double1x1	vendor/glm/gtx/compatibility.hpp	/^	typedef double						double1x1;		\/\/!< \\brief double-qualifier floating-point matrix with 1 component. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double2	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<2, double, highp>		double2;		\/\/!< \\brief double-qualifier floating-point vector with 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double2x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 2, double, highp>		double2x2;		\/\/!< \\brief double-qualifier floating-point matrix with 2 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double2x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 3, double, highp>		double2x3;		\/\/!< \\brief double-qualifier floating-point matrix with 2 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double2x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 4, double, highp>		double2x4;		\/\/!< \\brief double-qualifier floating-point matrix with 2 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double3	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<3, double, highp>		double3;		\/\/!< \\brief double-qualifier floating-point vector with 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double3x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 2, double, highp>		double3x2;		\/\/!< \\brief double-qualifier floating-point matrix with 3 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double3x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 3, double, highp>		double3x3;		\/\/!< \\brief double-qualifier floating-point matrix with 3 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double3x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 4, double, highp>		double3x4;		\/\/!< \\brief double-qualifier floating-point matrix with 3 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double4	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<4, double, highp>		double4;		\/\/!< \\brief double-qualifier floating-point vector with 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double4x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 2, double, highp>		double4x2;		\/\/!< \\brief double-qualifier floating-point matrix with 4 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double4x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 3, double, highp>		double4x3;		\/\/!< \\brief double-qualifier floating-point matrix with 4 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
double4x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 4, double, highp>		double4x4;		\/\/!< \\brief double-qualifier floating-point matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
dquat	vendor/glm/ext/quaternion_double.hpp	/^	typedef qua<double, defaultp>		dquat;$/;"	t	namespace:glm
dquat	vendor/glm/fwd.hpp	/^	typedef qua<double, defaultp>		dquat;$/;"	t	namespace:glm
dual	vendor/glm/gtx/dual_quaternion.hpp	/^		qua<T, Q> real, dual;$/;"	m	struct:glm::tdualquat
dualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef highp_fdualquat			dualquat;$/;"	t	namespace:glm
dualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef lowp_fdualquat			dualquat;$/;"	t	namespace:glm
dualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef mediump_fdualquat		dualquat;$/;"	t	namespace:glm
dvec1	vendor/glm/ext/vector_double1.hpp	/^	typedef vec<1, double, defaultp>		dvec1;$/;"	t	namespace:glm
dvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f64, defaultp>		dvec1;$/;"	t	namespace:glm
dvec2	vendor/glm/ext/vector_double2.hpp	/^	typedef vec<2, double, defaultp>		dvec2;$/;"	t	namespace:glm
dvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f64, defaultp>		dvec2;$/;"	t	namespace:glm
dvec3	vendor/glm/ext/vector_double3.hpp	/^	typedef vec<3, double, defaultp>		dvec3;$/;"	t	namespace:glm
dvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f64, defaultp>		dvec3;$/;"	t	namespace:glm
dvec4	vendor/glm/ext/vector_double4.hpp	/^	typedef vec<4, double, defaultp>		dvec4;$/;"	t	namespace:glm
dvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f64, defaultp>		dvec4;$/;"	t	namespace:glm
dword	vendor/glm/gtx/raw_data.hpp	/^	typedef detail::uint32		dword;$/;"	t	namespace:glm
dx	vendor/imgui/imstb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge
e	vendor/imgui/imgui.h	/^        const char*     e;$/;"	m	struct:ImGuiTextFilter::ImGuiTextRange
eflags	vendor/stb_image/stb_image.h	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:__anon72
elem	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER T const& elem(size_t i) const{ return (reinterpret_cast<const T*>(_buffer))[i]; }$/;"	f	struct:glm::detail::_swizzle_base0
elem	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER T& elem(size_t i){ return (reinterpret_cast<T*>(_buffer))[i]; }$/;"	f	struct:glm::detail::_swizzle_base0
elements	VertexBufferLayout/VertexBufferLayout.h	/^	std::vector<VertexBufferLayoutElement> elements;$/;"	m	class:VertexBufferLayout
empty	vendor/imgui/imgui.h	/^        bool            empty() const                   { return b == e; }$/;"	f	struct:ImGuiTextFilter::ImGuiTextRange
empty	vendor/imgui/imgui.h	/^    bool                empty()                 { return Buf.Size <= 1; }$/;"	f	struct:ImGuiTextBuffer
empty	vendor/imgui/imgui.h	/^    inline bool         empty() const                       { return Size == 0; }$/;"	f	struct:ImVector
end	vendor/glm/gtx/range.hpp	/^	inline typename genType::value_type * end(genType& v)$/;"	f	namespace:glm
end	vendor/glm/gtx/range.hpp	/^	inline typename genType::value_type const * end(genType const& v)$/;"	f	class:glm::genType
end	vendor/imgui/imgui.h	/^    const char*         end() const             { return Buf.Data ? &Buf.back() : EmptyString; }   \/\/ Buf is zero-terminated, so end() will point on the zero-terminator$/;"	f	struct:ImGuiTextBuffer
end	vendor/imgui/imgui.h	/^    inline T*           end()                               { return Data + Size; }$/;"	f	struct:ImVector
end	vendor/imgui/imgui.h	/^    inline const T*     end() const                         { return Data + Size; }$/;"	f	struct:ImVector
eob_run	vendor/stb_image/stb_image.h	/^   int            eob_run;$/;"	m	struct:__anon61
eof	vendor/stb_image/stb_image.h	/^   int      (*eof)   (void *user);                       \/\/ returns nonzero if we are at end of file\/data$/;"	m	struct:__anon55
equal	vendor/imgui/imstb_truetype.h	/^static int equal(float *a, float *b)$/;"	f
erase	vendor/imgui/imgui.h	/^    inline T*           erase(const T* it)                  { IM_ASSERT(it >= Data && it < Data+Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(T)); Size--; return Data + off; }$/;"	f	struct:ImVector
erase	vendor/imgui/imgui.h	/^    inline T*           erase(const T* it, const T* it_last){ IM_ASSERT(it >= Data && it < Data+Size && it_last > it && it_last <= Data+Size); const ptrdiff_t count = it_last - it; const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + count, ((size_t)Size - (size_t)off - count) * sizeof(T)); Size -= (int)count; return Data + off; }$/;"	f	struct:ImVector
erase_unsorted	vendor/imgui/imgui.h	/^    inline T*           erase_unsorted(const T* it)         { IM_ASSERT(it >= Data && it < Data+Size);  const ptrdiff_t off = it - Data; if (it < Data+Size-1) memcpy(Data + off, Data + Size - 1, sizeof(T)); Size--; return Data + off; }$/;"	f	struct:ImVector
expanded	vendor/stb_image/stb_image.h	/^   stbi_uc *idata, *expanded, *out;$/;"	m	struct:__anon67
exponent	vendor/glm/detail/type_float.hpp	/^		GLM_CONSTEXPR int_type exponent() const { return (i >> 23) & ((1 << 8) - 1); }$/;"	f	union:glm::detail::float_t
exponent	vendor/glm/detail/type_float.hpp	/^		GLM_CONSTEXPR int_type exponent() const { return (i >> 52) & ((int_type(1) << 11) - 1); }$/;"	f	union:glm::detail::float_t
extra	vendor/imgui/imstb_rectpack.h	/^   stbrp_node extra[2]; \/\/ we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'$/;"	m	struct:stbrp_context
ey	vendor/imgui/imstb_truetype.h	/^   float ey;$/;"	m	struct:stbtt__active_edge
f	vendor/glm/detail/type_float.hpp	/^		float_type f;$/;"	m	union:glm::detail::float_t
f32	vendor/glm/fwd.hpp	/^	typedef float					f32;$/;"	t	namespace:glm
f32	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 f32;$/;"	t	namespace:glm
f32	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_float32_t f32;$/;"	t	namespace:glm
f32	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_f32 f32;$/;"	t	namespace:glm
f32	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_float32 f32;$/;"	t	namespace:glm
f32mat1	vendor/glm/gtx/number_precision.hpp	/^	typedef f32			f32mat1;	\/\/!< \\brief Single-qualifier floating-point scalar. (from GLM_GTX_number_precision extension)$/;"	t	namespace:glm::gtx
f32mat1x1	vendor/glm/gtx/number_precision.hpp	/^	typedef f32			f32mat1x1;	\/\/!< \\brief Single-qualifier floating-point scalar. (from GLM_GTX_number_precision extension)$/;"	t	namespace:glm::gtx
f32mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, defaultp>	f32mat2;$/;"	t	namespace:glm
f32mat2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f32, defaultp> f32mat2;$/;"	t	namespace:glm
f32mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, defaultp>	f32mat2x2;$/;"	t	namespace:glm
f32mat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f32, defaultp> f32mat2x2;$/;"	t	namespace:glm
f32mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, defaultp>	f32mat2x3;$/;"	t	namespace:glm
f32mat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f32, defaultp> f32mat2x3;$/;"	t	namespace:glm
f32mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, defaultp>	f32mat2x4;$/;"	t	namespace:glm
f32mat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f32, defaultp> f32mat2x4;$/;"	t	namespace:glm
f32mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, defaultp>	f32mat3;$/;"	t	namespace:glm
f32mat3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f32, defaultp> f32mat3;$/;"	t	namespace:glm
f32mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, defaultp>	f32mat3x2;$/;"	t	namespace:glm
f32mat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f32, defaultp> f32mat3x2;$/;"	t	namespace:glm
f32mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, defaultp>	f32mat3x3;$/;"	t	namespace:glm
f32mat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f32, defaultp> f32mat3x3;$/;"	t	namespace:glm
f32mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, defaultp>	f32mat3x4;$/;"	t	namespace:glm
f32mat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f32, defaultp> f32mat3x4;$/;"	t	namespace:glm
f32mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, defaultp>	f32mat4;$/;"	t	namespace:glm
f32mat4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f32, defaultp> f32mat4;$/;"	t	namespace:glm
f32mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, defaultp>	f32mat4x2;$/;"	t	namespace:glm
f32mat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f32, defaultp> f32mat4x2;$/;"	t	namespace:glm
f32mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, defaultp>	f32mat4x3;$/;"	t	namespace:glm
f32mat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f32, defaultp> f32mat4x3;$/;"	t	namespace:glm
f32mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, defaultp>	f32mat4x4;$/;"	t	namespace:glm
f32mat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f32, defaultp> f32mat4x4;$/;"	t	namespace:glm
f32quat	vendor/glm/fwd.hpp	/^	typedef qua<f32, defaultp>			f32quat;$/;"	t	namespace:glm
f32quat	vendor/glm/gtc/type_precision.hpp	/^	typedef qua<f32, defaultp> f32quat;$/;"	t	namespace:glm
f32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f32, defaultp>		f32vec1;$/;"	t	namespace:glm
f32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, f32, defaultp> f32vec1;$/;"	t	namespace:glm
f32vec1	vendor/glm/gtx/number_precision.hpp	/^	typedef f32			f32vec1;    \/\/!< \\brief Single-qualifier floating-point scalar. (from GLM_GTX_number_precision extension)$/;"	t	namespace:glm::gtx
f32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f32, defaultp>		f32vec2;$/;"	t	namespace:glm
f32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, f32, defaultp> f32vec2;$/;"	t	namespace:glm
f32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f32, defaultp>		f32vec3;$/;"	t	namespace:glm
f32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, f32, defaultp> f32vec3;$/;"	t	namespace:glm
f32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f32, defaultp>		f32vec4;$/;"	t	namespace:glm
f32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, f32, defaultp> f32vec4;$/;"	t	namespace:glm
f64	vendor/glm/fwd.hpp	/^	typedef double					f64;$/;"	t	namespace:glm
f64	vendor/glm/gtc/type_precision.hpp	/^		typedef float64 f64;$/;"	t	namespace:glm
f64	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_float64_t f64;$/;"	t	namespace:glm
f64	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_f64 f64;$/;"	t	namespace:glm
f64	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_float64 f64;$/;"	t	namespace:glm
f64mat1	vendor/glm/gtx/number_precision.hpp	/^	typedef f64			f64mat1;	\/\/!< \\brief Double-qualifier floating-point scalar. (from GLM_GTX_number_precision extension)$/;"	t	namespace:glm::gtx
f64mat1x1	vendor/glm/gtx/number_precision.hpp	/^	typedef f64			f64mat1x1;	\/\/!< \\brief Double-qualifier floating-point scalar. (from GLM_GTX_number_precision extension)$/;"	t	namespace:glm::gtx
f64mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, defaultp>	f64mat2;$/;"	t	namespace:glm
f64mat2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f64, defaultp> f64mat2;$/;"	t	namespace:glm
f64mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, defaultp>	f64mat2x2;$/;"	t	namespace:glm
f64mat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f64, defaultp> f64mat2x2;$/;"	t	namespace:glm
f64mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f64, defaultp>	f64mat2x3;$/;"	t	namespace:glm
f64mat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f64, defaultp> f64mat2x3;$/;"	t	namespace:glm
f64mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f64, defaultp>	f64mat2x4;$/;"	t	namespace:glm
f64mat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f64, defaultp> f64mat2x4;$/;"	t	namespace:glm
f64mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, defaultp>	f64mat3;$/;"	t	namespace:glm
f64mat3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f64, defaultp> f64mat3;$/;"	t	namespace:glm
f64mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f64, defaultp>	f64mat3x2;$/;"	t	namespace:glm
f64mat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f64, defaultp> f64mat3x2;$/;"	t	namespace:glm
f64mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, defaultp>	f64mat3x3;$/;"	t	namespace:glm
f64mat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f64, defaultp> f64mat3x3;$/;"	t	namespace:glm
f64mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f64, defaultp>	f64mat3x4;$/;"	t	namespace:glm
f64mat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f64, defaultp> f64mat3x4;$/;"	t	namespace:glm
f64mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, defaultp>	f64mat4;$/;"	t	namespace:glm
f64mat4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f64, defaultp> f64mat4;$/;"	t	namespace:glm
f64mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f64, defaultp>	f64mat4x2;$/;"	t	namespace:glm
f64mat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f64, defaultp> f64mat4x2;$/;"	t	namespace:glm
f64mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f64, defaultp>	f64mat4x3;$/;"	t	namespace:glm
f64mat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f64, defaultp> f64mat4x3;$/;"	t	namespace:glm
f64mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, defaultp>	f64mat4x4;$/;"	t	namespace:glm
f64mat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f64, defaultp> f64mat4x4;$/;"	t	namespace:glm
f64quat	vendor/glm/fwd.hpp	/^	typedef qua<f64, defaultp>			f64quat;$/;"	t	namespace:glm
f64quat	vendor/glm/gtc/type_precision.hpp	/^	typedef qua<f64, defaultp> f64quat;$/;"	t	namespace:glm
f64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f64, defaultp>		f64vec1;$/;"	t	namespace:glm
f64vec1	vendor/glm/gtc/type_precision.hpp	/^		typedef vec<1, f64, defaultp> f64vec1;$/;"	t	namespace:glm
f64vec1	vendor/glm/gtx/number_precision.hpp	/^	typedef f64			f64vec1;    \/\/!< \\brief Single-qualifier floating-point scalar. (from GLM_GTX_number_precision extension)$/;"	t	namespace:glm::gtx
f64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f64, defaultp>		f64vec2;$/;"	t	namespace:glm
f64vec2	vendor/glm/gtc/type_precision.hpp	/^		typedef vec<2, f64, defaultp> f64vec2;$/;"	t	namespace:glm
f64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f64, defaultp>		f64vec3;$/;"	t	namespace:glm
f64vec3	vendor/glm/gtc/type_precision.hpp	/^		typedef vec<3, f64, defaultp> f64vec3;$/;"	t	namespace:glm
f64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f64, defaultp>		f64vec4;$/;"	t	namespace:glm
f64vec4	vendor/glm/gtc/type_precision.hpp	/^		typedef vec<4, f64, defaultp> f64vec4;$/;"	t	namespace:glm
fade	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER vec<2, T, Q> fade(vec<2, T, Q> const& t)$/;"	f	namespace:glm::detail
fade	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER vec<3, T, Q> fade(vec<3, T, Q> const& t)$/;"	f	namespace:glm::detail
fade	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER vec<4, T, Q> fade(vec<4, T, Q> const& t)$/;"	f	namespace:glm::detail
fast	vendor/stb_image/stb_image.h	/^   stbi__uint16 fast[1 << STBI__ZFAST_BITS];$/;"	m	struct:__anon64
fast	vendor/stb_image/stb_image.h	/^   stbi_uc  fast[1 << FAST_BITS];$/;"	m	struct:__anon60
fast_ac	vendor/stb_image/stb_image.h	/^   stbi__int16 fast_ac[4][1 << FAST_BITS];$/;"	m	struct:__anon61
fdselect	vendor/imgui/imstb_truetype.h	/^   stbtt__buf fdselect;               \/\/ map from glyph to fontdict$/;"	m	struct:stbtt_fontinfo
fdualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef highp_fdualquat			fdualquat;$/;"	t	namespace:glm
fdualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef lowp_fdualquat			fdualquat;$/;"	t	namespace:glm
fdualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef mediump_fdualquat		fdualquat;$/;"	t	namespace:glm
fdx	vendor/imgui/imstb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge
fdy	vendor/imgui/imstb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge
filePath	Texture/Texture.h	/^	std::string 	filePath;$/;"	m	class:Texture
filepath	Shader/Shader.h	/^	std::string filepath;$/;"	m	class:Shader
fill_	vendor/glm/gtx/io.hpp	/^			char_type       fill_;$/;"	m	class:glm::io::basic_state_saver
first	vendor/stb_image/stb_image.h	/^   stbi_uc first;$/;"	m	struct:__anon71
first_char	vendor/imgui/imstb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon52
first_free	vendor/imgui/imstb_truetype.h	/^   void   *first_free;$/;"	m	struct:stbtt__hheap
first_row_filter	vendor/stb_image/stb_image.h	/^static stbi_uc first_row_filter[5] =$/;"	v
first_unicode_codepoint_in_range	vendor/imgui/imstb_truetype.h	/^   int first_unicode_codepoint_in_range;  \/\/ if non-zero, then the chars are continuous, and this is the first codepoint$/;"	m	struct:__anon33
first_x	vendor/imgui/imstb_truetype.h	/^   float first_x, first_y;$/;"	m	struct:__anon43
first_y	vendor/imgui/imstb_truetype.h	/^   float first_x, first_y;$/;"	m	struct:__anon43
firstcode	vendor/stb_image/stb_image.h	/^   stbi__uint16 firstcode[16];$/;"	m	struct:__anon64
firstsymbol	vendor/stb_image/stb_image.h	/^   stbi__uint16 firstsymbol[16];$/;"	m	struct:__anon64
flags	vendor/stb_image/stb_image.h	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:__anon72
flags_	vendor/glm/gtx/io.hpp	/^			flags_type      flags_;$/;"	m	class:glm::io::basic_state_saver
flags_type	vendor/glm/gtx/io.hpp	/^			typedef ::std::ios_base::fmtflags      flags_type;$/;"	t	class:glm::io::basic_state_saver
float1	vendor/glm/gtx/compatibility.hpp	/^	typedef float						float1;			\/\/!< \\brief single-qualifier floating-point vector with 1 component. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float1x1	vendor/glm/gtx/compatibility.hpp	/^	typedef float						float1x1;		\/\/!< \\brief single-qualifier floating-point matrix with 1 component. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float2	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<2, float, highp>		float2;			\/\/!< \\brief single-qualifier floating-point vector with 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float2x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 2, float, highp>		float2x2;		\/\/!< \\brief single-qualifier floating-point matrix with 2 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float2x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 3, float, highp>		float2x3;		\/\/!< \\brief single-qualifier floating-point matrix with 2 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float2x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 4, float, highp>		float2x4;		\/\/!< \\brief single-qualifier floating-point matrix with 2 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float3	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<3, float, highp>		float3;			\/\/!< \\brief single-qualifier floating-point vector with 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float32	vendor/glm/fwd.hpp	/^	typedef float					float32;$/;"	t	namespace:glm
float32	vendor/glm/gtc/type_precision.hpp	/^	typedef float float32;$/;"	t	namespace:glm
float32_t	vendor/glm/fwd.hpp	/^	typedef float					float32_t;$/;"	t	namespace:glm
float32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 float32_t;$/;"	t	namespace:glm
float32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_float32_t float32_t;$/;"	t	namespace:glm
float32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_float32_t float32_t;$/;"	t	namespace:glm
float32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_float32 float32_t;$/;"	t	namespace:glm
float3x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 2, float, highp>		float3x2;		\/\/!< \\brief single-qualifier floating-point matrix with 3 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float3x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 3, float, highp>		float3x3;		\/\/!< \\brief single-qualifier floating-point matrix with 3 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float3x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 4, float, highp>		float3x4;		\/\/!< \\brief single-qualifier floating-point matrix with 3 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float4	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<4, float, highp>		float4;			\/\/!< \\brief single-qualifier floating-point vector with 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float4x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 2, float, highp>		float4x2;		\/\/!< \\brief single-qualifier floating-point matrix with 4 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float4x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 3, float, highp>		float4x3;		\/\/!< \\brief single-qualifier floating-point matrix with 4 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float4x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 4, float, highp>		float4x4;		\/\/!< \\brief single-qualifier floating-point matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
float64	vendor/glm/fwd.hpp	/^	typedef double					float64;$/;"	t	namespace:glm
float64	vendor/glm/gtc/type_precision.hpp	/^	typedef double float64;$/;"	t	namespace:glm
float64_t	vendor/glm/fwd.hpp	/^	typedef double					float64_t;$/;"	t	namespace:glm
float64_t	vendor/glm/gtc/type_precision.hpp	/^		typedef float64 float64_t;$/;"	t	namespace:glm
float64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_float64_t float64_t;$/;"	t	namespace:glm
float64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_float64_t float64_t;$/;"	t	namespace:glm
float64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_float64 float64_t;$/;"	t	namespace:glm
float_t	vendor/glm/detail/type_float.hpp	/^		GLM_CONSTEXPR float_t(float_type Num = 0.0f) : f(Num) {}$/;"	f	union:glm::detail::float_t
float_t	vendor/glm/detail/type_float.hpp	/^		GLM_CONSTEXPR float_t(float_type Num = static_cast<float_type>(0)) : f(Num) {}$/;"	f	union:glm::detail::float_t
float_t	vendor/glm/detail/type_float.hpp	/^	union float_t$/;"	u	namespace:glm::detail
float_t	vendor/glm/detail/type_float.hpp	/^	union float_t<double>$/;"	u	namespace:glm::detail
float_t	vendor/glm/detail/type_float.hpp	/^	union float_t<float>$/;"	u	namespace:glm::detail
float_type	vendor/glm/detail/type_float.hpp	/^		typedef double float_type;$/;"	t	union:glm::detail::float_t
float_type	vendor/glm/detail/type_float.hpp	/^		typedef float float_type;$/;"	t	union:glm::detail::float_t
fmat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, defaultp>	fmat2;$/;"	t	namespace:glm
fmat2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f32, defaultp> fmat2;$/;"	t	namespace:glm
fmat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, defaultp>	fmat2x2;$/;"	t	namespace:glm
fmat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f32, defaultp> fmat2x2;$/;"	t	namespace:glm
fmat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, defaultp>	fmat2x3;$/;"	t	namespace:glm
fmat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f32, defaultp> fmat2x3;$/;"	t	namespace:glm
fmat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, defaultp>	fmat2x4;$/;"	t	namespace:glm
fmat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f32, defaultp> fmat2x4;$/;"	t	namespace:glm
fmat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, defaultp>	fmat3;$/;"	t	namespace:glm
fmat3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f32, defaultp> fmat3;$/;"	t	namespace:glm
fmat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, defaultp>	fmat3x2;$/;"	t	namespace:glm
fmat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f32, defaultp> fmat3x2;$/;"	t	namespace:glm
fmat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, defaultp>	fmat3x3;$/;"	t	namespace:glm
fmat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f32, defaultp> fmat3x3;$/;"	t	namespace:glm
fmat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, defaultp>	fmat3x4;$/;"	t	namespace:glm
fmat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f32, defaultp> fmat3x4;$/;"	t	namespace:glm
fmat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, defaultp>	fmat4;$/;"	t	namespace:glm
fmat4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f32, defaultp> fmat4;$/;"	t	namespace:glm
fmat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, defaultp>	fmat4x2;$/;"	t	namespace:glm
fmat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f32, defaultp> fmat4x2;$/;"	t	namespace:glm
fmat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, defaultp>	fmat4x3;$/;"	t	namespace:glm
fmat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f32, defaultp> fmat4x3;$/;"	t	namespace:glm
fmat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, defaultp>	fmat4x4;$/;"	t	namespace:glm
fmat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f32, defaultp> fmat4x4;$/;"	t	namespace:glm
font_size	vendor/imgui/imstb_truetype.h	/^   float font_size;$/;"	m	struct:__anon33
fontdicts	vendor/imgui/imstb_truetype.h	/^   stbtt__buf fontdicts;              \/\/ array of font dicts$/;"	m	struct:stbtt_fontinfo
fontstart	vendor/imgui/imstb_truetype.h	/^   int              fontstart;         \/\/ offset of start of font$/;"	m	struct:stbtt_fontinfo
format_punct	vendor/glm/gtx/io.hpp	/^		class format_punct : public std::locale::facet$/;"	c	namespace:glm::io
format_saver	vendor/glm/gtx/io.hpp	/^		typedef basic_format_saver<char>     format_saver;$/;"	t	namespace:glm::io
formatted	vendor/glm/gtx/io.hpp	/^			bool       formatted;$/;"	m	class:glm::io::format_punct
fquat	vendor/glm/fwd.hpp	/^	typedef qua<float, defaultp>		fquat;$/;"	t	namespace:glm
free_head	vendor/imgui/imstb_rectpack.h	/^   stbrp_node *free_head;$/;"	m	struct:stbrp_context
front	vendor/imgui/imgui.h	/^    inline T&           front()                             { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	struct:ImVector
front	vendor/imgui/imgui.h	/^    inline const T&     front() const                       { IM_ASSERT(Size > 0); return Data[0]; }$/;"	f	struct:ImVector
ftex	vendor/imgui/imstb_truetype.h	/^GLuint ftex;$/;"	v
functor1	vendor/glm/detail/_vectorize.hpp	/^	struct functor1<vec, 1, R, T, Q>$/;"	s	namespace:glm::detail
functor1	vendor/glm/detail/_vectorize.hpp	/^	struct functor1<vec, 2, R, T, Q>$/;"	s	namespace:glm::detail
functor1	vendor/glm/detail/_vectorize.hpp	/^	struct functor1<vec, 3, R, T, Q>$/;"	s	namespace:glm::detail
functor1	vendor/glm/detail/_vectorize.hpp	/^	struct functor1<vec, 4, R, T, Q>$/;"	s	namespace:glm::detail
functor1	vendor/glm/detail/_vectorize.hpp	/^	struct functor1{};$/;"	s	namespace:glm::detail
functor2	vendor/glm/detail/_vectorize.hpp	/^	struct functor2<vec, 1, T, Q>$/;"	s	namespace:glm::detail
functor2	vendor/glm/detail/_vectorize.hpp	/^	struct functor2<vec, 2, T, Q>$/;"	s	namespace:glm::detail
functor2	vendor/glm/detail/_vectorize.hpp	/^	struct functor2<vec, 3, T, Q>$/;"	s	namespace:glm::detail
functor2	vendor/glm/detail/_vectorize.hpp	/^	struct functor2<vec, 4, T, Q>$/;"	s	namespace:glm::detail
functor2	vendor/glm/detail/_vectorize.hpp	/^	struct functor2{};$/;"	s	namespace:glm::detail
functor2_vec_sca	vendor/glm/detail/_vectorize.hpp	/^	struct functor2_vec_sca<vec, 1, T, Q>$/;"	s	namespace:glm::detail
functor2_vec_sca	vendor/glm/detail/_vectorize.hpp	/^	struct functor2_vec_sca<vec, 2, T, Q>$/;"	s	namespace:glm::detail
functor2_vec_sca	vendor/glm/detail/_vectorize.hpp	/^	struct functor2_vec_sca<vec, 3, T, Q>$/;"	s	namespace:glm::detail
functor2_vec_sca	vendor/glm/detail/_vectorize.hpp	/^	struct functor2_vec_sca<vec, 4, T, Q>$/;"	s	namespace:glm::detail
functor2_vec_sca	vendor/glm/detail/_vectorize.hpp	/^	struct functor2_vec_sca{};$/;"	s	namespace:glm::detail
fvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f32, defaultp>		fvec1;$/;"	t	namespace:glm
fvec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, float, defaultp> fvec1;$/;"	t	namespace:glm
fvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f32, defaultp>		fvec2;$/;"	t	namespace:glm
fvec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, float, defaultp> fvec2;$/;"	t	namespace:glm
fvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f32, defaultp>		fvec3;$/;"	t	namespace:glm
fvec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, float, defaultp> fvec3;$/;"	t	namespace:glm
fvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f32, defaultp>		fvec4;$/;"	t	namespace:glm
fvec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, float, defaultp> fvec4;$/;"	t	namespace:glm
fx	vendor/imgui/imstb_truetype.h	/^   float fx,fdx,fdy;$/;"	m	struct:stbtt__active_edge
g	vendor/glm/detail/type_vec2.hpp	/^				struct{ T r, g; };$/;"	m	struct:glm::vec::__anon10::__anon12
g	vendor/glm/detail/type_vec2.hpp	/^			union {T y, g, t;};$/;"	m	union:glm::vec::__anon15
g	vendor/glm/detail/type_vec3.hpp	/^				struct{ T r, g, b; };$/;"	m	struct:glm::vec::__anon3::__anon5
g	vendor/glm/detail/type_vec3.hpp	/^			union { T y, g, t; };$/;"	m	union:glm::vec::__anon8
g	vendor/glm/detail/type_vec4.hpp	/^				struct { T r, g, b, a; };$/;"	m	struct:glm::vec::__anon18::__anon20
g	vendor/glm/detail/type_vec4.hpp	/^			union { T y, g, t; };$/;"	m	union:glm::vec::__anon23
g_AttribLocationProjMtx	vendor/imgui/imgui_impl_opengl3.cpp	/^static int          g_AttribLocationTex = 0, g_AttribLocationProjMtx = 0;                                \/\/ Uniforms location$/;"	v	file:
g_AttribLocationTex	vendor/imgui/imgui_impl_opengl3.cpp	/^static int          g_AttribLocationTex = 0, g_AttribLocationProjMtx = 0;                                \/\/ Uniforms location$/;"	v	file:
g_AttribLocationVtxColor	vendor/imgui/imgui_impl_opengl3.cpp	/^static int          g_AttribLocationVtxPos = 0, g_AttribLocationVtxUV = 0, g_AttribLocationVtxColor = 0; \/\/ Vertex attributes location$/;"	v	file:
g_AttribLocationVtxPos	vendor/imgui/imgui_impl_opengl3.cpp	/^static int          g_AttribLocationVtxPos = 0, g_AttribLocationVtxUV = 0, g_AttribLocationVtxColor = 0; \/\/ Vertex attributes location$/;"	v	file:
g_AttribLocationVtxUV	vendor/imgui/imgui_impl_opengl3.cpp	/^static int          g_AttribLocationVtxPos = 0, g_AttribLocationVtxUV = 0, g_AttribLocationVtxColor = 0; \/\/ Vertex attributes location$/;"	v	file:
g_ClientApi	vendor/imgui/imgui_impl_glfw.cpp	/^static GlfwClientApi        g_ClientApi = GlfwClientApi_Unknown;$/;"	v	file:
g_ElementsHandle	vendor/imgui/imgui_impl_opengl3.cpp	/^static unsigned int g_VboHandle = 0, g_ElementsHandle = 0;$/;"	v	file:
g_FontTexture	vendor/imgui/imgui_impl_opengl3.cpp	/^static GLuint       g_FontTexture = 0;$/;"	v	file:
g_FragHandle	vendor/imgui/imgui_impl_opengl3.cpp	/^static GLuint       g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;$/;"	v	file:
g_GlslVersionString	vendor/imgui/imgui_impl_opengl3.cpp	/^static char         g_GlslVersionString[32] = "";$/;"	v	file:
g_MouseCursors	vendor/imgui/imgui_impl_glfw.cpp	/^static GLFWcursor*          g_MouseCursors[ImGuiMouseCursor_COUNT] = { 0 };$/;"	v	file:
g_MouseJustPressed	vendor/imgui/imgui_impl_glfw.cpp	/^static bool                 g_MouseJustPressed[5] = { false, false, false, false, false };$/;"	v	file:
g_PrevUserCallbackChar	vendor/imgui/imgui_impl_glfw.cpp	/^static GLFWcharfun          g_PrevUserCallbackChar = NULL;$/;"	v	file:
g_PrevUserCallbackKey	vendor/imgui/imgui_impl_glfw.cpp	/^static GLFWkeyfun           g_PrevUserCallbackKey = NULL;$/;"	v	file:
g_PrevUserCallbackMousebutton	vendor/imgui/imgui_impl_glfw.cpp	/^static GLFWmousebuttonfun   g_PrevUserCallbackMousebutton = NULL;$/;"	v	file:
g_PrevUserCallbackScroll	vendor/imgui/imgui_impl_glfw.cpp	/^static GLFWscrollfun        g_PrevUserCallbackScroll = NULL;$/;"	v	file:
g_ShaderHandle	vendor/imgui/imgui_impl_opengl3.cpp	/^static GLuint       g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;$/;"	v	file:
g_Time	vendor/imgui/imgui_impl_glfw.cpp	/^static double               g_Time = 0.0;$/;"	v	file:
g_VboHandle	vendor/imgui/imgui_impl_opengl3.cpp	/^static unsigned int g_VboHandle = 0, g_ElementsHandle = 0;$/;"	v	file:
g_VertHandle	vendor/imgui/imgui_impl_opengl3.cpp	/^static GLuint       g_ShaderHandle = 0, g_VertHandle = 0, g_FragHandle = 0;$/;"	v	file:
g_Window	vendor/imgui/imgui_impl_glfw.cpp	/^static GLFWwindow*          g_Window = NULL;    \/\/ Main window$/;"	v	file:
genTypeEnum	vendor/glm/detail/qualifier.hpp	/^	enum genTypeEnum$/;"	g	namespace:glm::detail
genTypeTrait	vendor/glm/detail/qualifier.hpp	/^	struct genTypeTrait$/;"	s	namespace:glm::detail
genTypeTrait	vendor/glm/detail/qualifier.hpp	/^	struct genTypeTrait<mat<C, R, T> >$/;"	s	namespace:glm::detail
glm	vendor/glm/common.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/_noise.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/detail/_swizzle.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/_swizzle.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/detail/_vectorize.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/detail/compute_common.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/detail/compute_vector_relational.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/detail/glm.cpp	/^namespace glm$/;"	n	file:
glm	vendor/glm/detail/qualifier.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/setup.hpp	/^	namespace glm$/;"	n
glm	vendor/glm/detail/setup.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/setup.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/detail/type_float.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/detail/type_half.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/detail/type_mat2x2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_mat2x3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_mat2x4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_mat3x2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_mat3x3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_mat3x4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_mat4x2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_mat4x3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_mat4x4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_quat.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_vec1.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_vec2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_vec3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/detail/type_vec4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/exponential.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_clip_space.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_common.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double2x2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double2x2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double2x3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double2x3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double2x4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double2x4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double3x2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double3x2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double3x3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double3x3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double3x4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double3x4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double4x2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double4x2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double4x3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double4x3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double4x4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_double4x4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float2x2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float2x2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float2x3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float2x3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float2x4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float2x4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float3x2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float3x2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float3x3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float3x3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float3x4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float3x4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float4x2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float4x2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float4x3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float4x3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float4x4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_float4x4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_projection.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_relational.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/matrix_transform.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/quaternion_common.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/quaternion_double.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/quaternion_double_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/quaternion_exponential.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/quaternion_float.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/quaternion_float_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/quaternion_geometric.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/quaternion_relational.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/quaternion_transform.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/quaternion_trigonometric.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/scalar_common.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/scalar_constants.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/scalar_int_sized.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/ext/scalar_relational.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/scalar_uint_sized.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/ext/scalar_ulp.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_bool1.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_bool1_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_bool2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_bool2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_bool3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_bool3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_bool4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_bool4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_common.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_double1.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_double1_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_double2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_double2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_double3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_double3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_double4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_double4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_float1.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_float1_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_float2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_float2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_float3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_float3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_float4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_float4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_int1.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_int1_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_int2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_int2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_int3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_int3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_int4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_int4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_relational.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_uint1.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_uint1_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_uint2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_uint2_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_uint3.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_uint3_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_uint4.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_uint4_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/ext/vector_ulp.hpp	/^namespace glm$/;"	n
glm	vendor/glm/fwd.hpp	/^namespace glm$/;"	n
glm	vendor/glm/geometric.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/bitfield.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/color_space.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/constants.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/epsilon.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/integer.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/matrix_access.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/matrix_integer.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/matrix_inverse.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/noise.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/packing.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/quaternion.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/random.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/reciprocal.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/round.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/type_aligned.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/type_precision.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtc/type_ptr.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/associated_min_max.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/bit.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/closest_point.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/color_encoding.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/color_space.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/color_space_YCoCg.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/common.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/compatibility.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/component_wise.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/dual_quaternion.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/easing.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/gtx/euler_angles.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/extend.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/extended_min_max.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/exterior_product.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/fast_exponential.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/fast_square_root.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/fast_trigonometry.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/functions.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/gradient_paint.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/handed_coordinate_space.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/integer.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/intersect.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/io.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/log_base.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/matrix_cross_product.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/matrix_decompose.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/matrix_factorisation.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/matrix_interpolation.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/matrix_major_storage.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/matrix_operation.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/matrix_query.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/matrix_transform_2d.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/mixed_product.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/norm.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/normal.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/normalize_dot.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/number_precision.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/gtx/optimum_pow.hpp	/^namespace glm{$/;"	n
glm	vendor/glm/gtx/orthonormalize.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/perpendicular.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/polar_coordinates.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/projection.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/quaternion.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/range.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/raw_data.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/rotate_normalized_axis.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/rotate_vector.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/scalar_multiplication.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/scalar_relational.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/spline.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/std_based_type.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/string_cast.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/texture.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/transform.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/transform2.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/type_aligned.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/type_trait.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/vec_swizzle.hpp	/^namespace glm {$/;"	n
glm	vendor/glm/gtx/vector_angle.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/vector_query.hpp	/^namespace glm$/;"	n
glm	vendor/glm/gtx/wrap.hpp	/^namespace glm$/;"	n
glm	vendor/glm/integer.hpp	/^namespace glm$/;"	n
glm	vendor/glm/matrix.hpp	/^namespace glm {$/;"	n
glm	vendor/glm/packing.hpp	/^namespace glm$/;"	n
glm	vendor/glm/trigonometric.hpp	/^namespace glm$/;"	n
glm	vendor/glm/vector_relational.hpp	/^namespace glm$/;"	n
glm_dvec2	vendor/glm/simd/platform.h	/^	typedef glm_f64vec2		glm_dvec2;$/;"	t
glm_dvec4	vendor/glm/simd/platform.h	/^	typedef glm_f64vec4		glm_dvec4;$/;"	t
glm_f32vec4	vendor/glm/simd/platform.h	/^	typedef __m128			glm_f32vec4;$/;"	t
glm_f64vec2	vendor/glm/simd/platform.h	/^	typedef __m128d			glm_f64vec2;$/;"	t
glm_f64vec4	vendor/glm/simd/platform.h	/^	typedef __m256d			glm_f64vec4;$/;"	t
glm_i128_interleave	vendor/glm/simd/integer.h	/^GLM_FUNC_QUALIFIER glm_uvec4 glm_i128_interleave(glm_uvec4 x)$/;"	f
glm_i128_interleave2	vendor/glm/simd/integer.h	/^GLM_FUNC_QUALIFIER glm_uvec4 glm_i128_interleave2(glm_uvec4 x, glm_uvec4 y)$/;"	f
glm_i32vec4	vendor/glm/simd/platform.h	/^	typedef __m128i			glm_i32vec4;$/;"	t
glm_i64vec2	vendor/glm/simd/platform.h	/^	typedef __m128i			glm_i64vec2;$/;"	t
glm_i64vec4	vendor/glm/simd/platform.h	/^	typedef __m256i			glm_i64vec4;$/;"	t
glm_ivec4	vendor/glm/simd/platform.h	/^	typedef glm_i32vec4		glm_ivec4;$/;"	t
glm_ivec4_abs	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_ivec4 glm_ivec4_abs(glm_ivec4 x)$/;"	f
glm_mat4_add	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER void glm_mat4_add(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])$/;"	f
glm_mat4_determinant	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_mat4_determinant(glm_vec4 const m[4])$/;"	f
glm_mat4_determinant_highp	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_mat4_determinant_highp(glm_vec4 const in[4])$/;"	f
glm_mat4_determinant_lowp	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_mat4_determinant_lowp(glm_vec4 const m[4])$/;"	f
glm_mat4_inverse	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER void glm_mat4_inverse(glm_vec4 const in[4], glm_vec4 out[4])$/;"	f
glm_mat4_inverse_lowp	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER void glm_mat4_inverse_lowp(glm_vec4 const in[4], glm_vec4 out[4])$/;"	f
glm_mat4_matrixCompMult	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER void glm_mat4_matrixCompMult(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])$/;"	f
glm_mat4_mul	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER void glm_mat4_mul(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])$/;"	f
glm_mat4_mul_vec4	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_mat4_mul_vec4(glm_vec4 const m[4], glm_vec4 v)$/;"	f
glm_mat4_outerProduct	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER void glm_mat4_outerProduct(__m128 const& c, __m128 const& r, __m128 out[4])$/;"	f
glm_mat4_sub	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER void glm_mat4_sub(glm_vec4 const in1[4], glm_vec4 const in2[4], glm_vec4 out[4])$/;"	f
glm_mat4_transpose	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER void glm_mat4_transpose(glm_vec4 const in[4], glm_vec4 out[4])$/;"	f
glm_u32vec4	vendor/glm/simd/platform.h	/^	typedef __m128i			glm_u32vec4;$/;"	t
glm_u64vec2	vendor/glm/simd/platform.h	/^	typedef __m128i			glm_u64vec2;$/;"	t
glm_u64vec4	vendor/glm/simd/platform.h	/^	typedef __m256i			glm_u64vec4;$/;"	t
glm_uvec4	vendor/glm/simd/platform.h	/^	typedef glm_u32vec4		glm_uvec4;$/;"	t
glm_vec1_add	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec1_add(glm_f32vec4 a, glm_f32vec4 b)$/;"	f
glm_vec1_div	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec1_div(glm_f32vec4 a, glm_f32vec4 b)$/;"	f
glm_vec1_dot	vendor/glm/simd/geometric.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec1_dot(glm_vec4 v1, glm_vec4 v2)$/;"	f
glm_vec1_fma	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec1_fma(glm_f32vec4 a, glm_f32vec4 b, glm_f32vec4 c)$/;"	f
glm_vec1_mul	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec1_mul(glm_f32vec4 a, glm_f32vec4 b)$/;"	f
glm_vec1_sqrt_lowp	vendor/glm/simd/exponential.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec1_sqrt_lowp(glm_f32vec4 x)$/;"	f
glm_vec1_sub	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec1_sub(glm_f32vec4 a, glm_f32vec4 b)$/;"	f
glm_vec4	vendor/glm/simd/platform.h	/^	typedef glm_f32vec4		glm_vec4;$/;"	t
glm_vec4_abs	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec4_abs(glm_f32vec4 x)$/;"	f
glm_vec4_add	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec4_add(glm_f32vec4 a, glm_f32vec4 b)$/;"	f
glm_vec4_ceil	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_ceil(glm_vec4 x)$/;"	f
glm_vec4_clamp	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_clamp(glm_vec4 v, glm_vec4 minVal, glm_vec4 maxVal)$/;"	f
glm_vec4_cross	vendor/glm/simd/geometric.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_cross(glm_vec4 v1, glm_vec4 v2)$/;"	f
glm_vec4_distance	vendor/glm/simd/geometric.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_distance(glm_vec4 p0, glm_vec4 p1)$/;"	f
glm_vec4_div	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec4_div(glm_f32vec4 a, glm_f32vec4 b)$/;"	f
glm_vec4_div_lowp	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec4_div_lowp(glm_f32vec4 a, glm_f32vec4 b)$/;"	f
glm_vec4_dot	vendor/glm/simd/geometric.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_dot(glm_vec4 v1, glm_vec4 v2)$/;"	f
glm_vec4_faceforward	vendor/glm/simd/geometric.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_faceforward(glm_vec4 N, glm_vec4 I, glm_vec4 Nref)$/;"	f
glm_vec4_floor	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_floor(glm_vec4 x)$/;"	f
glm_vec4_fma	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec4_fma(glm_f32vec4 a, glm_f32vec4 b, glm_f32vec4 c)$/;"	f
glm_vec4_fract	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_fract(glm_vec4 x)$/;"	f
glm_vec4_inf	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_inf(glm_vec4 x)$/;"	f
glm_vec4_length	vendor/glm/simd/geometric.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_length(glm_vec4 x)$/;"	f
glm_vec4_mix	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_mix(glm_vec4 v1, glm_vec4 v2, glm_vec4 a)$/;"	f
glm_vec4_mod	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_mod(glm_vec4 x, glm_vec4 y)$/;"	f
glm_vec4_mul	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec4_mul(glm_f32vec4 a, glm_f32vec4 b)$/;"	f
glm_vec4_mul_mat4	vendor/glm/simd/matrix.h	/^GLM_FUNC_QUALIFIER __m128 glm_vec4_mul_mat4(glm_vec4 v, glm_vec4 const m[4])$/;"	f
glm_vec4_nan	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_nan(glm_vec4 x)$/;"	f
glm_vec4_normalize	vendor/glm/simd/geometric.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_normalize(glm_vec4 v)$/;"	f
glm_vec4_reflect	vendor/glm/simd/geometric.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_reflect(glm_vec4 I, glm_vec4 N)$/;"	f
glm_vec4_refract	vendor/glm/simd/geometric.h	/^GLM_FUNC_QUALIFIER __m128 glm_vec4_refract(glm_vec4 I, glm_vec4 N, glm_vec4 eta)$/;"	f
glm_vec4_round	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_round(glm_vec4 x)$/;"	f
glm_vec4_roundEven	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_roundEven(glm_vec4 x)$/;"	f
glm_vec4_sign	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_sign(glm_vec4 x)$/;"	f
glm_vec4_smoothstep	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_smoothstep(glm_vec4 edge0, glm_vec4 edge1, glm_vec4 x)$/;"	f
glm_vec4_sqrt_lowp	vendor/glm/simd/exponential.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec4_sqrt_lowp(glm_f32vec4 x)$/;"	f
glm_vec4_step	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_vec4 glm_vec4_step(glm_vec4 edge, glm_vec4 x)$/;"	f
glm_vec4_sub	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec4_sub(glm_f32vec4 a, glm_f32vec4 b)$/;"	f
glm_vec4_swizzle_xyzw	vendor/glm/simd/common.h	/^GLM_FUNC_QUALIFIER glm_f32vec4 glm_vec4_swizzle_xyzw(glm_f32vec4 a)$/;"	f
glyf	vendor/imgui/imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
gpos	vendor/imgui/imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
gsubrs	vendor/imgui/imstb_truetype.h	/^   stbtt__buf gsubrs;                 \/\/ global charstring subroutines index$/;"	m	struct:stbtt_fontinfo
gtx	vendor/glm/gtx/number_precision.hpp	/^namespace gtx$/;"	n	namespace:glm
gtx	vendor/glm/gtx/optimum_pow.hpp	/^namespace gtx$/;"	n	namespace:glm
h	vendor/imgui/imstb_rectpack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect
h	vendor/imgui/imstb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
h	vendor/imgui/imstb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon36
h	vendor/stb_image/stb_image.h	/^      int h,v;$/;"	m	struct:__anon61::__anon62
h	vendor/stb_image/stb_image.h	/^   int w,h;$/;"	m	struct:__anon72
h2	vendor/stb_image/stb_image.h	/^      int x,y,w2,h2;$/;"	m	struct:__anon61::__anon62
h_oversample	vendor/imgui/imstb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon33
h_oversample	vendor/imgui/imstb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context
ha	vendor/stb_image/stb_image.h	/^      int hd,ha;$/;"	m	struct:__anon61::__anon62
has_preferred_x	vendor/imgui/imstb_textedit.h	/^   unsigned char has_preferred_x;$/;"	m	struct:__anon50
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::mat<2, 2, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::mat<2, 3, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::mat<2, 4, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::mat<3, 2, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::mat<3, 3, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::mat<3, 4, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::mat<4, 2, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::mat<4, 3, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::mat<4, 4, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::tdualquat<T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::tquat<T,Q>>$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::vec<1, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::vec<2, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::vec<3, T,Q> >$/;"	s	namespace:std
hash	vendor/glm/gtx/hash.hpp	/^	struct hash<glm::vec<4, T,Q> >$/;"	s	namespace:std
hd	vendor/stb_image/stb_image.h	/^      int hd,ha;$/;"	m	struct:__anon61::__anon62
hdata	vendor/glm/detail/type_half.hpp	/^	typedef short hdata;$/;"	t	namespace:glm::detail
head	vendor/imgui/imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
head	vendor/imgui/imstb_truetype.h	/^   struct stbtt__hheap_chunk *head;$/;"	m	struct:stbtt__hheap	typeref:struct:stbtt__hheap::stbtt__hheap_chunk
height	Texture/Texture.h	/^	int				height;$/;"	m	class:Texture
height	vendor/imgui/imstb_rectpack.h	/^   int height;$/;"	m	struct:stbrp_context
height	vendor/imgui/imstb_textedit.h	/^   float height; \/\/ height of line$/;"	m	struct:__anon52
height	vendor/imgui/imstb_truetype.h	/^   int   height;$/;"	m	struct:stbtt_pack_context
height	vendor/imgui/imstb_truetype.h	/^   int width,height;$/;"	m	struct:__anon45
heuristic	vendor/imgui/imstb_rectpack.h	/^   int heuristic;$/;"	m	struct:stbrp_context
hhea	vendor/imgui/imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
highp	vendor/glm/detail/qualifier.hpp	/^		highp = packed_highp, \/\/\/< By default highp qualifier is also packed$/;"	e	enum:glm::qualifier
highp_bvec1	vendor/glm/ext/vector_bool1_precision.hpp	/^	typedef vec<1, bool, highp>			highp_bvec1;$/;"	t	namespace:glm
highp_bvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, bool, highp>		highp_bvec1;$/;"	t	namespace:glm
highp_bvec2	vendor/glm/ext/vector_bool2_precision.hpp	/^	typedef vec<2, bool, highp>		highp_bvec2;$/;"	t	namespace:glm
highp_bvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, bool, highp>		highp_bvec2;$/;"	t	namespace:glm
highp_bvec3	vendor/glm/ext/vector_bool3_precision.hpp	/^	typedef vec<3, bool, highp>		highp_bvec3;$/;"	t	namespace:glm
highp_bvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, bool, highp>		highp_bvec3;$/;"	t	namespace:glm
highp_bvec4	vendor/glm/ext/vector_bool4_precision.hpp	/^	typedef vec<4, bool, highp>		highp_bvec4;$/;"	t	namespace:glm
highp_bvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, bool, highp>		highp_bvec4;$/;"	t	namespace:glm
highp_ddualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef tdualquat<double, highp>	highp_ddualquat;$/;"	t	namespace:glm
highp_dmat2	vendor/glm/ext/matrix_double2x2_precision.hpp	/^	typedef mat<2, 2, double, highp>	highp_dmat2;$/;"	t	namespace:glm
highp_dmat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, highp>		highp_dmat2;$/;"	t	namespace:glm
highp_dmat2x2	vendor/glm/ext/matrix_double2x2_precision.hpp	/^	typedef mat<2, 2, double, highp>	highp_dmat2x2;$/;"	t	namespace:glm
highp_dmat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, double, highp>	highp_dmat2x2;$/;"	t	namespace:glm
highp_dmat2x3	vendor/glm/ext/matrix_double2x3_precision.hpp	/^	typedef mat<2, 3, double, highp>	highp_dmat2x3;$/;"	t	namespace:glm
highp_dmat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, double, highp>	highp_dmat2x3;$/;"	t	namespace:glm
highp_dmat2x4	vendor/glm/ext/matrix_double2x4_precision.hpp	/^	typedef mat<2, 4, double, highp>	highp_dmat2x4;$/;"	t	namespace:glm
highp_dmat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, double, highp>	highp_dmat2x4;$/;"	t	namespace:glm
highp_dmat3	vendor/glm/ext/matrix_double3x3_precision.hpp	/^	typedef mat<3, 3, double, highp>	highp_dmat3;$/;"	t	namespace:glm
highp_dmat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, highp>		highp_dmat3;$/;"	t	namespace:glm
highp_dmat3x2	vendor/glm/ext/matrix_double3x2_precision.hpp	/^	typedef mat<3, 2, double, highp>	highp_dmat3x2;$/;"	t	namespace:glm
highp_dmat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, double, highp>	highp_dmat3x2;$/;"	t	namespace:glm
highp_dmat3x3	vendor/glm/ext/matrix_double3x3_precision.hpp	/^	typedef mat<3, 3, double, highp>	highp_dmat3x3;$/;"	t	namespace:glm
highp_dmat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, double, highp>	highp_dmat3x3;$/;"	t	namespace:glm
highp_dmat3x4	vendor/glm/ext/matrix_double3x4_precision.hpp	/^	typedef mat<3, 4, double, highp>	highp_dmat3x4;$/;"	t	namespace:glm
highp_dmat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, double, highp>	highp_dmat3x4;$/;"	t	namespace:glm
highp_dmat4	vendor/glm/ext/matrix_double4x4_precision.hpp	/^	typedef mat<4, 4, double, highp>	highp_dmat4;$/;"	t	namespace:glm
highp_dmat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, highp>		highp_dmat4;$/;"	t	namespace:glm
highp_dmat4x2	vendor/glm/ext/matrix_double4x2_precision.hpp	/^	typedef mat<4, 2, double, highp>	highp_dmat4x2;$/;"	t	namespace:glm
highp_dmat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, double, highp>	highp_dmat4x2;$/;"	t	namespace:glm
highp_dmat4x3	vendor/glm/ext/matrix_double4x3_precision.hpp	/^	typedef mat<4, 3, double, highp>	highp_dmat4x3;$/;"	t	namespace:glm
highp_dmat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, double, highp>	highp_dmat4x3;$/;"	t	namespace:glm
highp_dmat4x4	vendor/glm/ext/matrix_double4x4_precision.hpp	/^	typedef mat<4, 4, double, highp>	highp_dmat4x4;$/;"	t	namespace:glm
highp_dmat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, double, highp>	highp_dmat4x4;$/;"	t	namespace:glm
highp_dquat	vendor/glm/ext/quaternion_double_precision.hpp	/^	typedef qua<double, highp>		highp_dquat;$/;"	t	namespace:glm
highp_dquat	vendor/glm/fwd.hpp	/^	typedef qua<double, highp>			highp_dquat;$/;"	t	namespace:glm
highp_dualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef tdualquat<float, highp>		highp_dualquat;$/;"	t	namespace:glm
highp_dvec1	vendor/glm/ext/vector_double1_precision.hpp	/^	typedef vec<1, double, highp>		highp_dvec1;$/;"	t	namespace:glm
highp_dvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f64, highp>			highp_dvec1;$/;"	t	namespace:glm
highp_dvec2	vendor/glm/ext/vector_double2_precision.hpp	/^	typedef vec<2, double, highp>		highp_dvec2;$/;"	t	namespace:glm
highp_dvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f64, highp>			highp_dvec2;$/;"	t	namespace:glm
highp_dvec3	vendor/glm/ext/vector_double3_precision.hpp	/^	typedef vec<3, double, highp>		highp_dvec3;$/;"	t	namespace:glm
highp_dvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f64, highp>			highp_dvec3;$/;"	t	namespace:glm
highp_dvec4	vendor/glm/ext/vector_double4_precision.hpp	/^	typedef vec<4, double, highp>		highp_dvec4;$/;"	t	namespace:glm
highp_dvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f64, highp>			highp_dvec4;$/;"	t	namespace:glm
highp_f32	vendor/glm/fwd.hpp	/^	typedef float					highp_f32;$/;"	t	namespace:glm
highp_f32	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 highp_f32;$/;"	t	namespace:glm
highp_f32mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, highp>		highp_f32mat2;$/;"	t	namespace:glm
highp_f32mat2	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_f32mat2x2 highp_f32mat2;$/;"	t	namespace:glm
highp_f32mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, highp>		highp_f32mat2x2;$/;"	t	namespace:glm
highp_f32mat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f32, highp> highp_f32mat2x2;$/;"	t	namespace:glm
highp_f32mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, highp>		highp_f32mat2x3;$/;"	t	namespace:glm
highp_f32mat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f32, highp> highp_f32mat2x3;$/;"	t	namespace:glm
highp_f32mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, highp>		highp_f32mat2x4;$/;"	t	namespace:glm
highp_f32mat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f32, highp> highp_f32mat2x4;$/;"	t	namespace:glm
highp_f32mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, highp>		highp_f32mat3;$/;"	t	namespace:glm
highp_f32mat3	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_f32mat3x3 highp_f32mat3;$/;"	t	namespace:glm
highp_f32mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, highp>		highp_f32mat3x2;$/;"	t	namespace:glm
highp_f32mat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f32, highp> highp_f32mat3x2;$/;"	t	namespace:glm
highp_f32mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, highp>		highp_f32mat3x3;$/;"	t	namespace:glm
highp_f32mat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f32, highp> highp_f32mat3x3;$/;"	t	namespace:glm
highp_f32mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, highp>		highp_f32mat3x4;$/;"	t	namespace:glm
highp_f32mat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f32, highp> highp_f32mat3x4;$/;"	t	namespace:glm
highp_f32mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, highp>		highp_f32mat4;$/;"	t	namespace:glm
highp_f32mat4	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_f32mat4x4 highp_f32mat4;$/;"	t	namespace:glm
highp_f32mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, highp>		highp_f32mat4x2;$/;"	t	namespace:glm
highp_f32mat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f32, highp> highp_f32mat4x2;$/;"	t	namespace:glm
highp_f32mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, highp>		highp_f32mat4x3;$/;"	t	namespace:glm
highp_f32mat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f32, highp> highp_f32mat4x3;$/;"	t	namespace:glm
highp_f32mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, highp>		highp_f32mat4x4;$/;"	t	namespace:glm
highp_f32mat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f32, highp> highp_f32mat4x4;$/;"	t	namespace:glm
highp_f32quat	vendor/glm/fwd.hpp	/^	typedef qua<f32, highp>				highp_f32quat;$/;"	t	namespace:glm
highp_f32quat	vendor/glm/gtc/type_precision.hpp	/^	typedef qua<f32, highp> highp_f32quat;$/;"	t	namespace:glm
highp_f32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f32, highp>			highp_f32vec1;$/;"	t	namespace:glm
highp_f32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, f32, highp> highp_f32vec1;$/;"	t	namespace:glm
highp_f32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f32, highp>			highp_f32vec2;$/;"	t	namespace:glm
highp_f32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, f32, highp> highp_f32vec2;$/;"	t	namespace:glm
highp_f32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f32, highp>			highp_f32vec3;$/;"	t	namespace:glm
highp_f32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, f32, highp> highp_f32vec3;$/;"	t	namespace:glm
highp_f32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f32, highp>			highp_f32vec4;$/;"	t	namespace:glm
highp_f32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, f32, highp> highp_f32vec4;$/;"	t	namespace:glm
highp_f64	vendor/glm/fwd.hpp	/^	typedef double					highp_f64;$/;"	t	namespace:glm
highp_f64	vendor/glm/gtc/type_precision.hpp	/^	typedef float64 highp_f64;$/;"	t	namespace:glm
highp_f64mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, highp>		highp_f64mat2;$/;"	t	namespace:glm
highp_f64mat2	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_f64mat2x2 highp_f64mat2;$/;"	t	namespace:glm
highp_f64mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, highp>		highp_f64mat2x2;$/;"	t	namespace:glm
highp_f64mat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f64, highp> highp_f64mat2x2;$/;"	t	namespace:glm
highp_f64mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f64, highp>		highp_f64mat2x3;$/;"	t	namespace:glm
highp_f64mat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f64, highp> highp_f64mat2x3;$/;"	t	namespace:glm
highp_f64mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f64, highp>		highp_f64mat2x4;$/;"	t	namespace:glm
highp_f64mat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f64, highp> highp_f64mat2x4;$/;"	t	namespace:glm
highp_f64mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, highp>		highp_f64mat3;$/;"	t	namespace:glm
highp_f64mat3	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_f64mat3x3 highp_f64mat3;$/;"	t	namespace:glm
highp_f64mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f64, highp>		highp_f64mat3x2;$/;"	t	namespace:glm
highp_f64mat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f64, highp> highp_f64mat3x2;$/;"	t	namespace:glm
highp_f64mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, highp>		highp_f64mat3x3;$/;"	t	namespace:glm
highp_f64mat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f64, highp> highp_f64mat3x3;$/;"	t	namespace:glm
highp_f64mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f64, highp>		highp_f64mat3x4;$/;"	t	namespace:glm
highp_f64mat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f64, highp> highp_f64mat3x4;$/;"	t	namespace:glm
highp_f64mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, highp>		highp_f64mat4;$/;"	t	namespace:glm
highp_f64mat4	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_f64mat4x4 highp_f64mat4;$/;"	t	namespace:glm
highp_f64mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f64, highp>		highp_f64mat4x2;$/;"	t	namespace:glm
highp_f64mat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f64, highp> highp_f64mat4x2;$/;"	t	namespace:glm
highp_f64mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f64, highp>		highp_f64mat4x3;$/;"	t	namespace:glm
highp_f64mat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f64, highp> highp_f64mat4x3;$/;"	t	namespace:glm
highp_f64mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, highp>		highp_f64mat4x4;$/;"	t	namespace:glm
highp_f64mat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f64, highp> highp_f64mat4x4;$/;"	t	namespace:glm
highp_f64quat	vendor/glm/fwd.hpp	/^	typedef qua<f64, highp>				highp_f64quat;$/;"	t	namespace:glm
highp_f64quat	vendor/glm/gtc/type_precision.hpp	/^	typedef qua<f64, highp> highp_f64quat;$/;"	t	namespace:glm
highp_f64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f64, highp>			highp_f64vec1;$/;"	t	namespace:glm
highp_f64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, f64, highp> highp_f64vec1;$/;"	t	namespace:glm
highp_f64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f64, highp>			highp_f64vec2;$/;"	t	namespace:glm
highp_f64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, f64, highp> highp_f64vec2;$/;"	t	namespace:glm
highp_f64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f64, highp>			highp_f64vec3;$/;"	t	namespace:glm
highp_f64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, f64, highp> highp_f64vec3;$/;"	t	namespace:glm
highp_f64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f64, highp>			highp_f64vec4;$/;"	t	namespace:glm
highp_f64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, f64, highp> highp_f64vec4;$/;"	t	namespace:glm
highp_fdualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef tdualquat<float, highp>		highp_fdualquat;$/;"	t	namespace:glm
highp_float32	vendor/glm/fwd.hpp	/^	typedef float					highp_float32;$/;"	t	namespace:glm
highp_float32	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 highp_float32;$/;"	t	namespace:glm
highp_float32_t	vendor/glm/fwd.hpp	/^	typedef float					highp_float32_t;$/;"	t	namespace:glm
highp_float32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 highp_float32_t;$/;"	t	namespace:glm
highp_float64	vendor/glm/fwd.hpp	/^	typedef double					highp_float64;$/;"	t	namespace:glm
highp_float64	vendor/glm/gtc/type_precision.hpp	/^	typedef float64 highp_float64;$/;"	t	namespace:glm
highp_float64_t	vendor/glm/fwd.hpp	/^	typedef double					highp_float64_t;$/;"	t	namespace:glm
highp_float64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef float64 highp_float64_t;$/;"	t	namespace:glm
highp_fmat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, highp>		highp_fmat2;$/;"	t	namespace:glm
highp_fmat2	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_fmat2x2 highp_fmat2;$/;"	t	namespace:glm
highp_fmat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, highp>		highp_fmat2x2;$/;"	t	namespace:glm
highp_fmat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f32, highp> highp_fmat2x2;$/;"	t	namespace:glm
highp_fmat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, highp>		highp_fmat2x3;$/;"	t	namespace:glm
highp_fmat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f32, highp> highp_fmat2x3;$/;"	t	namespace:glm
highp_fmat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, highp>		highp_fmat2x4;$/;"	t	namespace:glm
highp_fmat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f32, highp> highp_fmat2x4;$/;"	t	namespace:glm
highp_fmat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, highp>		highp_fmat3;$/;"	t	namespace:glm
highp_fmat3	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_fmat3x3 highp_fmat3;$/;"	t	namespace:glm
highp_fmat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, highp>		highp_fmat3x2;$/;"	t	namespace:glm
highp_fmat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f32, highp> highp_fmat3x2;$/;"	t	namespace:glm
highp_fmat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, highp>		highp_fmat3x3;$/;"	t	namespace:glm
highp_fmat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f32, highp> highp_fmat3x3;$/;"	t	namespace:glm
highp_fmat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, highp>		highp_fmat3x4;$/;"	t	namespace:glm
highp_fmat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f32, highp> highp_fmat3x4;$/;"	t	namespace:glm
highp_fmat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, highp>		highp_fmat4;$/;"	t	namespace:glm
highp_fmat4	vendor/glm/gtc/type_precision.hpp	/^	typedef highp_fmat4x4 highp_fmat4;$/;"	t	namespace:glm
highp_fmat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, highp>		highp_fmat4x2;$/;"	t	namespace:glm
highp_fmat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f32, highp> highp_fmat4x2;$/;"	t	namespace:glm
highp_fmat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, highp>		highp_fmat4x3;$/;"	t	namespace:glm
highp_fmat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f32, highp> highp_fmat4x3;$/;"	t	namespace:glm
highp_fmat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, highp>		highp_fmat4x4;$/;"	t	namespace:glm
highp_fmat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f32, highp> highp_fmat4x4;$/;"	t	namespace:glm
highp_fquat	vendor/glm/fwd.hpp	/^	typedef qua<float, highp>			highp_fquat;$/;"	t	namespace:glm
highp_fvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, float, highp>		highp_fvec1;$/;"	t	namespace:glm
highp_fvec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, float, highp> highp_fvec1;$/;"	t	namespace:glm
highp_fvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, float, highp>		highp_fvec2;$/;"	t	namespace:glm
highp_fvec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, float, highp> highp_fvec2;$/;"	t	namespace:glm
highp_fvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, float, highp>		highp_fvec3;$/;"	t	namespace:glm
highp_fvec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, float, highp> highp_fvec3;$/;"	t	namespace:glm
highp_fvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, float, highp>		highp_fvec4;$/;"	t	namespace:glm
highp_fvec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, float, highp> highp_fvec4;$/;"	t	namespace:glm
highp_i16	vendor/glm/fwd.hpp	/^	typedef int16					highp_i16;$/;"	t	namespace:glm
highp_i16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int16 highp_i16;$/;"	t	namespace:glm
highp_i16vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i16, highp>		highp_i16vec1;$/;"	t	namespace:glm
highp_i16vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i16, highp>		highp_i16vec1;$/;"	t	namespace:glm
highp_i16vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i16, highp>		highp_i16vec2;$/;"	t	namespace:glm
highp_i16vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i16, highp>		highp_i16vec2;$/;"	t	namespace:glm
highp_i16vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i16, highp>		highp_i16vec3;$/;"	t	namespace:glm
highp_i16vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i16, highp>		highp_i16vec3;$/;"	t	namespace:glm
highp_i16vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i16, highp>		highp_i16vec4;$/;"	t	namespace:glm
highp_i16vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i16, highp>		highp_i16vec4;$/;"	t	namespace:glm
highp_i32	vendor/glm/fwd.hpp	/^	typedef int32					highp_i32;$/;"	t	namespace:glm
highp_i32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int32 highp_i32;$/;"	t	namespace:glm
highp_i32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i32, highp>		highp_i32vec1;$/;"	t	namespace:glm
highp_i32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i32, highp>		highp_i32vec1;$/;"	t	namespace:glm
highp_i32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i32, highp>		highp_i32vec2;$/;"	t	namespace:glm
highp_i32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i32, highp>		highp_i32vec2;$/;"	t	namespace:glm
highp_i32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i32, highp>		highp_i32vec3;$/;"	t	namespace:glm
highp_i32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i32, highp>		highp_i32vec3;$/;"	t	namespace:glm
highp_i32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i32, highp>		highp_i32vec4;$/;"	t	namespace:glm
highp_i32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i32, highp>		highp_i32vec4;$/;"	t	namespace:glm
highp_i64	vendor/glm/fwd.hpp	/^	typedef int64					highp_i64;$/;"	t	namespace:glm
highp_i64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int64 highp_i64;$/;"	t	namespace:glm
highp_i64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i64, highp>		highp_i64vec1;$/;"	t	namespace:glm
highp_i64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i64, highp>		highp_i64vec1;$/;"	t	namespace:glm
highp_i64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i64, highp>		highp_i64vec2;$/;"	t	namespace:glm
highp_i64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i64, highp>		highp_i64vec2;$/;"	t	namespace:glm
highp_i64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i64, highp>		highp_i64vec3;$/;"	t	namespace:glm
highp_i64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i64, highp>		highp_i64vec3;$/;"	t	namespace:glm
highp_i64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i64, highp>		highp_i64vec4;$/;"	t	namespace:glm
highp_i64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i64, highp>		highp_i64vec4;$/;"	t	namespace:glm
highp_i8	vendor/glm/fwd.hpp	/^	typedef int8					highp_i8;$/;"	t	namespace:glm
highp_i8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int8 highp_i8;$/;"	t	namespace:glm
highp_i8vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i8, highp>		highp_i8vec1;$/;"	t	namespace:glm
highp_i8vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i8, highp> highp_i8vec1;$/;"	t	namespace:glm
highp_i8vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i8, highp>		highp_i8vec2;$/;"	t	namespace:glm
highp_i8vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i8, highp> highp_i8vec2;$/;"	t	namespace:glm
highp_i8vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i8, highp>		highp_i8vec3;$/;"	t	namespace:glm
highp_i8vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i8, highp> highp_i8vec3;$/;"	t	namespace:glm
highp_i8vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i8, highp>		highp_i8vec4;$/;"	t	namespace:glm
highp_i8vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i8, highp> highp_i8vec4;$/;"	t	namespace:glm
highp_imat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, int, highp>				highp_imat2;$/;"	t	namespace:glm
highp_imat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, int, highp>				highp_imat2x2;$/;"	t	namespace:glm
highp_imat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 3, int, highp>				highp_imat2x3;$/;"	t	namespace:glm
highp_imat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 4, int, highp>				highp_imat2x4;$/;"	t	namespace:glm
highp_imat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, int, highp>				highp_imat3;$/;"	t	namespace:glm
highp_imat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 2, int, highp>				highp_imat3x2;$/;"	t	namespace:glm
highp_imat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, int, highp>				highp_imat3x3;$/;"	t	namespace:glm
highp_imat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 4, int, highp>				highp_imat3x4;$/;"	t	namespace:glm
highp_imat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, int, highp>				highp_imat4;$/;"	t	namespace:glm
highp_imat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 2, int, highp>				highp_imat4x2;$/;"	t	namespace:glm
highp_imat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 3, int, highp>				highp_imat4x3;$/;"	t	namespace:glm
highp_imat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, int, highp>				highp_imat4x4;$/;"	t	namespace:glm
highp_int16	vendor/glm/fwd.hpp	/^	typedef int16					highp_int16;$/;"	t	namespace:glm
highp_int16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int16 highp_int16;$/;"	t	namespace:glm
highp_int16_t	vendor/glm/fwd.hpp	/^	typedef int16					highp_int16_t;$/;"	t	namespace:glm
highp_int16_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int16 highp_int16_t;$/;"	t	namespace:glm
highp_int32	vendor/glm/fwd.hpp	/^	typedef int32					highp_int32;$/;"	t	namespace:glm
highp_int32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int32 highp_int32;$/;"	t	namespace:glm
highp_int32_t	vendor/glm/fwd.hpp	/^	typedef int32					highp_int32_t;$/;"	t	namespace:glm
highp_int32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int32 highp_int32_t;$/;"	t	namespace:glm
highp_int64	vendor/glm/fwd.hpp	/^	typedef int64					highp_int64;$/;"	t	namespace:glm
highp_int64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int64 highp_int64;$/;"	t	namespace:glm
highp_int64_t	vendor/glm/fwd.hpp	/^	typedef int64					highp_int64_t;$/;"	t	namespace:glm
highp_int64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int64 highp_int64_t;$/;"	t	namespace:glm
highp_int8	vendor/glm/fwd.hpp	/^	typedef int8					highp_int8;$/;"	t	namespace:glm
highp_int8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int8 highp_int8;$/;"	t	namespace:glm
highp_int8_t	vendor/glm/fwd.hpp	/^	typedef int8					highp_int8_t;$/;"	t	namespace:glm
highp_int8_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int8 highp_int8_t;$/;"	t	namespace:glm
highp_ivec1	vendor/glm/ext/vector_int1_precision.hpp	/^	typedef vec<1, int, highp>			highp_ivec1;$/;"	t	namespace:glm
highp_ivec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i32, highp>		highp_ivec1;$/;"	t	namespace:glm
highp_ivec2	vendor/glm/ext/vector_int2_precision.hpp	/^	typedef vec<2, int, highp>		highp_ivec2;$/;"	t	namespace:glm
highp_ivec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i32, highp>		highp_ivec2;$/;"	t	namespace:glm
highp_ivec3	vendor/glm/ext/vector_int3_precision.hpp	/^	typedef vec<3, int, highp>		highp_ivec3;$/;"	t	namespace:glm
highp_ivec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i32, highp>		highp_ivec3;$/;"	t	namespace:glm
highp_ivec4	vendor/glm/ext/vector_int4_precision.hpp	/^	typedef vec<4, int, highp>		highp_ivec4;$/;"	t	namespace:glm
highp_ivec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i32, highp>		highp_ivec4;$/;"	t	namespace:glm
highp_mat2	vendor/glm/ext/matrix_float2x2_precision.hpp	/^	typedef mat<2, 2, float, highp>		highp_mat2;$/;"	t	namespace:glm
highp_mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, highp>		highp_mat2;$/;"	t	namespace:glm
highp_mat2x2	vendor/glm/ext/matrix_float2x2_precision.hpp	/^	typedef mat<2, 2, float, highp>		highp_mat2x2;$/;"	t	namespace:glm
highp_mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, highp>		highp_mat2x2;$/;"	t	namespace:glm
highp_mat2x3	vendor/glm/ext/matrix_float2x3_precision.hpp	/^	typedef mat<2, 3, float, highp>		highp_mat2x3;$/;"	t	namespace:glm
highp_mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, highp>		highp_mat2x3;$/;"	t	namespace:glm
highp_mat2x4	vendor/glm/ext/matrix_float2x4_precision.hpp	/^	typedef mat<2, 4, float, highp>		highp_mat2x4;$/;"	t	namespace:glm
highp_mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, highp>		highp_mat2x4;$/;"	t	namespace:glm
highp_mat3	vendor/glm/ext/matrix_float3x3_precision.hpp	/^	typedef mat<3, 3, float, highp>		highp_mat3;$/;"	t	namespace:glm
highp_mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, highp>		highp_mat3;$/;"	t	namespace:glm
highp_mat3x2	vendor/glm/ext/matrix_float3x2_precision.hpp	/^	typedef mat<3, 2, float, highp>		highp_mat3x2;$/;"	t	namespace:glm
highp_mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, highp>		highp_mat3x2;$/;"	t	namespace:glm
highp_mat3x3	vendor/glm/ext/matrix_float3x3_precision.hpp	/^	typedef mat<3, 3, float, highp>		highp_mat3x3;$/;"	t	namespace:glm
highp_mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, highp>		highp_mat3x3;$/;"	t	namespace:glm
highp_mat3x4	vendor/glm/ext/matrix_float3x4_precision.hpp	/^	typedef mat<3, 4, float, highp>		highp_mat3x4;$/;"	t	namespace:glm
highp_mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, highp>		highp_mat3x4;$/;"	t	namespace:glm
highp_mat4	vendor/glm/ext/matrix_float4x4_precision.hpp	/^	typedef mat<4, 4, float, highp>		highp_mat4;$/;"	t	namespace:glm
highp_mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, highp>		highp_mat4;$/;"	t	namespace:glm
highp_mat4x2	vendor/glm/ext/matrix_float4x2_precision.hpp	/^	typedef mat<4, 2, float, highp>		highp_mat4x2;$/;"	t	namespace:glm
highp_mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, highp>		highp_mat4x2;$/;"	t	namespace:glm
highp_mat4x3	vendor/glm/ext/matrix_float4x3_precision.hpp	/^	typedef mat<4, 3, float, highp>		highp_mat4x3;$/;"	t	namespace:glm
highp_mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, highp>		highp_mat4x3;$/;"	t	namespace:glm
highp_mat4x4	vendor/glm/ext/matrix_float4x4_precision.hpp	/^	typedef mat<4, 4, float, highp>		highp_mat4x4;$/;"	t	namespace:glm
highp_mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, highp>		highp_mat4x4;$/;"	t	namespace:glm
highp_quat	vendor/glm/ext/quaternion_float_precision.hpp	/^	typedef qua<float, highp>		highp_quat;$/;"	t	namespace:glm
highp_quat	vendor/glm/fwd.hpp	/^	typedef qua<float, highp>			highp_quat;$/;"	t	namespace:glm
highp_u16	vendor/glm/fwd.hpp	/^	typedef uint16					highp_u16;$/;"	t	namespace:glm
highp_u16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint16 highp_u16;$/;"	t	namespace:glm
highp_u16vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u16, highp>		highp_u16vec1;$/;"	t	namespace:glm
highp_u16vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u16, highp>		highp_u16vec1;$/;"	t	namespace:glm
highp_u16vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u16, highp>		highp_u16vec2;$/;"	t	namespace:glm
highp_u16vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u16, highp>		highp_u16vec2;$/;"	t	namespace:glm
highp_u16vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u16, highp>		highp_u16vec3;$/;"	t	namespace:glm
highp_u16vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u16, highp>		highp_u16vec3;$/;"	t	namespace:glm
highp_u16vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u16, highp>		highp_u16vec4;$/;"	t	namespace:glm
highp_u16vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u16, highp>		highp_u16vec4;$/;"	t	namespace:glm
highp_u32	vendor/glm/fwd.hpp	/^	typedef uint32					highp_u32;$/;"	t	namespace:glm
highp_u32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint32 highp_u32;$/;"	t	namespace:glm
highp_u32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u32, highp>		highp_u32vec1;$/;"	t	namespace:glm
highp_u32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u32, highp>		highp_u32vec1;$/;"	t	namespace:glm
highp_u32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u32, highp>		highp_u32vec2;$/;"	t	namespace:glm
highp_u32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u32, highp>		highp_u32vec2;$/;"	t	namespace:glm
highp_u32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u32, highp>		highp_u32vec3;$/;"	t	namespace:glm
highp_u32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u32, highp>		highp_u32vec3;$/;"	t	namespace:glm
highp_u32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u32, highp>		highp_u32vec4;$/;"	t	namespace:glm
highp_u32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u32, highp>		highp_u32vec4;$/;"	t	namespace:glm
highp_u64	vendor/glm/fwd.hpp	/^	typedef uint64					highp_u64;$/;"	t	namespace:glm
highp_u64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint64 highp_u64;$/;"	t	namespace:glm
highp_u64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u64, highp>		highp_u64vec1;$/;"	t	namespace:glm
highp_u64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u64, highp>		highp_u64vec1;$/;"	t	namespace:glm
highp_u64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u64, highp>		highp_u64vec2;$/;"	t	namespace:glm
highp_u64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u64, highp>		highp_u64vec2;$/;"	t	namespace:glm
highp_u64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u64, highp>		highp_u64vec3;$/;"	t	namespace:glm
highp_u64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u64, highp>		highp_u64vec3;$/;"	t	namespace:glm
highp_u64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u64, highp>		highp_u64vec4;$/;"	t	namespace:glm
highp_u64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u64, highp>		highp_u64vec4;$/;"	t	namespace:glm
highp_u8	vendor/glm/fwd.hpp	/^	typedef uint8					highp_u8;$/;"	t	namespace:glm
highp_u8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint8 highp_u8;$/;"	t	namespace:glm
highp_u8vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u8, highp>		highp_u8vec1;$/;"	t	namespace:glm
highp_u8vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u8, highp> highp_u8vec1;$/;"	t	namespace:glm
highp_u8vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u8, highp>		highp_u8vec2;$/;"	t	namespace:glm
highp_u8vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u8, highp> highp_u8vec2;$/;"	t	namespace:glm
highp_u8vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u8, highp>		highp_u8vec3;$/;"	t	namespace:glm
highp_u8vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u8, highp> highp_u8vec3;$/;"	t	namespace:glm
highp_u8vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u8, highp>		highp_u8vec4;$/;"	t	namespace:glm
highp_u8vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u8, highp> highp_u8vec4;$/;"	t	namespace:glm
highp_uint16	vendor/glm/fwd.hpp	/^	typedef uint16					highp_uint16;$/;"	t	namespace:glm
highp_uint16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint16 highp_uint16;$/;"	t	namespace:glm
highp_uint16_t	vendor/glm/fwd.hpp	/^	typedef uint16					highp_uint16_t;$/;"	t	namespace:glm
highp_uint16_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint16 highp_uint16_t;$/;"	t	namespace:glm
highp_uint32	vendor/glm/fwd.hpp	/^	typedef uint32					highp_uint32;$/;"	t	namespace:glm
highp_uint32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint32 highp_uint32;$/;"	t	namespace:glm
highp_uint32_t	vendor/glm/fwd.hpp	/^	typedef uint32					highp_uint32_t;$/;"	t	namespace:glm
highp_uint32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint32 highp_uint32_t;$/;"	t	namespace:glm
highp_uint64	vendor/glm/fwd.hpp	/^	typedef uint64					highp_uint64;$/;"	t	namespace:glm
highp_uint64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint64 highp_uint64;$/;"	t	namespace:glm
highp_uint64_t	vendor/glm/fwd.hpp	/^	typedef uint64					highp_uint64_t;$/;"	t	namespace:glm
highp_uint64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint64 highp_uint64_t;$/;"	t	namespace:glm
highp_uint8	vendor/glm/fwd.hpp	/^	typedef uint8					highp_uint8;$/;"	t	namespace:glm
highp_uint8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint8 highp_uint8;$/;"	t	namespace:glm
highp_uint8_t	vendor/glm/fwd.hpp	/^	typedef uint8					highp_uint8_t;$/;"	t	namespace:glm
highp_uint8_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint8 highp_uint8_t;$/;"	t	namespace:glm
highp_umat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, uint, highp>				highp_umat2;$/;"	t	namespace:glm
highp_umat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, uint, highp>				highp_umat2x2;$/;"	t	namespace:glm
highp_umat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 3, uint, highp>				highp_umat2x3;$/;"	t	namespace:glm
highp_umat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 4, uint, highp>				highp_umat2x4;$/;"	t	namespace:glm
highp_umat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, uint, highp>				highp_umat3;$/;"	t	namespace:glm
highp_umat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 2, uint, highp>				highp_umat3x2;$/;"	t	namespace:glm
highp_umat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, uint, highp>				highp_umat3x3;$/;"	t	namespace:glm
highp_umat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 4, uint, highp>				highp_umat3x4;$/;"	t	namespace:glm
highp_umat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, uint, highp>				highp_umat4;$/;"	t	namespace:glm
highp_umat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 2, uint, highp>				highp_umat4x2;$/;"	t	namespace:glm
highp_umat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 3, uint, highp>				highp_umat4x3;$/;"	t	namespace:glm
highp_umat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, uint, highp>				highp_umat4x4;$/;"	t	namespace:glm
highp_uvec1	vendor/glm/ext/vector_uint1_precision.hpp	/^	typedef vec<1, unsigned int, highp>			highp_uvec1;$/;"	t	namespace:glm
highp_uvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u32, highp>		highp_uvec1;$/;"	t	namespace:glm
highp_uvec2	vendor/glm/ext/vector_uint2_precision.hpp	/^	typedef vec<2, unsigned int, highp>		highp_uvec2;$/;"	t	namespace:glm
highp_uvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u32, highp>		highp_uvec2;$/;"	t	namespace:glm
highp_uvec3	vendor/glm/ext/vector_uint3_precision.hpp	/^	typedef vec<3, unsigned int, highp>		highp_uvec3;$/;"	t	namespace:glm
highp_uvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u32, highp>		highp_uvec3;$/;"	t	namespace:glm
highp_uvec4	vendor/glm/ext/vector_uint4_precision.hpp	/^	typedef vec<4, unsigned int, highp>		highp_uvec4;$/;"	t	namespace:glm
highp_uvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u32, highp>		highp_uvec4;$/;"	t	namespace:glm
highp_vec1	vendor/glm/ext/vector_float1_precision.hpp	/^	typedef vec<1, float, highp>		highp_vec1;$/;"	t	namespace:glm
highp_vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, float, highp>		highp_vec1;$/;"	t	namespace:glm
highp_vec2	vendor/glm/ext/vector_float2_precision.hpp	/^	typedef vec<2, float, highp>		highp_vec2;$/;"	t	namespace:glm
highp_vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, float, highp>		highp_vec2;$/;"	t	namespace:glm
highp_vec3	vendor/glm/ext/vector_float3_precision.hpp	/^	typedef vec<3, float, highp>		highp_vec3;$/;"	t	namespace:glm
highp_vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, float, highp>		highp_vec3;$/;"	t	namespace:glm
highp_vec4	vendor/glm/ext/vector_float4_precision.hpp	/^	typedef vec<4, float, highp>		highp_vec4;$/;"	t	namespace:glm
highp_vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, float, highp>		highp_vec4;$/;"	t	namespace:glm
history	vendor/stb_image/stb_image.h	/^   stbi_uc *history; $/;"	m	struct:__anon72
hmtx	vendor/imgui/imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
hs	vendor/stb_image/stb_image.h	/^   int hs,vs;   \/\/ expansion factor in each axis$/;"	m	struct:__anon63
hsz	vendor/stb_image/stb_image.h	/^   int bpp, offset, hsz;$/;"	m	struct:__anon69
huff_ac	vendor/stb_image/stb_image.h	/^   stbi__huffman huff_ac[4];$/;"	m	struct:__anon61
huff_dc	vendor/stb_image/stb_image.h	/^   stbi__huffman huff_dc[4];$/;"	m	struct:__anon61
i	vendor/glm/detail/type_float.hpp	/^		int_type i;$/;"	m	union:glm::detail::float_t
i16	vendor/glm/fwd.hpp	/^	typedef int16					i16;$/;"	t	namespace:glm
i16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int16 i16;$/;"	t	namespace:glm
i16vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i16, defaultp>	i16vec1;$/;"	t	namespace:glm
i16vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i16, defaultp> i16vec1;$/;"	t	namespace:glm
i16vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i16, defaultp>	i16vec2;$/;"	t	namespace:glm
i16vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i16, defaultp> i16vec2;$/;"	t	namespace:glm
i16vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i16, defaultp>	i16vec3;$/;"	t	namespace:glm
i16vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i16, defaultp> i16vec3;$/;"	t	namespace:glm
i16vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i16, defaultp>	i16vec4;$/;"	t	namespace:glm
i16vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i16, defaultp> i16vec4;$/;"	t	namespace:glm
i32	vendor/glm/fwd.hpp	/^	typedef int32					i32;$/;"	t	namespace:glm
i32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int32 i32;$/;"	t	namespace:glm
i32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i32, defaultp>	i32vec1;$/;"	t	namespace:glm
i32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i32, defaultp> i32vec1;$/;"	t	namespace:glm
i32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i32, defaultp>	i32vec2;$/;"	t	namespace:glm
i32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i32, defaultp> i32vec2;$/;"	t	namespace:glm
i32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i32, defaultp>	i32vec3;$/;"	t	namespace:glm
i32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i32, defaultp> i32vec3;$/;"	t	namespace:glm
i32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i32, defaultp>	i32vec4;$/;"	t	namespace:glm
i32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i32, defaultp> i32vec4;$/;"	t	namespace:glm
i64	vendor/glm/fwd.hpp	/^	typedef int64					i64;$/;"	t	namespace:glm
i64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int64 i64;$/;"	t	namespace:glm
i64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i64, defaultp>	i64vec1;$/;"	t	namespace:glm
i64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i64, defaultp> i64vec1;$/;"	t	namespace:glm
i64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i64, defaultp>	i64vec2;$/;"	t	namespace:glm
i64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i64, defaultp> i64vec2;$/;"	t	namespace:glm
i64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i64, defaultp>	i64vec3;$/;"	t	namespace:glm
i64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i64, defaultp> i64vec3;$/;"	t	namespace:glm
i64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i64, defaultp>	i64vec4;$/;"	t	namespace:glm
i64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i64, defaultp> i64vec4;$/;"	t	namespace:glm
i8	vendor/glm/fwd.hpp	/^	typedef int8					i8;$/;"	t	namespace:glm
i8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int8 i8;$/;"	t	namespace:glm
i8vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i8, defaultp>	i8vec1;$/;"	t	namespace:glm
i8vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i8, defaultp> i8vec1;$/;"	t	namespace:glm
i8vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i8, defaultp>	i8vec2;$/;"	t	namespace:glm
i8vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i8, defaultp> i8vec2;$/;"	t	namespace:glm
i8vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i8, defaultp>	i8vec3;$/;"	t	namespace:glm
i8vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i8, defaultp> i8vec3;$/;"	t	namespace:glm
i8vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i8, defaultp>	i8vec4;$/;"	t	namespace:glm
i8vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i8, defaultp> i8vec4;$/;"	t	namespace:glm
id	vendor/glm/gtx/io.hpp	/^			static std::locale::id id;$/;"	m	class:glm::io::format_punct
id	vendor/imgui/imstb_rectpack.h	/^   int            id;$/;"	m	struct:stbrp_rect
id	vendor/imgui/imstb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
id	vendor/stb_image/stb_image.h	/^      int id;$/;"	m	struct:__anon61::__anon62
idata	vendor/stb_image/stb_image.h	/^   stbi_uc *idata, *expanded, *out;$/;"	m	struct:__anon67
idct_block_kernel	vendor/stb_image/stb_image.h	/^   void (*idct_block_kernel)(stbi_uc *out, int out_stride, short data[64]);$/;"	m	struct:__anon61
identity	vendor/glm/detail/qualifier.hpp	/^		GLM_FUNC_QUALIFIER GLM_CONSTEXPR static genType identity()$/;"	f	struct:glm::detail::init_gentype
imat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat2								imat2;$/;"	t	namespace:glm
imat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat2								imat2;$/;"	t	namespace:glm
imat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat2							imat2;$/;"	t	namespace:glm
imat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat2x2							imat2x2;$/;"	t	namespace:glm
imat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat2x2							imat2x2;$/;"	t	namespace:glm
imat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat2x2							imat2x2;$/;"	t	namespace:glm
imat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat2x3							imat2x3;$/;"	t	namespace:glm
imat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat2x3							imat2x3;$/;"	t	namespace:glm
imat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat2x3							imat2x3;$/;"	t	namespace:glm
imat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat2x4							imat2x4;$/;"	t	namespace:glm
imat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat2x4							imat2x4;$/;"	t	namespace:glm
imat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat2x4							imat2x4;$/;"	t	namespace:glm
imat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat3								imat3;$/;"	t	namespace:glm
imat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat3								imat3;$/;"	t	namespace:glm
imat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat3							imat3;$/;"	t	namespace:glm
imat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat3x2							imat3x2;$/;"	t	namespace:glm
imat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat3x2							imat3x2;$/;"	t	namespace:glm
imat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat3x2							imat3x2;$/;"	t	namespace:glm
imat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat3x3							imat3x3;$/;"	t	namespace:glm
imat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat3x3							imat3x3;$/;"	t	namespace:glm
imat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat3x3							imat3x3;$/;"	t	namespace:glm
imat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat3x4							imat3x4;$/;"	t	namespace:glm
imat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat3x4							imat3x4;$/;"	t	namespace:glm
imat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat3x4							imat3x4;$/;"	t	namespace:glm
imat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat4								imat4;$/;"	t	namespace:glm
imat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat4								imat4;$/;"	t	namespace:glm
imat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat4							imat4;$/;"	t	namespace:glm
imat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat4x2							imat4x2;$/;"	t	namespace:glm
imat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat4x2							imat4x2;$/;"	t	namespace:glm
imat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat4x2							imat4x2;$/;"	t	namespace:glm
imat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat4x3							imat4x3;$/;"	t	namespace:glm
imat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat4x3							imat4x3;$/;"	t	namespace:glm
imat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat4x3							imat4x3;$/;"	t	namespace:glm
imat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_imat4x4							imat4x4;$/;"	t	namespace:glm
imat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_imat4x4							imat4x4;$/;"	t	namespace:glm
imat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_imat4x4							imat4x4;$/;"	t	namespace:glm
img_buffer	vendor/stb_image/stb_image.h	/^   stbi_uc *img_buffer, *img_buffer_end;$/;"	m	struct:__anon56
img_buffer_end	vendor/stb_image/stb_image.h	/^   stbi_uc *img_buffer, *img_buffer_end;$/;"	m	struct:__anon56
img_buffer_original	vendor/stb_image/stb_image.h	/^   stbi_uc *img_buffer_original, *img_buffer_original_end;$/;"	m	struct:__anon56
img_buffer_original_end	vendor/stb_image/stb_image.h	/^   stbi_uc *img_buffer_original, *img_buffer_original_end;$/;"	m	struct:__anon56
img_comp	vendor/stb_image/stb_image.h	/^   } img_comp[4];$/;"	m	struct:__anon61	typeref:struct:__anon61::__anon62
img_h_max	vendor/stb_image/stb_image.h	/^   int img_h_max, img_v_max;$/;"	m	struct:__anon61
img_mcu_h	vendor/stb_image/stb_image.h	/^   int img_mcu_w, img_mcu_h;$/;"	m	struct:__anon61
img_mcu_w	vendor/stb_image/stb_image.h	/^   int img_mcu_w, img_mcu_h;$/;"	m	struct:__anon61
img_mcu_x	vendor/stb_image/stb_image.h	/^   int img_mcu_x, img_mcu_y;$/;"	m	struct:__anon61
img_mcu_y	vendor/stb_image/stb_image.h	/^   int img_mcu_x, img_mcu_y;$/;"	m	struct:__anon61
img_n	vendor/stb_image/stb_image.h	/^   int img_n, img_out_n;$/;"	m	struct:__anon56
img_out_n	vendor/stb_image/stb_image.h	/^   int img_n, img_out_n;$/;"	m	struct:__anon56
img_v_max	vendor/stb_image/stb_image.h	/^   int img_h_max, img_v_max;$/;"	m	struct:__anon61
img_x	vendor/stb_image/stb_image.h	/^   stbi__uint32 img_x, img_y;$/;"	m	struct:__anon56
img_y	vendor/stb_image/stb_image.h	/^   stbi__uint32 img_x, img_y;$/;"	m	struct:__anon56
indexToLocFormat	vendor/imgui/imstb_truetype.h	/^   int indexToLocFormat;              \/\/ format needed to map from glyph index to glyph$/;"	m	struct:stbtt_fontinfo
index_from_ptr	vendor/imgui/imgui.h	/^    inline int          index_from_ptr(const T* it) const   { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; return (int)off; }$/;"	f	struct:ImVector
index_map	vendor/imgui/imstb_truetype.h	/^   int index_map;                     \/\/ a cmap mapping for our chosen character encoding$/;"	m	struct:stbtt_fontinfo
init_gentype	vendor/glm/detail/qualifier.hpp	/^	struct init_gentype$/;"	s	namespace:glm::detail
init_gentype	vendor/glm/detail/qualifier.hpp	/^	struct init_gentype<genType, GENTYPE_MAT>$/;"	s	namespace:glm::detail
init_gentype	vendor/glm/detail/qualifier.hpp	/^	struct init_gentype<genType, GENTYPE_QUAT>$/;"	s	namespace:glm::detail
init_mode	vendor/imgui/imstb_rectpack.h	/^   int init_mode;$/;"	m	struct:stbrp_context
initialized	vendor/imgui/imstb_textedit.h	/^   unsigned char initialized;$/;"	m	struct:__anon50
insert	vendor/imgui/imgui.h	/^    inline T*           insert(const T* it, const T& v)     { IM_ASSERT(it >= Data && it <= Data+Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(T)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }$/;"	f	struct:ImVector
insert_length	vendor/imgui/imstb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  insert_length;$/;"	m	struct:__anon48
insert_mode	vendor/imgui/imstb_textedit.h	/^   unsigned char insert_mode;$/;"	m	struct:__anon50
int1	vendor/glm/gtx/compatibility.hpp	/^	typedef int							int1;			\/\/!< \\brief integer vector with 1 component. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int16	vendor/glm/ext/scalar_int_sized.hpp	/^		typedef std::int16_t		int16;$/;"	t	namespace:glm::detail
int16	vendor/glm/ext/scalar_int_sized.hpp	/^	typedef detail::int16		int16;$/;"	t	namespace:glm
int16	vendor/glm/fwd.hpp	/^	typedef std::int16_t			int16;$/;"	t	namespace:glm
int16_t	vendor/glm/fwd.hpp	/^	typedef int16					int16_t;$/;"	t	namespace:glm
int1x1	vendor/glm/gtx/compatibility.hpp	/^	typedef int							int1x1;			\/\/!< \\brief integer matrix with 1 component. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int2	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<2, int, highp>			int2;			\/\/!< \\brief integer vector with 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int2x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 2, int, highp>		int2x2;			\/\/!< \\brief integer matrix with 2 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int2x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 3, int, highp>		int2x3;			\/\/!< \\brief integer matrix with 2 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int2x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<2, 4, int, highp>		int2x4;			\/\/!< \\brief integer matrix with 2 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int3	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<3, int, highp>			int3;			\/\/!< \\brief integer vector with 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int32	vendor/glm/ext/scalar_int_sized.hpp	/^		typedef std::int32_t		int32;$/;"	t	namespace:glm::detail
int32	vendor/glm/ext/scalar_int_sized.hpp	/^	typedef detail::int32		int32;$/;"	t	namespace:glm
int32	vendor/glm/fwd.hpp	/^	typedef std::int32_t			int32;$/;"	t	namespace:glm
int32_t	vendor/glm/fwd.hpp	/^	typedef int32					int32_t;$/;"	t	namespace:glm
int3x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 2, int, highp>		int3x2;			\/\/!< \\brief integer matrix with 3 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int3x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 3, int, highp>		int3x3;			\/\/!< \\brief integer matrix with 3 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int3x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<3, 4, int, highp>		int3x4;			\/\/!< \\brief integer matrix with 3 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int4	vendor/glm/gtx/compatibility.hpp	/^	typedef vec<4, int, highp>			int4;			\/\/!< \\brief integer vector with 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int4x2	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 2, int, highp>		int4x2;			\/\/!< \\brief integer matrix with 4 x 2 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int4x3	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 3, int, highp>		int4x3;			\/\/!< \\brief integer matrix with 4 x 3 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int4x4	vendor/glm/gtx/compatibility.hpp	/^	typedef mat<4, 4, int, highp>		int4x4;			\/\/!< \\brief integer matrix with 4 x 4 components. (From GLM_GTX_compatibility extension)$/;"	t	namespace:glm
int64	vendor/glm/detail/setup.hpp	/^		typedef std::int64_t						int64;$/;"	t	namespace:glm::detail
int64	vendor/glm/ext/scalar_int_sized.hpp	/^	typedef detail::int64		int64;$/;"	t	namespace:glm
int64	vendor/glm/fwd.hpp	/^	typedef std::int64_t			int64;$/;"	t	namespace:glm
int64_t	vendor/glm/fwd.hpp	/^	typedef int64					int64_t;$/;"	t	namespace:glm
int8	vendor/glm/ext/scalar_int_sized.hpp	/^		typedef std::int8_t			int8;$/;"	t	namespace:glm::detail
int8	vendor/glm/ext/scalar_int_sized.hpp	/^	typedef detail::int8		int8;$/;"	t	namespace:glm
int8	vendor/glm/fwd.hpp	/^	typedef std::int8_t				int8;$/;"	t	namespace:glm
int8_t	vendor/glm/fwd.hpp	/^	typedef int8					int8_t;$/;"	t	namespace:glm
int_type	vendor/glm/detail/type_float.hpp	/^		typedef detail::int64 int_type;$/;"	t	union:glm::detail::float_t
int_type	vendor/glm/detail/type_float.hpp	/^		typedef int int_type;$/;"	t	union:glm::detail::float_t
invert	vendor/imgui/imstb_truetype.h	/^   int invert;$/;"	m	struct:stbtt__edge
io	vendor/glm/gtx/io.hpp	/^	namespace io$/;"	n	namespace:glm
io	vendor/stb_image/stb_image.h	/^   stbi_io_callbacks io;$/;"	m	struct:__anon56
io_user_data	vendor/stb_image/stb_image.h	/^   void *io_user_data;$/;"	m	struct:__anon56
is_aligned	vendor/glm/detail/qualifier.hpp	/^		struct is_aligned<glm::aligned_highp>$/;"	s	namespace:glm::detail
is_aligned	vendor/glm/detail/qualifier.hpp	/^		struct is_aligned<glm::aligned_lowp>$/;"	s	namespace:glm::detail
is_aligned	vendor/glm/detail/qualifier.hpp	/^		struct is_aligned<glm::aligned_mediump>$/;"	s	namespace:glm::detail
is_aligned	vendor/glm/detail/qualifier.hpp	/^	struct is_aligned$/;"	s	namespace:glm::detail
is_int	vendor/glm/detail/setup.hpp	/^	struct is_int$/;"	s	namespace:glm::detail
is_int	vendor/glm/detail/setup.hpp	/^	struct is_int<signed int>$/;"	s	namespace:glm::detail
is_int	vendor/glm/detail/setup.hpp	/^	struct is_int<unsigned int>$/;"	s	namespace:glm::detail
is_int	vendor/glm/ext/scalar_int_sized.hpp	/^	struct is_int<int16>$/;"	s	namespace:glm::detail
is_int	vendor/glm/ext/scalar_int_sized.hpp	/^	struct is_int<int64>$/;"	s	namespace:glm::detail
is_int	vendor/glm/ext/scalar_int_sized.hpp	/^	struct is_int<int8>$/;"	s	namespace:glm::detail
is_int	vendor/glm/ext/scalar_uint_sized.hpp	/^	struct is_int<uint16>$/;"	s	namespace:glm::detail
is_int	vendor/glm/ext/scalar_uint_sized.hpp	/^	struct is_int<uint64>$/;"	s	namespace:glm::detail
is_int	vendor/glm/ext/scalar_uint_sized.hpp	/^	struct is_int<uint8>$/;"	s	namespace:glm::detail
is_mat	vendor/glm/gtx/type_trait.hpp	/^		static bool const is_mat = false;$/;"	m	struct:glm::type
is_mat	vendor/glm/gtx/type_trait.hpp	/^		static bool const is_mat = true;$/;"	m	struct:glm::type
is_quat	vendor/glm/gtx/type_trait.hpp	/^		static bool const is_quat = false;$/;"	m	struct:glm::type
is_quat	vendor/glm/gtx/type_trait.hpp	/^		static bool const is_quat = true;$/;"	m	struct:glm::type
is_separator	vendor/imgui/imgui_widgets.cpp	/^static bool is_separator(unsigned int c)                                        { return ImCharIsBlankW(c) || c==',' || c==';' || c=='(' || c==')' || c=='{' || c=='}' || c=='[' || c==']' || c=='|'; }$/;"	f	namespace:ImStb
is_vec	vendor/glm/gtx/type_trait.hpp	/^		static bool const is_vec = false;$/;"	m	struct:glm::type
is_vec	vendor/glm/gtx/type_trait.hpp	/^		static bool const is_vec = true;$/;"	m	struct:glm::type
is_word_boundary	vendor/imgui/imstb_textedit.h	/^static int is_word_boundary( STB_TEXTEDIT_STRING *str, int idx )$/;"	f
is_word_boundary_from_left	vendor/imgui/imgui_widgets.cpp	/^static int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx)       { return idx > 0 ? (!is_separator( obj->TextW[idx-1] ) && is_separator( obj->TextW[idx] ) ) : 1; }$/;"	f	namespace:ImStb
is_word_boundary_from_right	vendor/imgui/imgui_widgets.cpp	/^static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx)      { return idx > 0 ? (is_separator( obj->TextW[idx-1] ) && !is_separator( obj->TextW[idx] ) ) : 1; }$/;"	f	namespace:ImStb
isfinite	vendor/glm/gtx/compatibility.hpp	32;"	d
isinf	vendor/glm/detail/_fixes.hpp	20;"	d
isnan	vendor/glm/detail/_fixes.hpp	15;"	d
iterator	vendor/imgui/imgui.h	/^    typedef value_type*         iterator;$/;"	t	struct:ImVector
ivec1	vendor/glm/ext/vector_int1.hpp	/^	typedef vec<1, int, defaultp>			ivec1;$/;"	t	namespace:glm
ivec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i32, defaultp>	ivec1;$/;"	t	namespace:glm
ivec2	vendor/glm/ext/vector_int2.hpp	/^	typedef vec<2, int, defaultp>		ivec2;$/;"	t	namespace:glm
ivec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i32, defaultp>	ivec2;$/;"	t	namespace:glm
ivec3	vendor/glm/ext/vector_int3.hpp	/^	typedef vec<3, int, defaultp>		ivec3;$/;"	t	namespace:glm
ivec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i32, defaultp>	ivec3;$/;"	t	namespace:glm
ivec4	vendor/glm/ext/vector_int4.hpp	/^	typedef vec<4, int, defaultp>		ivec4;$/;"	t	namespace:glm
ivec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i32, defaultp>	ivec4;$/;"	t	namespace:glm
jfif	vendor/stb_image/stb_image.h	/^   int            jfif;$/;"	m	struct:__anon61
kern	vendor/imgui/imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
key	vendor/imgui/imgui.h	/^        ImGuiID key;$/;"	m	struct:ImGuiStorage::ImGuiStoragePair
length	vendor/glm/detail/type_mat2x2.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length() { return 2; }$/;"	f	struct:glm::mat
length	vendor/glm/detail/type_mat2x3.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length() { return 2; }$/;"	f	struct:glm::mat
length	vendor/glm/detail/type_mat2x4.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length() { return 2; }$/;"	f	struct:glm::mat
length	vendor/glm/detail/type_mat3x2.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length() { return 3; }$/;"	f	struct:glm::mat
length	vendor/glm/detail/type_mat3x3.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length() { return 3; }$/;"	f	struct:glm::mat
length	vendor/glm/detail/type_mat3x4.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length() { return 3; }$/;"	f	struct:glm::mat
length	vendor/glm/detail/type_mat4x2.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length() { return 4; }$/;"	f	struct:glm::mat
length	vendor/glm/detail/type_mat4x3.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length() { return 4; }$/;"	f	struct:glm::mat
length	vendor/glm/detail/type_mat4x4.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 4;}$/;"	f	struct:glm::mat
length	vendor/glm/detail/type_quat.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 4;}$/;"	f	struct:glm::qua
length	vendor/glm/detail/type_vec1.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 1;}$/;"	f	struct:glm::vec
length	vendor/glm/detail/type_vec2.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 2;}$/;"	f	struct:glm::vec
length	vendor/glm/detail/type_vec3.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 3;}$/;"	f	struct:glm::vec
length	vendor/glm/detail/type_vec4.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 4;}$/;"	f	struct:glm::vec
length	vendor/glm/gtx/dual_quaternion.hpp	/^		GLM_FUNC_DECL static GLM_CONSTEXPR length_type length(){return 2;}$/;"	f	struct:glm::tdualquat
length	vendor/imgui/imstb_textedit.h	/^   int first_char, length; \/\/ first char of row, and length$/;"	m	struct:__anon52
length	vendor/stb_image/stb_image.h	/^   stbi__uint32 length;$/;"	m	struct:__anon66
length_t	vendor/glm/detail/setup.hpp	/^		typedef size_t length_t;$/;"	t	namespace:glm
length_type	vendor/glm/detail/type_mat2x2.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::mat
length_type	vendor/glm/detail/type_mat2x3.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::mat
length_type	vendor/glm/detail/type_mat2x4.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::mat
length_type	vendor/glm/detail/type_mat3x2.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::mat
length_type	vendor/glm/detail/type_mat3x3.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::mat
length_type	vendor/glm/detail/type_mat3x4.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::mat
length_type	vendor/glm/detail/type_mat4x2.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::mat
length_type	vendor/glm/detail/type_mat4x3.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::mat
length_type	vendor/glm/detail/type_mat4x4.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::mat
length_type	vendor/glm/detail/type_quat.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::qua
length_type	vendor/glm/detail/type_vec1.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::vec
length_type	vendor/glm/detail/type_vec2.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::vec
length_type	vendor/glm/detail/type_vec3.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::vec
length_type	vendor/glm/detail/type_vec4.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::vec
length_type	vendor/glm/gtx/dual_quaternion.hpp	/^		typedef length_t length_type;$/;"	t	struct:glm::tdualquat
lerp	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<2, T, Q> lerp(const vec<2, T, Q>& x, const vec<2, T, Q>& y, T a){return mix(x, y, a);}							\/\/!< \\brief Returns x * (1.0 - a) + y * a, i.e., the linear blend of x and y using the floating-point value a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
lerp	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<2, T, Q> lerp(const vec<2, T, Q>& x, const vec<2, T, Q>& y, const vec<2, T, Q>& a){return mix(x, y, a);}	\/\/!< \\brief Returns the component-wise result of x * (1.0 - a) + y * a, i.e., the linear blend of x and y using vector a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
lerp	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<3, T, Q> lerp(const vec<3, T, Q>& x, const vec<3, T, Q>& y, T a){return mix(x, y, a);}							\/\/!< \\brief Returns x * (1.0 - a) + y * a, i.e., the linear blend of x and y using the floating-point value a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
lerp	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<3, T, Q> lerp(const vec<3, T, Q>& x, const vec<3, T, Q>& y, const vec<3, T, Q>& a){return mix(x, y, a);}	\/\/!< \\brief Returns the component-wise result of x * (1.0 - a) + y * a, i.e., the linear blend of x and y using vector a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
lerp	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<4, T, Q> lerp(const vec<4, T, Q>& x, const vec<4, T, Q>& y, T a){return mix(x, y, a);}							\/\/!< \\brief Returns x * (1.0 - a) + y * a, i.e., the linear blend of x and y using the floating-point value a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
lerp	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<4, T, Q> lerp(const vec<4, T, Q>& x, const vec<4, T, Q>& y, const vec<4, T, Q>& a){return mix(x, y, a);}	\/\/!< \\brief Returns the component-wise result of x * (1.0 - a) + y * a, i.e., the linear blend of x and y using vector a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
lerp	vendor/glm/gtx/compatibility.hpp	/^	template<typename T> GLM_FUNC_QUALIFIER T lerp(T x, T y, T a){return mix(x, y, a);}																					\/\/!< \\brief Returns x * (1.0 - a) + y * a, i.e., the linear blend of x and y using the floating-point value a. The value for a is not restricted to the range [0, 1]. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
lflags	vendor/stb_image/stb_image.h	/^   int lflags;$/;"	m	struct:__anon72
line0	vendor/stb_image/stb_image.h	/^   stbi_uc *line0,*line1;$/;"	m	struct:__anon63
line1	vendor/stb_image/stb_image.h	/^   stbi_uc *line0,*line1;$/;"	m	struct:__anon63
line_size	vendor/stb_image/stb_image.h	/^   int line_size;$/;"	m	struct:__anon72
linebuf	vendor/stb_image/stb_image.h	/^      stbi_uc *linebuf;$/;"	m	struct:__anon61::__anon62
load_jpeg_image	vendor/stb_image/stb_image.h	/^static stbi_uc *load_jpeg_image(stbi__jpeg *z, int *out_x, int *out_y, int *comp, int req_comp)$/;"	f
loca	vendor/imgui/imstb_truetype.h	/^   int loca,head,glyf,hhea,hmtx,kern,gpos; \/\/ table locations as offset from start of .ttf$/;"	m	struct:stbtt_fontinfo
localBuffer	Texture/Texture.h	/^	unsigned char* 	localBuffer;$/;"	m	class:Texture
locale_	vendor/glm/gtx/io.hpp	/^			locale_type     locale_;$/;"	m	class:glm::io::basic_state_saver
locale_type	vendor/glm/gtx/io.hpp	/^			typedef ::std::locale const            locale_type;$/;"	t	class:glm::io::basic_state_saver::std
log2	vendor/glm/detail/_fixes.hpp	25;"	d
lowp	vendor/glm/detail/qualifier.hpp	/^		lowp = packed_lowp, \/\/\/< By default lowp qualifier is also packed$/;"	e	enum:glm::qualifier
lowp_bvec1	vendor/glm/ext/vector_bool1_precision.hpp	/^	typedef vec<1, bool, lowp>			lowp_bvec1;$/;"	t	namespace:glm
lowp_bvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, bool, lowp>		lowp_bvec1;$/;"	t	namespace:glm
lowp_bvec2	vendor/glm/ext/vector_bool2_precision.hpp	/^	typedef vec<2, bool, lowp>		lowp_bvec2;$/;"	t	namespace:glm
lowp_bvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, bool, lowp>		lowp_bvec2;$/;"	t	namespace:glm
lowp_bvec3	vendor/glm/ext/vector_bool3_precision.hpp	/^	typedef vec<3, bool, lowp>		lowp_bvec3;$/;"	t	namespace:glm
lowp_bvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, bool, lowp>		lowp_bvec3;$/;"	t	namespace:glm
lowp_bvec4	vendor/glm/ext/vector_bool4_precision.hpp	/^	typedef vec<4, bool, lowp>		lowp_bvec4;$/;"	t	namespace:glm
lowp_bvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, bool, lowp>		lowp_bvec4;$/;"	t	namespace:glm
lowp_ddualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef tdualquat<double, lowp>		lowp_ddualquat;$/;"	t	namespace:glm
lowp_dmat2	vendor/glm/ext/matrix_double2x2_precision.hpp	/^	typedef mat<2, 2, double, lowp>		lowp_dmat2;$/;"	t	namespace:glm
lowp_dmat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, lowp>		lowp_dmat2;$/;"	t	namespace:glm
lowp_dmat2x2	vendor/glm/ext/matrix_double2x2_precision.hpp	/^	typedef mat<2, 2, double, lowp>		lowp_dmat2x2;$/;"	t	namespace:glm
lowp_dmat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, double, lowp>		lowp_dmat2x2;$/;"	t	namespace:glm
lowp_dmat2x3	vendor/glm/ext/matrix_double2x3_precision.hpp	/^	typedef mat<2, 3, double, lowp>		lowp_dmat2x3;$/;"	t	namespace:glm
lowp_dmat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, double, lowp>		lowp_dmat2x3;$/;"	t	namespace:glm
lowp_dmat2x4	vendor/glm/ext/matrix_double2x4_precision.hpp	/^	typedef mat<2, 4, double, lowp>		lowp_dmat2x4;$/;"	t	namespace:glm
lowp_dmat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, double, lowp>		lowp_dmat2x4;$/;"	t	namespace:glm
lowp_dmat3	vendor/glm/ext/matrix_double3x3_precision.hpp	/^	typedef mat<3, 3, double, lowp>		lowp_dmat3;$/;"	t	namespace:glm
lowp_dmat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, lowp>		lowp_dmat3;$/;"	t	namespace:glm
lowp_dmat3x2	vendor/glm/ext/matrix_double3x2_precision.hpp	/^	typedef mat<3, 2, double, lowp>		lowp_dmat3x2;$/;"	t	namespace:glm
lowp_dmat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, double, lowp>		lowp_dmat3x2;$/;"	t	namespace:glm
lowp_dmat3x3	vendor/glm/ext/matrix_double3x3_precision.hpp	/^	typedef mat<3, 3, double, lowp>		lowp_dmat3x3;$/;"	t	namespace:glm
lowp_dmat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, double, lowp>		lowp_dmat3x3;$/;"	t	namespace:glm
lowp_dmat3x4	vendor/glm/ext/matrix_double3x4_precision.hpp	/^	typedef mat<3, 4, double, lowp>		lowp_dmat3x4;$/;"	t	namespace:glm
lowp_dmat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, double, lowp>		lowp_dmat3x4;$/;"	t	namespace:glm
lowp_dmat4	vendor/glm/ext/matrix_double4x4_precision.hpp	/^	typedef mat<4, 4, double, lowp>		lowp_dmat4;$/;"	t	namespace:glm
lowp_dmat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, lowp>		lowp_dmat4;$/;"	t	namespace:glm
lowp_dmat4x2	vendor/glm/ext/matrix_double4x2_precision.hpp	/^	typedef mat<4, 2, double, lowp>		lowp_dmat4x2;$/;"	t	namespace:glm
lowp_dmat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, double, lowp>		lowp_dmat4x2;$/;"	t	namespace:glm
lowp_dmat4x3	vendor/glm/ext/matrix_double4x3_precision.hpp	/^	typedef mat<4, 3, double, lowp>		lowp_dmat4x3;$/;"	t	namespace:glm
lowp_dmat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, double, lowp>		lowp_dmat4x3;$/;"	t	namespace:glm
lowp_dmat4x4	vendor/glm/ext/matrix_double4x4_precision.hpp	/^	typedef mat<4, 4, double, lowp>		lowp_dmat4x4;$/;"	t	namespace:glm
lowp_dmat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, double, lowp>		lowp_dmat4x4;$/;"	t	namespace:glm
lowp_dquat	vendor/glm/ext/quaternion_double_precision.hpp	/^	typedef qua<double, lowp>		lowp_dquat;$/;"	t	namespace:glm
lowp_dquat	vendor/glm/fwd.hpp	/^	typedef qua<double, lowp>			lowp_dquat;$/;"	t	namespace:glm
lowp_dualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef tdualquat<float, lowp>		lowp_dualquat;$/;"	t	namespace:glm
lowp_dvec1	vendor/glm/ext/vector_double1_precision.hpp	/^	typedef vec<1, double, lowp>		lowp_dvec1;$/;"	t	namespace:glm
lowp_dvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f64, lowp>			lowp_dvec1;$/;"	t	namespace:glm
lowp_dvec2	vendor/glm/ext/vector_double2_precision.hpp	/^	typedef vec<2, double, lowp>		lowp_dvec2;$/;"	t	namespace:glm
lowp_dvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f64, lowp>			lowp_dvec2;$/;"	t	namespace:glm
lowp_dvec3	vendor/glm/ext/vector_double3_precision.hpp	/^	typedef vec<3, double, lowp>		lowp_dvec3;$/;"	t	namespace:glm
lowp_dvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f64, lowp>			lowp_dvec3;$/;"	t	namespace:glm
lowp_dvec4	vendor/glm/ext/vector_double4_precision.hpp	/^	typedef vec<4, double, lowp>		lowp_dvec4;$/;"	t	namespace:glm
lowp_dvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f64, lowp>			lowp_dvec4;$/;"	t	namespace:glm
lowp_f32	vendor/glm/fwd.hpp	/^	typedef float					lowp_f32;$/;"	t	namespace:glm
lowp_f32	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 lowp_f32;$/;"	t	namespace:glm
lowp_f32mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, lowp>		lowp_f32mat2;$/;"	t	namespace:glm
lowp_f32mat2	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_f32mat2x2 lowp_f32mat2;$/;"	t	namespace:glm
lowp_f32mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, lowp>		lowp_f32mat2x2;$/;"	t	namespace:glm
lowp_f32mat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f32, lowp> lowp_f32mat2x2;$/;"	t	namespace:glm
lowp_f32mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, lowp>		lowp_f32mat2x3;$/;"	t	namespace:glm
lowp_f32mat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f32, lowp> lowp_f32mat2x3;$/;"	t	namespace:glm
lowp_f32mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, lowp>		lowp_f32mat2x4;$/;"	t	namespace:glm
lowp_f32mat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f32, lowp> lowp_f32mat2x4;$/;"	t	namespace:glm
lowp_f32mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, lowp>		lowp_f32mat3;$/;"	t	namespace:glm
lowp_f32mat3	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_f32mat3x3 lowp_f32mat3;$/;"	t	namespace:glm
lowp_f32mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, lowp>		lowp_f32mat3x2;$/;"	t	namespace:glm
lowp_f32mat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f32, lowp> lowp_f32mat3x2;$/;"	t	namespace:glm
lowp_f32mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, lowp>		lowp_f32mat3x3;$/;"	t	namespace:glm
lowp_f32mat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f32, lowp> lowp_f32mat3x3;$/;"	t	namespace:glm
lowp_f32mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, lowp>		lowp_f32mat3x4;$/;"	t	namespace:glm
lowp_f32mat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f32, lowp> lowp_f32mat3x4;$/;"	t	namespace:glm
lowp_f32mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, lowp>		lowp_f32mat4;$/;"	t	namespace:glm
lowp_f32mat4	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_f32mat4x4 lowp_f32mat4;$/;"	t	namespace:glm
lowp_f32mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, lowp>		lowp_f32mat4x2;$/;"	t	namespace:glm
lowp_f32mat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f32, lowp> lowp_f32mat4x2;$/;"	t	namespace:glm
lowp_f32mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, lowp>		lowp_f32mat4x3;$/;"	t	namespace:glm
lowp_f32mat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f32, lowp> lowp_f32mat4x3;$/;"	t	namespace:glm
lowp_f32mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, lowp>		lowp_f32mat4x4;$/;"	t	namespace:glm
lowp_f32mat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f32, lowp> lowp_f32mat4x4;$/;"	t	namespace:glm
lowp_f32quat	vendor/glm/fwd.hpp	/^	typedef qua<f32, lowp>				lowp_f32quat;$/;"	t	namespace:glm
lowp_f32quat	vendor/glm/gtc/type_precision.hpp	/^	typedef qua<f32, lowp> lowp_f32quat;$/;"	t	namespace:glm
lowp_f32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f32, lowp>			lowp_f32vec1;$/;"	t	namespace:glm
lowp_f32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, f32, lowp> lowp_f32vec1;$/;"	t	namespace:glm
lowp_f32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f32, lowp>			lowp_f32vec2;$/;"	t	namespace:glm
lowp_f32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, f32, lowp> lowp_f32vec2;$/;"	t	namespace:glm
lowp_f32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f32, lowp>			lowp_f32vec3;$/;"	t	namespace:glm
lowp_f32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, f32, lowp> lowp_f32vec3;$/;"	t	namespace:glm
lowp_f32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f32, lowp>			lowp_f32vec4;$/;"	t	namespace:glm
lowp_f32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, f32, lowp> lowp_f32vec4;$/;"	t	namespace:glm
lowp_f64	vendor/glm/fwd.hpp	/^	typedef double					lowp_f64;$/;"	t	namespace:glm
lowp_f64	vendor/glm/gtc/type_precision.hpp	/^	typedef float64 lowp_f64;$/;"	t	namespace:glm
lowp_f64mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, lowp>		lowp_f64mat2;$/;"	t	namespace:glm
lowp_f64mat2	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_f64mat2x2 lowp_f64mat2;$/;"	t	namespace:glm
lowp_f64mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, lowp>		lowp_f64mat2x2;$/;"	t	namespace:glm
lowp_f64mat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f64, lowp> lowp_f64mat2x2;$/;"	t	namespace:glm
lowp_f64mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f64, lowp>		lowp_f64mat2x3;$/;"	t	namespace:glm
lowp_f64mat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f64, lowp> lowp_f64mat2x3;$/;"	t	namespace:glm
lowp_f64mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f64, lowp>		lowp_f64mat2x4;$/;"	t	namespace:glm
lowp_f64mat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f64, lowp> lowp_f64mat2x4;$/;"	t	namespace:glm
lowp_f64mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, lowp>		lowp_f64mat3;$/;"	t	namespace:glm
lowp_f64mat3	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_f64mat3x3 lowp_f64mat3;$/;"	t	namespace:glm
lowp_f64mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f64, lowp>		lowp_f64mat3x2;$/;"	t	namespace:glm
lowp_f64mat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f64, lowp> lowp_f64mat3x2;$/;"	t	namespace:glm
lowp_f64mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, lowp>		lowp_f64mat3x3;$/;"	t	namespace:glm
lowp_f64mat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f64, lowp> lowp_f64mat3x3;$/;"	t	namespace:glm
lowp_f64mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f64, lowp>		lowp_f64mat3x4;$/;"	t	namespace:glm
lowp_f64mat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f64, lowp> lowp_f64mat3x4;$/;"	t	namespace:glm
lowp_f64mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, lowp>		lowp_f64mat4;$/;"	t	namespace:glm
lowp_f64mat4	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_f64mat4x4 lowp_f64mat4;$/;"	t	namespace:glm
lowp_f64mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f64, lowp>		lowp_f64mat4x2;$/;"	t	namespace:glm
lowp_f64mat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f64, lowp> lowp_f64mat4x2;$/;"	t	namespace:glm
lowp_f64mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f64, lowp>		lowp_f64mat4x3;$/;"	t	namespace:glm
lowp_f64mat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f64, lowp> lowp_f64mat4x3;$/;"	t	namespace:glm
lowp_f64mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, lowp>		lowp_f64mat4x4;$/;"	t	namespace:glm
lowp_f64mat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f64, lowp> lowp_f64mat4x4;$/;"	t	namespace:glm
lowp_f64quat	vendor/glm/fwd.hpp	/^	typedef qua<f64, lowp>				lowp_f64quat;$/;"	t	namespace:glm
lowp_f64quat	vendor/glm/gtc/type_precision.hpp	/^	typedef qua<f64, lowp> lowp_f64quat;$/;"	t	namespace:glm
lowp_f64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f64, lowp>			lowp_f64vec1;$/;"	t	namespace:glm
lowp_f64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, f64, lowp> lowp_f64vec1;$/;"	t	namespace:glm
lowp_f64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f64, lowp>			lowp_f64vec2;$/;"	t	namespace:glm
lowp_f64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, f64, lowp> lowp_f64vec2;$/;"	t	namespace:glm
lowp_f64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f64, lowp>			lowp_f64vec3;$/;"	t	namespace:glm
lowp_f64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, f64, lowp> lowp_f64vec3;$/;"	t	namespace:glm
lowp_f64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f64, lowp>			lowp_f64vec4;$/;"	t	namespace:glm
lowp_f64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, f64, lowp> lowp_f64vec4;$/;"	t	namespace:glm
lowp_fdualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef tdualquat<float, lowp>		lowp_fdualquat;$/;"	t	namespace:glm
lowp_float32	vendor/glm/fwd.hpp	/^	typedef float					lowp_float32;$/;"	t	namespace:glm
lowp_float32	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 lowp_float32;$/;"	t	namespace:glm
lowp_float32_t	vendor/glm/fwd.hpp	/^	typedef float					lowp_float32_t;$/;"	t	namespace:glm
lowp_float32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 lowp_float32_t;$/;"	t	namespace:glm
lowp_float64	vendor/glm/fwd.hpp	/^	typedef double					lowp_float64;$/;"	t	namespace:glm
lowp_float64	vendor/glm/gtc/type_precision.hpp	/^	typedef float64 lowp_float64;$/;"	t	namespace:glm
lowp_float64_t	vendor/glm/fwd.hpp	/^	typedef double					lowp_float64_t;$/;"	t	namespace:glm
lowp_float64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef float64 lowp_float64_t;$/;"	t	namespace:glm
lowp_fmat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, lowp>		lowp_fmat2;$/;"	t	namespace:glm
lowp_fmat2	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_fmat2x2 lowp_fmat2;$/;"	t	namespace:glm
lowp_fmat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, lowp>		lowp_fmat2x2;$/;"	t	namespace:glm
lowp_fmat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f32, lowp> lowp_fmat2x2;$/;"	t	namespace:glm
lowp_fmat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, lowp>		lowp_fmat2x3;$/;"	t	namespace:glm
lowp_fmat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f32, lowp> lowp_fmat2x3;$/;"	t	namespace:glm
lowp_fmat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, lowp>		lowp_fmat2x4;$/;"	t	namespace:glm
lowp_fmat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f32, lowp> lowp_fmat2x4;$/;"	t	namespace:glm
lowp_fmat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, lowp>		lowp_fmat3;$/;"	t	namespace:glm
lowp_fmat3	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_fmat3x3 lowp_fmat3;$/;"	t	namespace:glm
lowp_fmat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, lowp>		lowp_fmat3x2;$/;"	t	namespace:glm
lowp_fmat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f32, lowp> lowp_fmat3x2;$/;"	t	namespace:glm
lowp_fmat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, lowp>		lowp_fmat3x3;$/;"	t	namespace:glm
lowp_fmat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f32, lowp> lowp_fmat3x3;$/;"	t	namespace:glm
lowp_fmat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, lowp>		lowp_fmat3x4;$/;"	t	namespace:glm
lowp_fmat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f32, lowp> lowp_fmat3x4;$/;"	t	namespace:glm
lowp_fmat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, lowp>		lowp_fmat4;$/;"	t	namespace:glm
lowp_fmat4	vendor/glm/gtc/type_precision.hpp	/^	typedef lowp_fmat4x4 lowp_fmat4;$/;"	t	namespace:glm
lowp_fmat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, lowp>		lowp_fmat4x2;$/;"	t	namespace:glm
lowp_fmat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f32, lowp> lowp_fmat4x2;$/;"	t	namespace:glm
lowp_fmat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, lowp>		lowp_fmat4x3;$/;"	t	namespace:glm
lowp_fmat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f32, lowp> lowp_fmat4x3;$/;"	t	namespace:glm
lowp_fmat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, lowp>		lowp_fmat4x4;$/;"	t	namespace:glm
lowp_fmat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f32, lowp> lowp_fmat4x4;$/;"	t	namespace:glm
lowp_fquat	vendor/glm/fwd.hpp	/^	typedef qua<float, lowp>			lowp_fquat;$/;"	t	namespace:glm
lowp_fvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, float, lowp>			lowp_fvec1;$/;"	t	namespace:glm
lowp_fvec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, float, lowp> lowp_fvec1;$/;"	t	namespace:glm
lowp_fvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, float, lowp>			lowp_fvec2;$/;"	t	namespace:glm
lowp_fvec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, float, lowp> lowp_fvec2;$/;"	t	namespace:glm
lowp_fvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, float, lowp>			lowp_fvec3;$/;"	t	namespace:glm
lowp_fvec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, float, lowp> lowp_fvec3;$/;"	t	namespace:glm
lowp_fvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, float, lowp>			lowp_fvec4;$/;"	t	namespace:glm
lowp_fvec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, float, lowp> lowp_fvec4;$/;"	t	namespace:glm
lowp_i16	vendor/glm/fwd.hpp	/^	typedef int16					lowp_i16;$/;"	t	namespace:glm
lowp_i16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int16 lowp_i16;$/;"	t	namespace:glm
lowp_i16vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i16, lowp>		lowp_i16vec1;$/;"	t	namespace:glm
lowp_i16vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i16, lowp>		lowp_i16vec1;$/;"	t	namespace:glm
lowp_i16vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i16, lowp>		lowp_i16vec2;$/;"	t	namespace:glm
lowp_i16vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i16, lowp>		lowp_i16vec2;$/;"	t	namespace:glm
lowp_i16vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i16, lowp>		lowp_i16vec3;$/;"	t	namespace:glm
lowp_i16vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i16, lowp>		lowp_i16vec3;$/;"	t	namespace:glm
lowp_i16vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i16, lowp>		lowp_i16vec4;$/;"	t	namespace:glm
lowp_i16vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i16, lowp>		lowp_i16vec4;$/;"	t	namespace:glm
lowp_i32	vendor/glm/fwd.hpp	/^	typedef int32					lowp_i32;$/;"	t	namespace:glm
lowp_i32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int32 lowp_i32;$/;"	t	namespace:glm
lowp_i32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i32, lowp>		lowp_i32vec1;$/;"	t	namespace:glm
lowp_i32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i32, lowp>		lowp_i32vec1;$/;"	t	namespace:glm
lowp_i32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i32, lowp>		lowp_i32vec2;$/;"	t	namespace:glm
lowp_i32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i32, lowp>		lowp_i32vec2;$/;"	t	namespace:glm
lowp_i32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i32, lowp>		lowp_i32vec3;$/;"	t	namespace:glm
lowp_i32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i32, lowp>		lowp_i32vec3;$/;"	t	namespace:glm
lowp_i32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i32, lowp>		lowp_i32vec4;$/;"	t	namespace:glm
lowp_i32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i32, lowp>		lowp_i32vec4;$/;"	t	namespace:glm
lowp_i64	vendor/glm/fwd.hpp	/^	typedef int64					lowp_i64;$/;"	t	namespace:glm
lowp_i64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int64 lowp_i64;$/;"	t	namespace:glm
lowp_i64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i64, lowp>		lowp_i64vec1;$/;"	t	namespace:glm
lowp_i64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i64, lowp>		lowp_i64vec1;$/;"	t	namespace:glm
lowp_i64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i64, lowp>		lowp_i64vec2;$/;"	t	namespace:glm
lowp_i64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i64, lowp>		lowp_i64vec2;$/;"	t	namespace:glm
lowp_i64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i64, lowp>		lowp_i64vec3;$/;"	t	namespace:glm
lowp_i64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i64, lowp>		lowp_i64vec3;$/;"	t	namespace:glm
lowp_i64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i64, lowp>		lowp_i64vec4;$/;"	t	namespace:glm
lowp_i64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i64, lowp>		lowp_i64vec4;$/;"	t	namespace:glm
lowp_i8	vendor/glm/fwd.hpp	/^	typedef int8					lowp_i8;$/;"	t	namespace:glm
lowp_i8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int8 lowp_i8;$/;"	t	namespace:glm
lowp_i8vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i8, lowp>		lowp_i8vec1;$/;"	t	namespace:glm
lowp_i8vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i8, lowp> lowp_i8vec1;$/;"	t	namespace:glm
lowp_i8vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i8, lowp>		lowp_i8vec2;$/;"	t	namespace:glm
lowp_i8vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i8, lowp> lowp_i8vec2;$/;"	t	namespace:glm
lowp_i8vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i8, lowp>		lowp_i8vec3;$/;"	t	namespace:glm
lowp_i8vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i8, lowp> lowp_i8vec3;$/;"	t	namespace:glm
lowp_i8vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i8, lowp>		lowp_i8vec4;$/;"	t	namespace:glm
lowp_i8vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i8, lowp> lowp_i8vec4;$/;"	t	namespace:glm
lowp_imat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, int, lowp>				lowp_imat2;$/;"	t	namespace:glm
lowp_imat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, int, lowp>				lowp_imat2x2;$/;"	t	namespace:glm
lowp_imat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 3, int, lowp>				lowp_imat2x3;$/;"	t	namespace:glm
lowp_imat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 4, int, lowp>				lowp_imat2x4;$/;"	t	namespace:glm
lowp_imat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, int, lowp>				lowp_imat3;$/;"	t	namespace:glm
lowp_imat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 2, int, lowp>				lowp_imat3x2;$/;"	t	namespace:glm
lowp_imat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, int, lowp>				lowp_imat3x3;$/;"	t	namespace:glm
lowp_imat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 4, int, lowp>				lowp_imat3x4;$/;"	t	namespace:glm
lowp_imat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, int, lowp>				lowp_imat4;$/;"	t	namespace:glm
lowp_imat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 2, int, lowp>				lowp_imat4x2;$/;"	t	namespace:glm
lowp_imat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 3, int, lowp>				lowp_imat4x3;$/;"	t	namespace:glm
lowp_imat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, int, lowp>				lowp_imat4x4;$/;"	t	namespace:glm
lowp_int16	vendor/glm/fwd.hpp	/^	typedef int16					lowp_int16;$/;"	t	namespace:glm
lowp_int16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int16 lowp_int16;$/;"	t	namespace:glm
lowp_int16_t	vendor/glm/fwd.hpp	/^	typedef int16					lowp_int16_t;$/;"	t	namespace:glm
lowp_int16_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int16 lowp_int16_t;$/;"	t	namespace:glm
lowp_int32	vendor/glm/fwd.hpp	/^	typedef int32					lowp_int32;$/;"	t	namespace:glm
lowp_int32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int32 lowp_int32;$/;"	t	namespace:glm
lowp_int32_t	vendor/glm/fwd.hpp	/^	typedef int32					lowp_int32_t;$/;"	t	namespace:glm
lowp_int32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int32 lowp_int32_t;$/;"	t	namespace:glm
lowp_int64	vendor/glm/fwd.hpp	/^	typedef int64					lowp_int64;$/;"	t	namespace:glm
lowp_int64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int64 lowp_int64;$/;"	t	namespace:glm
lowp_int64_t	vendor/glm/fwd.hpp	/^	typedef int64					lowp_int64_t;$/;"	t	namespace:glm
lowp_int64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int64 lowp_int64_t;$/;"	t	namespace:glm
lowp_int8	vendor/glm/fwd.hpp	/^	typedef int8					lowp_int8;$/;"	t	namespace:glm
lowp_int8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int8 lowp_int8;$/;"	t	namespace:glm
lowp_int8_t	vendor/glm/fwd.hpp	/^	typedef int8					lowp_int8_t;$/;"	t	namespace:glm
lowp_int8_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int8 lowp_int8_t;$/;"	t	namespace:glm
lowp_ivec1	vendor/glm/ext/vector_int1_precision.hpp	/^	typedef vec<1, int, lowp>			lowp_ivec1;$/;"	t	namespace:glm
lowp_ivec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i32, lowp>		lowp_ivec1;$/;"	t	namespace:glm
lowp_ivec2	vendor/glm/ext/vector_int2_precision.hpp	/^	typedef vec<2, int, lowp>		lowp_ivec2;$/;"	t	namespace:glm
lowp_ivec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i32, lowp>		lowp_ivec2;$/;"	t	namespace:glm
lowp_ivec3	vendor/glm/ext/vector_int3_precision.hpp	/^	typedef vec<3, int, lowp>		lowp_ivec3;$/;"	t	namespace:glm
lowp_ivec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i32, lowp>		lowp_ivec3;$/;"	t	namespace:glm
lowp_ivec4	vendor/glm/ext/vector_int4_precision.hpp	/^	typedef vec<4, int, lowp>		lowp_ivec4;$/;"	t	namespace:glm
lowp_ivec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i32, lowp>		lowp_ivec4;$/;"	t	namespace:glm
lowp_mat2	vendor/glm/ext/matrix_float2x2_precision.hpp	/^	typedef mat<2, 2, float, lowp>		lowp_mat2;$/;"	t	namespace:glm
lowp_mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, lowp>		lowp_mat2;$/;"	t	namespace:glm
lowp_mat2x2	vendor/glm/ext/matrix_float2x2_precision.hpp	/^	typedef mat<2, 2, float, lowp>		lowp_mat2x2;$/;"	t	namespace:glm
lowp_mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, lowp>		lowp_mat2x2;$/;"	t	namespace:glm
lowp_mat2x3	vendor/glm/ext/matrix_float2x3_precision.hpp	/^	typedef mat<2, 3, float, lowp>		lowp_mat2x3;$/;"	t	namespace:glm
lowp_mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, lowp>		lowp_mat2x3;$/;"	t	namespace:glm
lowp_mat2x4	vendor/glm/ext/matrix_float2x4_precision.hpp	/^	typedef mat<2, 4, float, lowp>		lowp_mat2x4;$/;"	t	namespace:glm
lowp_mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, lowp>		lowp_mat2x4;$/;"	t	namespace:glm
lowp_mat3	vendor/glm/ext/matrix_float3x3_precision.hpp	/^	typedef mat<3, 3, float, lowp>		lowp_mat3;$/;"	t	namespace:glm
lowp_mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, lowp>		lowp_mat3;$/;"	t	namespace:glm
lowp_mat3x2	vendor/glm/ext/matrix_float3x2_precision.hpp	/^	typedef mat<3, 2, float, lowp>		lowp_mat3x2;$/;"	t	namespace:glm
lowp_mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, lowp>		lowp_mat3x2;$/;"	t	namespace:glm
lowp_mat3x3	vendor/glm/ext/matrix_float3x3_precision.hpp	/^	typedef mat<3, 3, float, lowp>		lowp_mat3x3;$/;"	t	namespace:glm
lowp_mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, lowp>		lowp_mat3x3;$/;"	t	namespace:glm
lowp_mat3x4	vendor/glm/ext/matrix_float3x4_precision.hpp	/^	typedef mat<3, 4, float, lowp>		lowp_mat3x4;$/;"	t	namespace:glm
lowp_mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, lowp>		lowp_mat3x4;$/;"	t	namespace:glm
lowp_mat4	vendor/glm/ext/matrix_float4x4_precision.hpp	/^	typedef mat<4, 4, float, lowp>		lowp_mat4;$/;"	t	namespace:glm
lowp_mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, lowp>		lowp_mat4;$/;"	t	namespace:glm
lowp_mat4x2	vendor/glm/ext/matrix_float4x2_precision.hpp	/^	typedef mat<4, 2, float, lowp>		lowp_mat4x2;$/;"	t	namespace:glm
lowp_mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, lowp>		lowp_mat4x2;$/;"	t	namespace:glm
lowp_mat4x3	vendor/glm/ext/matrix_float4x3_precision.hpp	/^	typedef mat<4, 3, float, lowp>		lowp_mat4x3;$/;"	t	namespace:glm
lowp_mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, lowp>		lowp_mat4x3;$/;"	t	namespace:glm
lowp_mat4x4	vendor/glm/ext/matrix_float4x4_precision.hpp	/^	typedef mat<4, 4, float, lowp>		lowp_mat4x4;$/;"	t	namespace:glm
lowp_mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, lowp>		lowp_mat4x4;$/;"	t	namespace:glm
lowp_quat	vendor/glm/ext/quaternion_float_precision.hpp	/^	typedef qua<float, lowp>		lowp_quat;$/;"	t	namespace:glm
lowp_quat	vendor/glm/fwd.hpp	/^	typedef qua<float, lowp>			lowp_quat;$/;"	t	namespace:glm
lowp_u16	vendor/glm/fwd.hpp	/^	typedef uint16					lowp_u16;$/;"	t	namespace:glm
lowp_u16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint16 lowp_u16;$/;"	t	namespace:glm
lowp_u16vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u16, lowp>		lowp_u16vec1;$/;"	t	namespace:glm
lowp_u16vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u16, lowp>		lowp_u16vec1;$/;"	t	namespace:glm
lowp_u16vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u16, lowp>		lowp_u16vec2;$/;"	t	namespace:glm
lowp_u16vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u16, lowp>		lowp_u16vec2;$/;"	t	namespace:glm
lowp_u16vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u16, lowp>		lowp_u16vec3;$/;"	t	namespace:glm
lowp_u16vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u16, lowp>		lowp_u16vec3;$/;"	t	namespace:glm
lowp_u16vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u16, lowp>		lowp_u16vec4;$/;"	t	namespace:glm
lowp_u16vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u16, lowp>		lowp_u16vec4;$/;"	t	namespace:glm
lowp_u32	vendor/glm/fwd.hpp	/^	typedef uint32					lowp_u32;$/;"	t	namespace:glm
lowp_u32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint32 lowp_u32;$/;"	t	namespace:glm
lowp_u32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u32, lowp>		lowp_u32vec1;$/;"	t	namespace:glm
lowp_u32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u32, lowp>		lowp_u32vec1;$/;"	t	namespace:glm
lowp_u32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u32, lowp>		lowp_u32vec2;$/;"	t	namespace:glm
lowp_u32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u32, lowp>		lowp_u32vec2;$/;"	t	namespace:glm
lowp_u32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u32, lowp>		lowp_u32vec3;$/;"	t	namespace:glm
lowp_u32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u32, lowp>		lowp_u32vec3;$/;"	t	namespace:glm
lowp_u32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u32, lowp>		lowp_u32vec4;$/;"	t	namespace:glm
lowp_u32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u32, lowp>		lowp_u32vec4;$/;"	t	namespace:glm
lowp_u64	vendor/glm/fwd.hpp	/^	typedef uint64					lowp_u64;$/;"	t	namespace:glm
lowp_u64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint64 lowp_u64;$/;"	t	namespace:glm
lowp_u64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u64, lowp>		lowp_u64vec1;$/;"	t	namespace:glm
lowp_u64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u64, lowp>		lowp_u64vec1;$/;"	t	namespace:glm
lowp_u64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u64, lowp>		lowp_u64vec2;$/;"	t	namespace:glm
lowp_u64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u64, lowp>		lowp_u64vec2;$/;"	t	namespace:glm
lowp_u64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u64, lowp>		lowp_u64vec3;$/;"	t	namespace:glm
lowp_u64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u64, lowp>		lowp_u64vec3;$/;"	t	namespace:glm
lowp_u64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u64, lowp>		lowp_u64vec4;$/;"	t	namespace:glm
lowp_u64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u64, lowp>		lowp_u64vec4;$/;"	t	namespace:glm
lowp_u8	vendor/glm/fwd.hpp	/^	typedef uint8					lowp_u8;$/;"	t	namespace:glm
lowp_u8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint8 lowp_u8;$/;"	t	namespace:glm
lowp_u8vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u8, lowp>		lowp_u8vec1;$/;"	t	namespace:glm
lowp_u8vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u8, lowp> lowp_u8vec1;$/;"	t	namespace:glm
lowp_u8vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u8, lowp>		lowp_u8vec2;$/;"	t	namespace:glm
lowp_u8vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u8, lowp> lowp_u8vec2;$/;"	t	namespace:glm
lowp_u8vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u8, lowp>		lowp_u8vec3;$/;"	t	namespace:glm
lowp_u8vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u8, lowp> lowp_u8vec3;$/;"	t	namespace:glm
lowp_u8vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u8, lowp>		lowp_u8vec4;$/;"	t	namespace:glm
lowp_u8vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u8, lowp> lowp_u8vec4;$/;"	t	namespace:glm
lowp_uint16	vendor/glm/fwd.hpp	/^	typedef uint16					lowp_uint16;$/;"	t	namespace:glm
lowp_uint16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint16 lowp_uint16;$/;"	t	namespace:glm
lowp_uint16_t	vendor/glm/fwd.hpp	/^	typedef uint16					lowp_uint16_t;$/;"	t	namespace:glm
lowp_uint16_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint16 lowp_uint16_t;$/;"	t	namespace:glm
lowp_uint32	vendor/glm/fwd.hpp	/^	typedef uint32					lowp_uint32;$/;"	t	namespace:glm
lowp_uint32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint32 lowp_uint32;$/;"	t	namespace:glm
lowp_uint32_t	vendor/glm/fwd.hpp	/^	typedef uint32					lowp_uint32_t;$/;"	t	namespace:glm
lowp_uint32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint32 lowp_uint32_t;$/;"	t	namespace:glm
lowp_uint64	vendor/glm/fwd.hpp	/^	typedef uint64					lowp_uint64;$/;"	t	namespace:glm
lowp_uint64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint64 lowp_uint64;$/;"	t	namespace:glm
lowp_uint64_t	vendor/glm/fwd.hpp	/^	typedef uint64					lowp_uint64_t;$/;"	t	namespace:glm
lowp_uint64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint64 lowp_uint64_t;$/;"	t	namespace:glm
lowp_uint8	vendor/glm/fwd.hpp	/^	typedef uint8					lowp_uint8;$/;"	t	namespace:glm
lowp_uint8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint8 lowp_uint8;$/;"	t	namespace:glm
lowp_uint8_t	vendor/glm/fwd.hpp	/^	typedef uint8					lowp_uint8_t;$/;"	t	namespace:glm
lowp_uint8_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint8 lowp_uint8_t;$/;"	t	namespace:glm
lowp_umat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, uint, lowp>				lowp_umat2;$/;"	t	namespace:glm
lowp_umat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, uint, lowp>				lowp_umat2x2;$/;"	t	namespace:glm
lowp_umat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 3, uint, lowp>				lowp_umat2x3;$/;"	t	namespace:glm
lowp_umat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 4, uint, lowp>				lowp_umat2x4;$/;"	t	namespace:glm
lowp_umat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, uint, lowp>				lowp_umat3;$/;"	t	namespace:glm
lowp_umat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 2, uint, lowp>				lowp_umat3x2;$/;"	t	namespace:glm
lowp_umat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, uint, lowp>				lowp_umat3x3;$/;"	t	namespace:glm
lowp_umat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 4, uint, lowp>				lowp_umat3x4;$/;"	t	namespace:glm
lowp_umat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, uint, lowp>				lowp_umat4;$/;"	t	namespace:glm
lowp_umat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 2, uint, lowp>				lowp_umat4x2;$/;"	t	namespace:glm
lowp_umat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 3, uint, lowp>				lowp_umat4x3;$/;"	t	namespace:glm
lowp_umat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, uint, lowp>				lowp_umat4x4;$/;"	t	namespace:glm
lowp_uvec1	vendor/glm/ext/vector_uint1_precision.hpp	/^	typedef vec<1, unsigned int, lowp>			lowp_uvec1;$/;"	t	namespace:glm
lowp_uvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u32, lowp>		lowp_uvec1;$/;"	t	namespace:glm
lowp_uvec2	vendor/glm/ext/vector_uint2_precision.hpp	/^	typedef vec<2, unsigned int, lowp>		lowp_uvec2;$/;"	t	namespace:glm
lowp_uvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u32, lowp>		lowp_uvec2;$/;"	t	namespace:glm
lowp_uvec3	vendor/glm/ext/vector_uint3_precision.hpp	/^	typedef vec<3, unsigned int, lowp>		lowp_uvec3;$/;"	t	namespace:glm
lowp_uvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u32, lowp>		lowp_uvec3;$/;"	t	namespace:glm
lowp_uvec4	vendor/glm/ext/vector_uint4_precision.hpp	/^	typedef vec<4, unsigned int, lowp>		lowp_uvec4;$/;"	t	namespace:glm
lowp_uvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u32, lowp>		lowp_uvec4;$/;"	t	namespace:glm
lowp_vec1	vendor/glm/ext/vector_float1_precision.hpp	/^	typedef vec<1, float, lowp>			lowp_vec1;$/;"	t	namespace:glm
lowp_vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, float, lowp>			lowp_vec1;$/;"	t	namespace:glm
lowp_vec2	vendor/glm/ext/vector_float2_precision.hpp	/^	typedef vec<2, float, lowp>			lowp_vec2;$/;"	t	namespace:glm
lowp_vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, float, lowp>			lowp_vec2;$/;"	t	namespace:glm
lowp_vec3	vendor/glm/ext/vector_float3_precision.hpp	/^	typedef vec<3, float, lowp>			lowp_vec3;$/;"	t	namespace:glm
lowp_vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, float, lowp>			lowp_vec3;$/;"	t	namespace:glm
lowp_vec4	vendor/glm/ext/vector_float4_precision.hpp	/^	typedef vec<4, float, lowp>			lowp_vec4;$/;"	t	namespace:glm
lowp_vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, float, lowp>			lowp_vec4;$/;"	t	namespace:glm
lpal	vendor/stb_image/stb_image.h	/^   stbi_uc lpal[256][4];$/;"	m	struct:__anon72
ma	vendor/stb_image/stb_image.h	/^   unsigned int mr,mg,mb,ma, all_a;$/;"	m	struct:__anon69
main	Application.cpp	/^int main(void)$/;"	f
main	Painter/Test.cpp	/^int main(){$/;"	f
main	vendor/imgui/imstb_truetype.h	/^int main(int argc, char **argv)$/;"	f
main_clipboard	vendor/imgui/imgui.cpp	/^static PasteboardRef main_clipboard = 0;$/;"	v	file:
mantissa	vendor/glm/detail/type_float.hpp	/^		GLM_CONSTEXPR int_type mantissa() const { return i & ((1 << 23) - 1); }$/;"	f	union:glm::detail::float_t
mantissa	vendor/glm/detail/type_float.hpp	/^		GLM_CONSTEXPR int_type mantissa() const { return i & ((int_type(1) << 52) - 1); }$/;"	f	union:glm::detail::float_t
marker	vendor/stb_image/stb_image.h	/^   unsigned char  marker;      \/\/ marker seen while filling entropy buffer$/;"	m	struct:__anon61
mat	vendor/glm/detail/type_mat2x2.hpp	/^	struct mat<2, 2, T, Q>$/;"	s	namespace:glm
mat	vendor/glm/detail/type_mat2x3.hpp	/^	struct mat<2, 3, T, Q>$/;"	s	namespace:glm
mat	vendor/glm/detail/type_mat2x4.hpp	/^	struct mat<2, 4, T, Q>$/;"	s	namespace:glm
mat	vendor/glm/detail/type_mat3x2.hpp	/^	struct mat<3, 2, T, Q>$/;"	s	namespace:glm
mat	vendor/glm/detail/type_mat3x3.hpp	/^	struct mat<3, 3, T, Q>$/;"	s	namespace:glm
mat	vendor/glm/detail/type_mat3x4.hpp	/^	struct mat<3, 4, T, Q>$/;"	s	namespace:glm
mat	vendor/glm/detail/type_mat4x2.hpp	/^	struct mat<4, 2, T, Q>$/;"	s	namespace:glm
mat	vendor/glm/detail/type_mat4x3.hpp	/^	struct mat<4, 3, T, Q>$/;"	s	namespace:glm
mat	vendor/glm/detail/type_mat4x4.hpp	/^	struct mat<4, 4, T, Q>$/;"	s	namespace:glm
mat2	vendor/glm/ext/matrix_float2x2.hpp	/^	typedef mat<2, 2, float, defaultp>		mat2;$/;"	t	namespace:glm
mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, defaultp>	mat2;$/;"	t	namespace:glm
mat2x2	vendor/glm/ext/matrix_float2x2.hpp	/^	typedef mat<2, 2, float, defaultp>		mat2x2;$/;"	t	namespace:glm
mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, defaultp>	mat2x2;$/;"	t	namespace:glm
mat2x3	vendor/glm/ext/matrix_float2x3.hpp	/^	typedef mat<2, 3, float, defaultp>		mat2x3;$/;"	t	namespace:glm
mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, defaultp>	mat2x3;$/;"	t	namespace:glm
mat2x4	vendor/glm/ext/matrix_float2x4.hpp	/^	typedef mat<2, 4, float, defaultp>		mat2x4;$/;"	t	namespace:glm
mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, defaultp>	mat2x4;$/;"	t	namespace:glm
mat3	vendor/glm/ext/matrix_float3x3.hpp	/^	typedef mat<3, 3, float, defaultp>			mat3;$/;"	t	namespace:glm
mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, defaultp>	mat3;$/;"	t	namespace:glm
mat3x2	vendor/glm/ext/matrix_float3x2.hpp	/^	typedef mat<3, 2, float, defaultp>			mat3x2;$/;"	t	namespace:glm
mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, defaultp>	mat3x2;$/;"	t	namespace:glm
mat3x3	vendor/glm/ext/matrix_float3x3.hpp	/^	typedef mat<3, 3, float, defaultp>			mat3x3;$/;"	t	namespace:glm
mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, defaultp>	mat3x3;$/;"	t	namespace:glm
mat3x4	vendor/glm/ext/matrix_float3x4.hpp	/^	typedef mat<3, 4, float, defaultp>			mat3x4;$/;"	t	namespace:glm
mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, defaultp>	mat3x4;$/;"	t	namespace:glm
mat4	vendor/glm/ext/matrix_float4x4.hpp	/^	typedef mat<4, 4, float, defaultp>			mat4;$/;"	t	namespace:glm
mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, defaultp>	mat4;$/;"	t	namespace:glm
mat4x2	vendor/glm/ext/matrix_float4x2.hpp	/^	typedef mat<4, 2, float, defaultp>			mat4x2;$/;"	t	namespace:glm
mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, defaultp>	mat4x2;$/;"	t	namespace:glm
mat4x3	vendor/glm/ext/matrix_float4x3.hpp	/^	typedef mat<4, 3, float, defaultp>			mat4x3;$/;"	t	namespace:glm
mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, defaultp>	mat4x3;$/;"	t	namespace:glm
mat4x4	vendor/glm/ext/matrix_float4x4.hpp	/^	typedef mat<4, 4, float, defaultp>			mat4x4;$/;"	t	namespace:glm
mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, defaultp>	mat4x4;$/;"	t	namespace:glm
max	vendor/glm/detail/_fixes.hpp	5;"	d
max_x	vendor/imgui/imstb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon43
max_x	vendor/stb_image/stb_image.h	/^   int max_x, max_y;$/;"	m	struct:__anon72
max_y	vendor/imgui/imstb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon43
max_y	vendor/stb_image/stb_image.h	/^   int max_x, max_y;$/;"	m	struct:__anon72
maxcode	vendor/stb_image/stb_image.h	/^   int maxcode[17];$/;"	m	struct:__anon64
maxcode	vendor/stb_image/stb_image.h	/^   unsigned int maxcode[18];$/;"	m	struct:__anon60
mb	vendor/stb_image/stb_image.h	/^   unsigned int mr,mg,mb,ma, all_a;$/;"	m	struct:__anon69
mediump	vendor/glm/detail/qualifier.hpp	/^		mediump = packed_mediump, \/\/\/< By default mediump qualifier is also packed$/;"	e	enum:glm::qualifier
mediump_bvec1	vendor/glm/ext/vector_bool1_precision.hpp	/^	typedef vec<1, bool, mediump>		mediump_bvec1;$/;"	t	namespace:glm
mediump_bvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, bool, mediump>	mediump_bvec1;$/;"	t	namespace:glm
mediump_bvec2	vendor/glm/ext/vector_bool2_precision.hpp	/^	typedef vec<2, bool, mediump>	mediump_bvec2;$/;"	t	namespace:glm
mediump_bvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, bool, mediump>	mediump_bvec2;$/;"	t	namespace:glm
mediump_bvec3	vendor/glm/ext/vector_bool3_precision.hpp	/^	typedef vec<3, bool, mediump>	mediump_bvec3;$/;"	t	namespace:glm
mediump_bvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, bool, mediump>	mediump_bvec3;$/;"	t	namespace:glm
mediump_bvec4	vendor/glm/ext/vector_bool4_precision.hpp	/^	typedef vec<4, bool, mediump>	mediump_bvec4;$/;"	t	namespace:glm
mediump_bvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, bool, mediump>	mediump_bvec4;$/;"	t	namespace:glm
mediump_ddualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef tdualquat<double, mediump>	mediump_ddualquat;$/;"	t	namespace:glm
mediump_dmat2	vendor/glm/ext/matrix_double2x2_precision.hpp	/^	typedef mat<2, 2, double, mediump>	mediump_dmat2;$/;"	t	namespace:glm
mediump_dmat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, mediump>		mediump_dmat2;$/;"	t	namespace:glm
mediump_dmat2x2	vendor/glm/ext/matrix_double2x2_precision.hpp	/^	typedef mat<2, 2, double, mediump>	mediump_dmat2x2;$/;"	t	namespace:glm
mediump_dmat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, double, mediump>	mediump_dmat2x2;$/;"	t	namespace:glm
mediump_dmat2x3	vendor/glm/ext/matrix_double2x3_precision.hpp	/^	typedef mat<2, 3, double, mediump>	mediump_dmat2x3;$/;"	t	namespace:glm
mediump_dmat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, double, mediump>	mediump_dmat2x3;$/;"	t	namespace:glm
mediump_dmat2x4	vendor/glm/ext/matrix_double2x4_precision.hpp	/^	typedef mat<2, 4, double, mediump>	mediump_dmat2x4;$/;"	t	namespace:glm
mediump_dmat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, double, mediump>	mediump_dmat2x4;$/;"	t	namespace:glm
mediump_dmat3	vendor/glm/ext/matrix_double3x3_precision.hpp	/^	typedef mat<3, 3, double, mediump>	mediump_dmat3;$/;"	t	namespace:glm
mediump_dmat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, mediump>		mediump_dmat3;$/;"	t	namespace:glm
mediump_dmat3x2	vendor/glm/ext/matrix_double3x2_precision.hpp	/^	typedef mat<3, 2, double, mediump>	mediump_dmat3x2;$/;"	t	namespace:glm
mediump_dmat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, double, mediump>	mediump_dmat3x2;$/;"	t	namespace:glm
mediump_dmat3x3	vendor/glm/ext/matrix_double3x3_precision.hpp	/^	typedef mat<3, 3, double, mediump>	mediump_dmat3x3;$/;"	t	namespace:glm
mediump_dmat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, double, mediump>	mediump_dmat3x3;$/;"	t	namespace:glm
mediump_dmat3x4	vendor/glm/ext/matrix_double3x4_precision.hpp	/^	typedef mat<3, 4, double, mediump>	mediump_dmat3x4;$/;"	t	namespace:glm
mediump_dmat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, double, mediump>	mediump_dmat3x4;$/;"	t	namespace:glm
mediump_dmat4	vendor/glm/ext/matrix_double4x4_precision.hpp	/^	typedef mat<4, 4, double, mediump>	mediump_dmat4;$/;"	t	namespace:glm
mediump_dmat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, mediump>		mediump_dmat4;$/;"	t	namespace:glm
mediump_dmat4x2	vendor/glm/ext/matrix_double4x2_precision.hpp	/^	typedef mat<4, 2, double, mediump>	mediump_dmat4x2;$/;"	t	namespace:glm
mediump_dmat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, double, mediump>	mediump_dmat4x2;$/;"	t	namespace:glm
mediump_dmat4x3	vendor/glm/ext/matrix_double4x3_precision.hpp	/^	typedef mat<4, 3, double, mediump>	mediump_dmat4x3;$/;"	t	namespace:glm
mediump_dmat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, double, mediump>	mediump_dmat4x3;$/;"	t	namespace:glm
mediump_dmat4x4	vendor/glm/ext/matrix_double4x4_precision.hpp	/^	typedef mat<4, 4, double, mediump>	mediump_dmat4x4;$/;"	t	namespace:glm
mediump_dmat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, double, mediump>	mediump_dmat4x4;$/;"	t	namespace:glm
mediump_dquat	vendor/glm/ext/quaternion_double_precision.hpp	/^	typedef qua<double, mediump>	mediump_dquat;$/;"	t	namespace:glm
mediump_dquat	vendor/glm/fwd.hpp	/^	typedef qua<double, mediump>		mediump_dquat;$/;"	t	namespace:glm
mediump_dualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef tdualquat<float, mediump>	mediump_dualquat;$/;"	t	namespace:glm
mediump_dvec1	vendor/glm/ext/vector_double1_precision.hpp	/^	typedef vec<1, double, mediump>		mediump_dvec1;$/;"	t	namespace:glm
mediump_dvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f64, mediump>		mediump_dvec1;$/;"	t	namespace:glm
mediump_dvec2	vendor/glm/ext/vector_double2_precision.hpp	/^	typedef vec<2, double, mediump>		mediump_dvec2;$/;"	t	namespace:glm
mediump_dvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f64, mediump>		mediump_dvec2;$/;"	t	namespace:glm
mediump_dvec3	vendor/glm/ext/vector_double3_precision.hpp	/^	typedef vec<3, double, mediump>		mediump_dvec3;$/;"	t	namespace:glm
mediump_dvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f64, mediump>		mediump_dvec3;$/;"	t	namespace:glm
mediump_dvec4	vendor/glm/ext/vector_double4_precision.hpp	/^	typedef vec<4, double, mediump>		mediump_dvec4;$/;"	t	namespace:glm
mediump_dvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f64, mediump>		mediump_dvec4;$/;"	t	namespace:glm
mediump_f32	vendor/glm/fwd.hpp	/^	typedef float					mediump_f32;$/;"	t	namespace:glm
mediump_f32	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 mediump_f32;$/;"	t	namespace:glm
mediump_f32mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, mediump>		mediump_f32mat2;$/;"	t	namespace:glm
mediump_f32mat2	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_f32mat2x2 mediump_f32mat2;$/;"	t	namespace:glm
mediump_f32mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, mediump>		mediump_f32mat2x2;$/;"	t	namespace:glm
mediump_f32mat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f32, mediump> mediump_f32mat2x2;$/;"	t	namespace:glm
mediump_f32mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, mediump>		mediump_f32mat2x3;$/;"	t	namespace:glm
mediump_f32mat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f32, mediump> mediump_f32mat2x3;$/;"	t	namespace:glm
mediump_f32mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, mediump>		mediump_f32mat2x4;$/;"	t	namespace:glm
mediump_f32mat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f32, mediump> mediump_f32mat2x4;$/;"	t	namespace:glm
mediump_f32mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, mediump>		mediump_f32mat3;$/;"	t	namespace:glm
mediump_f32mat3	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_f32mat3x3 mediump_f32mat3;$/;"	t	namespace:glm
mediump_f32mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, mediump>		mediump_f32mat3x2;$/;"	t	namespace:glm
mediump_f32mat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f32, mediump> mediump_f32mat3x2;$/;"	t	namespace:glm
mediump_f32mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, mediump>		mediump_f32mat3x3;$/;"	t	namespace:glm
mediump_f32mat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f32, mediump> mediump_f32mat3x3;$/;"	t	namespace:glm
mediump_f32mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, mediump>		mediump_f32mat3x4;$/;"	t	namespace:glm
mediump_f32mat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f32, mediump> mediump_f32mat3x4;$/;"	t	namespace:glm
mediump_f32mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, mediump>		mediump_f32mat4;$/;"	t	namespace:glm
mediump_f32mat4	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_f32mat4x4 mediump_f32mat4;$/;"	t	namespace:glm
mediump_f32mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, mediump>		mediump_f32mat4x2;$/;"	t	namespace:glm
mediump_f32mat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f32, mediump> mediump_f32mat4x2;$/;"	t	namespace:glm
mediump_f32mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, mediump>		mediump_f32mat4x3;$/;"	t	namespace:glm
mediump_f32mat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f32, mediump> mediump_f32mat4x3;$/;"	t	namespace:glm
mediump_f32mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, mediump>		mediump_f32mat4x4;$/;"	t	namespace:glm
mediump_f32mat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f32, mediump> mediump_f32mat4x4;$/;"	t	namespace:glm
mediump_f32quat	vendor/glm/fwd.hpp	/^	typedef qua<f32, mediump>			mediump_f32quat;$/;"	t	namespace:glm
mediump_f32quat	vendor/glm/gtc/type_precision.hpp	/^	typedef qua<f32, mediump> mediump_f32quat;$/;"	t	namespace:glm
mediump_f32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f32, mediump>		mediump_f32vec1;$/;"	t	namespace:glm
mediump_f32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, f32, mediump> mediump_f32vec1;$/;"	t	namespace:glm
mediump_f32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f32, mediump>		mediump_f32vec2;$/;"	t	namespace:glm
mediump_f32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, f32, mediump> mediump_f32vec2;$/;"	t	namespace:glm
mediump_f32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f32, mediump>		mediump_f32vec3;$/;"	t	namespace:glm
mediump_f32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, f32, mediump> mediump_f32vec3;$/;"	t	namespace:glm
mediump_f32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f32, mediump>		mediump_f32vec4;$/;"	t	namespace:glm
mediump_f32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, f32, mediump> mediump_f32vec4;$/;"	t	namespace:glm
mediump_f64	vendor/glm/fwd.hpp	/^	typedef double					mediump_f64;$/;"	t	namespace:glm
mediump_f64	vendor/glm/gtc/type_precision.hpp	/^	typedef float64 mediump_f64;$/;"	t	namespace:glm
mediump_f64mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, mediump>		mediump_f64mat2;$/;"	t	namespace:glm
mediump_f64mat2	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_f64mat2x2 mediump_f64mat2;$/;"	t	namespace:glm
mediump_f64mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f64, mediump>		mediump_f64mat2x2;$/;"	t	namespace:glm
mediump_f64mat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f64, mediump> mediump_f64mat2x2;$/;"	t	namespace:glm
mediump_f64mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f64, mediump>		mediump_f64mat2x3;$/;"	t	namespace:glm
mediump_f64mat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f64, mediump> mediump_f64mat2x3;$/;"	t	namespace:glm
mediump_f64mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f64, mediump>		mediump_f64mat2x4;$/;"	t	namespace:glm
mediump_f64mat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f64, mediump> mediump_f64mat2x4;$/;"	t	namespace:glm
mediump_f64mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, mediump>		mediump_f64mat3;$/;"	t	namespace:glm
mediump_f64mat3	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_f64mat3x3 mediump_f64mat3;$/;"	t	namespace:glm
mediump_f64mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f64, mediump>		mediump_f64mat3x2;$/;"	t	namespace:glm
mediump_f64mat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f64, mediump> mediump_f64mat3x2;$/;"	t	namespace:glm
mediump_f64mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f64, mediump>		mediump_f64mat3x3;$/;"	t	namespace:glm
mediump_f64mat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f64, mediump> mediump_f64mat3x3;$/;"	t	namespace:glm
mediump_f64mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f64, mediump>		mediump_f64mat3x4;$/;"	t	namespace:glm
mediump_f64mat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f64, mediump> mediump_f64mat3x4;$/;"	t	namespace:glm
mediump_f64mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, mediump>		mediump_f64mat4;$/;"	t	namespace:glm
mediump_f64mat4	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_f64mat4x4 mediump_f64mat4;$/;"	t	namespace:glm
mediump_f64mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f64, mediump>		mediump_f64mat4x2;$/;"	t	namespace:glm
mediump_f64mat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f64, mediump> mediump_f64mat4x2;$/;"	t	namespace:glm
mediump_f64mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f64, mediump>		mediump_f64mat4x3;$/;"	t	namespace:glm
mediump_f64mat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f64, mediump> mediump_f64mat4x3;$/;"	t	namespace:glm
mediump_f64mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f64, mediump>		mediump_f64mat4x4;$/;"	t	namespace:glm
mediump_f64mat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f64, mediump> mediump_f64mat4x4;$/;"	t	namespace:glm
mediump_f64quat	vendor/glm/fwd.hpp	/^	typedef qua<f64, mediump>			mediump_f64quat;$/;"	t	namespace:glm
mediump_f64quat	vendor/glm/gtc/type_precision.hpp	/^	typedef qua<f64, mediump> mediump_f64quat;$/;"	t	namespace:glm
mediump_f64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, f64, mediump>		mediump_f64vec1;$/;"	t	namespace:glm
mediump_f64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, f64, mediump> mediump_f64vec1;$/;"	t	namespace:glm
mediump_f64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, f64, mediump>		mediump_f64vec2;$/;"	t	namespace:glm
mediump_f64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, f64, mediump> mediump_f64vec2;$/;"	t	namespace:glm
mediump_f64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, f64, mediump>		mediump_f64vec3;$/;"	t	namespace:glm
mediump_f64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, f64, mediump> mediump_f64vec3;$/;"	t	namespace:glm
mediump_f64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, f64, mediump>		mediump_f64vec4;$/;"	t	namespace:glm
mediump_f64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, f64, mediump> mediump_f64vec4;$/;"	t	namespace:glm
mediump_fdualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	typedef tdualquat<float, mediump>	mediump_fdualquat;$/;"	t	namespace:glm
mediump_float32	vendor/glm/fwd.hpp	/^	typedef float					mediump_float32;$/;"	t	namespace:glm
mediump_float32	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 mediump_float32;$/;"	t	namespace:glm
mediump_float32_t	vendor/glm/fwd.hpp	/^	typedef float					mediump_float32_t;$/;"	t	namespace:glm
mediump_float32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef float32 mediump_float32_t;$/;"	t	namespace:glm
mediump_float64	vendor/glm/fwd.hpp	/^	typedef double					mediump_float64;$/;"	t	namespace:glm
mediump_float64	vendor/glm/gtc/type_precision.hpp	/^	typedef float64 mediump_float64;$/;"	t	namespace:glm
mediump_float64_t	vendor/glm/fwd.hpp	/^	typedef double					mediump_float64_t;$/;"	t	namespace:glm
mediump_float64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef float64 mediump_float64_t;$/;"	t	namespace:glm
mediump_fmat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, mediump>		mediump_fmat2;$/;"	t	namespace:glm
mediump_fmat2	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_fmat2x2 mediump_fmat2;$/;"	t	namespace:glm
mediump_fmat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, mediump>		mediump_fmat2x2;$/;"	t	namespace:glm
mediump_fmat2x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 2, f32, mediump> mediump_fmat2x2;$/;"	t	namespace:glm
mediump_fmat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, mediump>		mediump_fmat2x3;$/;"	t	namespace:glm
mediump_fmat2x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 3, f32, mediump> mediump_fmat2x3;$/;"	t	namespace:glm
mediump_fmat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, mediump>		mediump_fmat2x4;$/;"	t	namespace:glm
mediump_fmat2x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<2, 4, f32, mediump> mediump_fmat2x4;$/;"	t	namespace:glm
mediump_fmat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, mediump>		mediump_fmat3;$/;"	t	namespace:glm
mediump_fmat3	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_fmat3x3 mediump_fmat3;$/;"	t	namespace:glm
mediump_fmat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, mediump>		mediump_fmat3x2;$/;"	t	namespace:glm
mediump_fmat3x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 2, f32, mediump> mediump_fmat3x2;$/;"	t	namespace:glm
mediump_fmat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, mediump>		mediump_fmat3x3;$/;"	t	namespace:glm
mediump_fmat3x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 3, f32, mediump> mediump_fmat3x3;$/;"	t	namespace:glm
mediump_fmat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, mediump>		mediump_fmat3x4;$/;"	t	namespace:glm
mediump_fmat3x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<3, 4, f32, mediump> mediump_fmat3x4;$/;"	t	namespace:glm
mediump_fmat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, mediump>		mediump_fmat4;$/;"	t	namespace:glm
mediump_fmat4	vendor/glm/gtc/type_precision.hpp	/^	typedef mediump_fmat4x4 mediump_fmat4;$/;"	t	namespace:glm
mediump_fmat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, mediump>		mediump_fmat4x2;$/;"	t	namespace:glm
mediump_fmat4x2	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 2, f32, mediump> mediump_fmat4x2;$/;"	t	namespace:glm
mediump_fmat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, mediump>		mediump_fmat4x3;$/;"	t	namespace:glm
mediump_fmat4x3	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 3, f32, mediump> mediump_fmat4x3;$/;"	t	namespace:glm
mediump_fmat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, mediump>		mediump_fmat4x4;$/;"	t	namespace:glm
mediump_fmat4x4	vendor/glm/gtc/type_precision.hpp	/^	typedef mat<4, 4, f32, mediump> mediump_fmat4x4;$/;"	t	namespace:glm
mediump_fquat	vendor/glm/fwd.hpp	/^	typedef qua<float, mediump>			mediump_fquat;$/;"	t	namespace:glm
mediump_fvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, float, mediump>		mediump_fvec1;$/;"	t	namespace:glm
mediump_fvec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, float, mediump> mediump_fvec1;$/;"	t	namespace:glm
mediump_fvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, float, mediump>		mediump_fvec2;$/;"	t	namespace:glm
mediump_fvec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, float, mediump> mediump_fvec2;$/;"	t	namespace:glm
mediump_fvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, float, mediump>		mediump_fvec3;$/;"	t	namespace:glm
mediump_fvec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, float, mediump> mediump_fvec3;$/;"	t	namespace:glm
mediump_fvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, float, mediump>		mediump_fvec4;$/;"	t	namespace:glm
mediump_fvec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, float, mediump> mediump_fvec4;$/;"	t	namespace:glm
mediump_i16	vendor/glm/fwd.hpp	/^	typedef int16					mediump_i16;$/;"	t	namespace:glm
mediump_i16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int16 mediump_i16;$/;"	t	namespace:glm
mediump_i16vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i16, mediump>	mediump_i16vec1;$/;"	t	namespace:glm
mediump_i16vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i16, mediump>		mediump_i16vec1;$/;"	t	namespace:glm
mediump_i16vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i16, mediump>	mediump_i16vec2;$/;"	t	namespace:glm
mediump_i16vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i16, mediump>		mediump_i16vec2;$/;"	t	namespace:glm
mediump_i16vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i16, mediump>	mediump_i16vec3;$/;"	t	namespace:glm
mediump_i16vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i16, mediump>		mediump_i16vec3;$/;"	t	namespace:glm
mediump_i16vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i16, mediump>	mediump_i16vec4;$/;"	t	namespace:glm
mediump_i16vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i16, mediump>		mediump_i16vec4;$/;"	t	namespace:glm
mediump_i32	vendor/glm/fwd.hpp	/^	typedef int32					mediump_i32;$/;"	t	namespace:glm
mediump_i32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int32 mediump_i32;$/;"	t	namespace:glm
mediump_i32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i32, mediump>	mediump_i32vec1;$/;"	t	namespace:glm
mediump_i32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i32, mediump>		mediump_i32vec1;$/;"	t	namespace:glm
mediump_i32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i32, mediump>	mediump_i32vec2;$/;"	t	namespace:glm
mediump_i32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i32, mediump>		mediump_i32vec2;$/;"	t	namespace:glm
mediump_i32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i32, mediump>	mediump_i32vec3;$/;"	t	namespace:glm
mediump_i32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i32, mediump>		mediump_i32vec3;$/;"	t	namespace:glm
mediump_i32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i32, mediump>	mediump_i32vec4;$/;"	t	namespace:glm
mediump_i32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i32, mediump>		mediump_i32vec4;$/;"	t	namespace:glm
mediump_i64	vendor/glm/fwd.hpp	/^	typedef int64					mediump_i64;$/;"	t	namespace:glm
mediump_i64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int64 mediump_i64;$/;"	t	namespace:glm
mediump_i64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i64, mediump>	mediump_i64vec1;$/;"	t	namespace:glm
mediump_i64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i64, mediump>		mediump_i64vec1;$/;"	t	namespace:glm
mediump_i64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i64, mediump>	mediump_i64vec2;$/;"	t	namespace:glm
mediump_i64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i64, mediump>		mediump_i64vec2;$/;"	t	namespace:glm
mediump_i64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i64, mediump>	mediump_i64vec3;$/;"	t	namespace:glm
mediump_i64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i64, mediump>		mediump_i64vec3;$/;"	t	namespace:glm
mediump_i64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i64, mediump>	mediump_i64vec4;$/;"	t	namespace:glm
mediump_i64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i64, mediump>		mediump_i64vec4;$/;"	t	namespace:glm
mediump_i8	vendor/glm/fwd.hpp	/^	typedef int8					mediump_i8;$/;"	t	namespace:glm
mediump_i8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int8 mediump_i8;$/;"	t	namespace:glm
mediump_i8vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i8, mediump>		mediump_i8vec1;$/;"	t	namespace:glm
mediump_i8vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, i8, mediump> mediump_i8vec1;$/;"	t	namespace:glm
mediump_i8vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i8, mediump>		mediump_i8vec2;$/;"	t	namespace:glm
mediump_i8vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, i8, mediump> mediump_i8vec2;$/;"	t	namespace:glm
mediump_i8vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i8, mediump>		mediump_i8vec3;$/;"	t	namespace:glm
mediump_i8vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, i8, mediump> mediump_i8vec3;$/;"	t	namespace:glm
mediump_i8vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i8, mediump>		mediump_i8vec4;$/;"	t	namespace:glm
mediump_i8vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, i8, mediump> mediump_i8vec4;$/;"	t	namespace:glm
mediump_imat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, int, mediump>			mediump_imat2;$/;"	t	namespace:glm
mediump_imat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, int, mediump>			mediump_imat2x2;$/;"	t	namespace:glm
mediump_imat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 3, int, mediump>			mediump_imat2x3;$/;"	t	namespace:glm
mediump_imat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 4, int, mediump>			mediump_imat2x4;$/;"	t	namespace:glm
mediump_imat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, int, mediump>			mediump_imat3;$/;"	t	namespace:glm
mediump_imat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 2, int, mediump>			mediump_imat3x2;$/;"	t	namespace:glm
mediump_imat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, int, mediump>			mediump_imat3x3;$/;"	t	namespace:glm
mediump_imat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 4, int, mediump>			mediump_imat3x4;$/;"	t	namespace:glm
mediump_imat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, int, mediump>			mediump_imat4;$/;"	t	namespace:glm
mediump_imat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 2, int, mediump>			mediump_imat4x2;$/;"	t	namespace:glm
mediump_imat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 3, int, mediump>			mediump_imat4x3;$/;"	t	namespace:glm
mediump_imat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, int, mediump>			mediump_imat4x4;$/;"	t	namespace:glm
mediump_int16	vendor/glm/fwd.hpp	/^	typedef int16					mediump_int16;$/;"	t	namespace:glm
mediump_int16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int16 mediump_int16;$/;"	t	namespace:glm
mediump_int16_t	vendor/glm/fwd.hpp	/^	typedef int16					mediump_int16_t;$/;"	t	namespace:glm
mediump_int16_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int16 mediump_int16_t;$/;"	t	namespace:glm
mediump_int32	vendor/glm/fwd.hpp	/^	typedef int32					mediump_int32;$/;"	t	namespace:glm
mediump_int32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int32 mediump_int32;$/;"	t	namespace:glm
mediump_int32_t	vendor/glm/fwd.hpp	/^	typedef int32					mediump_int32_t;$/;"	t	namespace:glm
mediump_int32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int32 mediump_int32_t;$/;"	t	namespace:glm
mediump_int64	vendor/glm/fwd.hpp	/^	typedef int64					mediump_int64;$/;"	t	namespace:glm
mediump_int64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int64 mediump_int64;$/;"	t	namespace:glm
mediump_int64_t	vendor/glm/fwd.hpp	/^	typedef int64					mediump_int64_t;$/;"	t	namespace:glm
mediump_int64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int64 mediump_int64_t;$/;"	t	namespace:glm
mediump_int8	vendor/glm/fwd.hpp	/^	typedef int8					mediump_int8;$/;"	t	namespace:glm
mediump_int8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int8 mediump_int8;$/;"	t	namespace:glm
mediump_int8_t	vendor/glm/fwd.hpp	/^	typedef int8					mediump_int8_t;$/;"	t	namespace:glm
mediump_int8_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::int8 mediump_int8_t;$/;"	t	namespace:glm
mediump_ivec1	vendor/glm/ext/vector_int1_precision.hpp	/^	typedef vec<1, int, mediump>		mediump_ivec1;$/;"	t	namespace:glm
mediump_ivec1	vendor/glm/fwd.hpp	/^	typedef vec<1, i32, mediump>	mediump_ivec1;$/;"	t	namespace:glm
mediump_ivec2	vendor/glm/ext/vector_int2_precision.hpp	/^	typedef vec<2, int, mediump>	mediump_ivec2;$/;"	t	namespace:glm
mediump_ivec2	vendor/glm/fwd.hpp	/^	typedef vec<2, i32, mediump>	mediump_ivec2;$/;"	t	namespace:glm
mediump_ivec3	vendor/glm/ext/vector_int3_precision.hpp	/^	typedef vec<3, int, mediump>	mediump_ivec3;$/;"	t	namespace:glm
mediump_ivec3	vendor/glm/fwd.hpp	/^	typedef vec<3, i32, mediump>	mediump_ivec3;$/;"	t	namespace:glm
mediump_ivec4	vendor/glm/ext/vector_int4_precision.hpp	/^	typedef vec<4, int, mediump>	mediump_ivec4;$/;"	t	namespace:glm
mediump_ivec4	vendor/glm/fwd.hpp	/^	typedef vec<4, i32, mediump>	mediump_ivec4;$/;"	t	namespace:glm
mediump_mat2	vendor/glm/ext/matrix_float2x2_precision.hpp	/^	typedef mat<2, 2, float, mediump>	mediump_mat2;$/;"	t	namespace:glm
mediump_mat2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, mediump>		mediump_mat2;$/;"	t	namespace:glm
mediump_mat2x2	vendor/glm/ext/matrix_float2x2_precision.hpp	/^	typedef mat<2, 2, float, mediump>	mediump_mat2x2;$/;"	t	namespace:glm
mediump_mat2x2	vendor/glm/fwd.hpp	/^	typedef mat<2, 2, f32, mediump>		mediump_mat2x2;$/;"	t	namespace:glm
mediump_mat2x3	vendor/glm/ext/matrix_float2x3_precision.hpp	/^	typedef mat<2, 3, float, mediump>	mediump_mat2x3;$/;"	t	namespace:glm
mediump_mat2x3	vendor/glm/fwd.hpp	/^	typedef mat<2, 3, f32, mediump>		mediump_mat2x3;$/;"	t	namespace:glm
mediump_mat2x4	vendor/glm/ext/matrix_float2x4_precision.hpp	/^	typedef mat<2, 4, float, mediump>	mediump_mat2x4;$/;"	t	namespace:glm
mediump_mat2x4	vendor/glm/fwd.hpp	/^	typedef mat<2, 4, f32, mediump>		mediump_mat2x4;$/;"	t	namespace:glm
mediump_mat3	vendor/glm/ext/matrix_float3x3_precision.hpp	/^	typedef mat<3, 3, float, mediump>	mediump_mat3;$/;"	t	namespace:glm
mediump_mat3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, mediump>		mediump_mat3;$/;"	t	namespace:glm
mediump_mat3x2	vendor/glm/ext/matrix_float3x2_precision.hpp	/^	typedef mat<3, 2, float, mediump>	mediump_mat3x2;$/;"	t	namespace:glm
mediump_mat3x2	vendor/glm/fwd.hpp	/^	typedef mat<3, 2, f32, mediump>		mediump_mat3x2;$/;"	t	namespace:glm
mediump_mat3x3	vendor/glm/ext/matrix_float3x3_precision.hpp	/^	typedef mat<3, 3, float, mediump>	mediump_mat3x3;$/;"	t	namespace:glm
mediump_mat3x3	vendor/glm/fwd.hpp	/^	typedef mat<3, 3, f32, mediump>		mediump_mat3x3;$/;"	t	namespace:glm
mediump_mat3x4	vendor/glm/ext/matrix_float3x4_precision.hpp	/^	typedef mat<3, 4, float, mediump>	mediump_mat3x4;$/;"	t	namespace:glm
mediump_mat3x4	vendor/glm/fwd.hpp	/^	typedef mat<3, 4, f32, mediump>		mediump_mat3x4;$/;"	t	namespace:glm
mediump_mat4	vendor/glm/ext/matrix_float4x4_precision.hpp	/^	typedef mat<4, 4, float, mediump>	mediump_mat4;$/;"	t	namespace:glm
mediump_mat4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, mediump>		mediump_mat4;$/;"	t	namespace:glm
mediump_mat4x2	vendor/glm/ext/matrix_float4x2_precision.hpp	/^	typedef mat<4, 2, float, mediump>	mediump_mat4x2;$/;"	t	namespace:glm
mediump_mat4x2	vendor/glm/fwd.hpp	/^	typedef mat<4, 2, f32, mediump>		mediump_mat4x2;$/;"	t	namespace:glm
mediump_mat4x3	vendor/glm/ext/matrix_float4x3_precision.hpp	/^	typedef mat<4, 3, float, mediump>	mediump_mat4x3;$/;"	t	namespace:glm
mediump_mat4x3	vendor/glm/fwd.hpp	/^	typedef mat<4, 3, f32, mediump>		mediump_mat4x3;$/;"	t	namespace:glm
mediump_mat4x4	vendor/glm/ext/matrix_float4x4_precision.hpp	/^	typedef mat<4, 4, float, mediump>	mediump_mat4x4;$/;"	t	namespace:glm
mediump_mat4x4	vendor/glm/fwd.hpp	/^	typedef mat<4, 4, f32, mediump>		mediump_mat4x4;$/;"	t	namespace:glm
mediump_quat	vendor/glm/ext/quaternion_float_precision.hpp	/^	typedef qua<float, mediump>		mediump_quat;$/;"	t	namespace:glm
mediump_quat	vendor/glm/fwd.hpp	/^	typedef qua<float, mediump>			mediump_quat;$/;"	t	namespace:glm
mediump_u16	vendor/glm/fwd.hpp	/^	typedef uint16					mediump_u16;$/;"	t	namespace:glm
mediump_u16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint16 mediump_u16;$/;"	t	namespace:glm
mediump_u16vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u16, mediump>	mediump_u16vec1;$/;"	t	namespace:glm
mediump_u16vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u16, mediump>		mediump_u16vec1;$/;"	t	namespace:glm
mediump_u16vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u16, mediump>	mediump_u16vec2;$/;"	t	namespace:glm
mediump_u16vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u16, mediump>		mediump_u16vec2;$/;"	t	namespace:glm
mediump_u16vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u16, mediump>	mediump_u16vec3;$/;"	t	namespace:glm
mediump_u16vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u16, mediump>		mediump_u16vec3;$/;"	t	namespace:glm
mediump_u16vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u16, mediump>	mediump_u16vec4;$/;"	t	namespace:glm
mediump_u16vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u16, mediump>		mediump_u16vec4;$/;"	t	namespace:glm
mediump_u32	vendor/glm/fwd.hpp	/^	typedef uint32					mediump_u32;$/;"	t	namespace:glm
mediump_u32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint32 mediump_u32;$/;"	t	namespace:glm
mediump_u32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u32, mediump>	mediump_u32vec1;$/;"	t	namespace:glm
mediump_u32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u32, mediump>		mediump_u32vec1;$/;"	t	namespace:glm
mediump_u32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u32, mediump>	mediump_u32vec2;$/;"	t	namespace:glm
mediump_u32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u32, mediump>		mediump_u32vec2;$/;"	t	namespace:glm
mediump_u32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u32, mediump>	mediump_u32vec3;$/;"	t	namespace:glm
mediump_u32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u32, mediump>		mediump_u32vec3;$/;"	t	namespace:glm
mediump_u32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u32, mediump>	mediump_u32vec4;$/;"	t	namespace:glm
mediump_u32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u32, mediump>		mediump_u32vec4;$/;"	t	namespace:glm
mediump_u64	vendor/glm/fwd.hpp	/^	typedef uint64					mediump_u64;$/;"	t	namespace:glm
mediump_u64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint64 mediump_u64;$/;"	t	namespace:glm
mediump_u64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u64, mediump>	mediump_u64vec1;$/;"	t	namespace:glm
mediump_u64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u64, mediump>		mediump_u64vec1;$/;"	t	namespace:glm
mediump_u64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u64, mediump>	mediump_u64vec2;$/;"	t	namespace:glm
mediump_u64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u64, mediump>		mediump_u64vec2;$/;"	t	namespace:glm
mediump_u64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u64, mediump>	mediump_u64vec3;$/;"	t	namespace:glm
mediump_u64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u64, mediump>		mediump_u64vec3;$/;"	t	namespace:glm
mediump_u64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u64, mediump>	mediump_u64vec4;$/;"	t	namespace:glm
mediump_u64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u64, mediump>		mediump_u64vec4;$/;"	t	namespace:glm
mediump_u8	vendor/glm/fwd.hpp	/^	typedef uint8					mediump_u8;$/;"	t	namespace:glm
mediump_u8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint8 mediump_u8;$/;"	t	namespace:glm
mediump_u8vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u8, mediump>		mediump_u8vec1;$/;"	t	namespace:glm
mediump_u8vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u8, mediump> mediump_u8vec1;$/;"	t	namespace:glm
mediump_u8vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u8, mediump>		mediump_u8vec2;$/;"	t	namespace:glm
mediump_u8vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u8, mediump> mediump_u8vec2;$/;"	t	namespace:glm
mediump_u8vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u8, mediump>		mediump_u8vec3;$/;"	t	namespace:glm
mediump_u8vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u8, mediump> mediump_u8vec3;$/;"	t	namespace:glm
mediump_u8vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u8, mediump>		mediump_u8vec4;$/;"	t	namespace:glm
mediump_u8vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u8, mediump> mediump_u8vec4;$/;"	t	namespace:glm
mediump_uint16	vendor/glm/fwd.hpp	/^	typedef uint16					mediump_uint16;$/;"	t	namespace:glm
mediump_uint16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint16 mediump_uint16;$/;"	t	namespace:glm
mediump_uint16_t	vendor/glm/fwd.hpp	/^	typedef uint16					mediump_uint16_t;$/;"	t	namespace:glm
mediump_uint16_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint16 mediump_uint16_t;$/;"	t	namespace:glm
mediump_uint32	vendor/glm/fwd.hpp	/^	typedef uint32					mediump_uint32;$/;"	t	namespace:glm
mediump_uint32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint32 mediump_uint32;$/;"	t	namespace:glm
mediump_uint32_t	vendor/glm/fwd.hpp	/^	typedef uint32					mediump_uint32_t;$/;"	t	namespace:glm
mediump_uint32_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint32 mediump_uint32_t;$/;"	t	namespace:glm
mediump_uint64	vendor/glm/fwd.hpp	/^	typedef uint64					mediump_uint64;$/;"	t	namespace:glm
mediump_uint64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint64 mediump_uint64;$/;"	t	namespace:glm
mediump_uint64_t	vendor/glm/fwd.hpp	/^	typedef uint64					mediump_uint64_t;$/;"	t	namespace:glm
mediump_uint64_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint64 mediump_uint64_t;$/;"	t	namespace:glm
mediump_uint8	vendor/glm/fwd.hpp	/^	typedef uint8					mediump_uint8;$/;"	t	namespace:glm
mediump_uint8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint8 mediump_uint8;$/;"	t	namespace:glm
mediump_uint8_t	vendor/glm/fwd.hpp	/^	typedef uint8					mediump_uint8_t;$/;"	t	namespace:glm
mediump_uint8_t	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint8 mediump_uint8_t;$/;"	t	namespace:glm
mediump_umat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, uint, mediump>			mediump_umat2;$/;"	t	namespace:glm
mediump_umat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 2, uint, mediump>			mediump_umat2x2;$/;"	t	namespace:glm
mediump_umat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 3, uint, mediump>			mediump_umat2x3;$/;"	t	namespace:glm
mediump_umat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<2, 4, uint, mediump>			mediump_umat2x4;$/;"	t	namespace:glm
mediump_umat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, uint, mediump>			mediump_umat3;$/;"	t	namespace:glm
mediump_umat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 2, uint, mediump>			mediump_umat3x2;$/;"	t	namespace:glm
mediump_umat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 3, uint, mediump>			mediump_umat3x3;$/;"	t	namespace:glm
mediump_umat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<3, 4, uint, mediump>			mediump_umat3x4;$/;"	t	namespace:glm
mediump_umat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, uint, mediump>			mediump_umat4;$/;"	t	namespace:glm
mediump_umat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 2, uint, mediump>			mediump_umat4x2;$/;"	t	namespace:glm
mediump_umat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 3, uint, mediump>			mediump_umat4x3;$/;"	t	namespace:glm
mediump_umat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mat<4, 4, uint, mediump>			mediump_umat4x4;$/;"	t	namespace:glm
mediump_uvec1	vendor/glm/ext/vector_uint1_precision.hpp	/^	typedef vec<1, unsigned int, mediump>		mediump_uvec1;$/;"	t	namespace:glm
mediump_uvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u32, mediump>	mediump_uvec1;$/;"	t	namespace:glm
mediump_uvec2	vendor/glm/ext/vector_uint2_precision.hpp	/^	typedef vec<2, unsigned int, mediump>	mediump_uvec2;$/;"	t	namespace:glm
mediump_uvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u32, mediump>	mediump_uvec2;$/;"	t	namespace:glm
mediump_uvec3	vendor/glm/ext/vector_uint3_precision.hpp	/^	typedef vec<3, unsigned int, mediump>	mediump_uvec3;$/;"	t	namespace:glm
mediump_uvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u32, mediump>	mediump_uvec3;$/;"	t	namespace:glm
mediump_uvec4	vendor/glm/ext/vector_uint4_precision.hpp	/^	typedef vec<4, unsigned int, mediump>	mediump_uvec4;$/;"	t	namespace:glm
mediump_uvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u32, mediump>	mediump_uvec4;$/;"	t	namespace:glm
mediump_vec1	vendor/glm/ext/vector_float1_precision.hpp	/^	typedef vec<1, float, mediump>		mediump_vec1;$/;"	t	namespace:glm
mediump_vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, float, mediump>		mediump_vec1;$/;"	t	namespace:glm
mediump_vec2	vendor/glm/ext/vector_float2_precision.hpp	/^	typedef vec<2, float, mediump>		mediump_vec2;$/;"	t	namespace:glm
mediump_vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, float, mediump>		mediump_vec2;$/;"	t	namespace:glm
mediump_vec3	vendor/glm/ext/vector_float3_precision.hpp	/^	typedef vec<3, float, mediump>		mediump_vec3;$/;"	t	namespace:glm
mediump_vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, float, mediump>		mediump_vec3;$/;"	t	namespace:glm
mediump_vec4	vendor/glm/ext/vector_float4_precision.hpp	/^	typedef vec<4, float, mediump>		mediump_vec4;$/;"	t	namespace:glm
mediump_vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, float, mediump>		mediump_vec4;$/;"	t	namespace:glm
mg	vendor/stb_image/stb_image.h	/^   unsigned int mr,mg,mb,ma, all_a;$/;"	m	struct:__anon69
min	vendor/glm/detail/_fixes.hpp	10;"	d
min_x	vendor/imgui/imstb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon43
min_y	vendor/imgui/imstb_truetype.h	/^   stbtt_int32 min_x, max_x, min_y, max_y;$/;"	m	struct:__anon43
mod289	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER T mod289(T const& x)$/;"	f	namespace:glm::detail
mr	vendor/stb_image/stb_image.h	/^   unsigned int mr,mg,mb,ma, all_a;$/;"	m	struct:__anon69
my_stbtt_initfont	vendor/imgui/imstb_truetype.h	/^void my_stbtt_initfont(void)$/;"	f
my_stbtt_print	vendor/imgui/imstb_truetype.h	/^void my_stbtt_print(float x, float y, char *text)$/;"	f
negative	vendor/glm/detail/type_float.hpp	/^		GLM_CONSTEXPR bool negative() const { return i < 0; }$/;"	f	union:glm::detail::float_t
newline	vendor/glm/gtx/io.hpp	/^			char_type  newline;$/;"	m	class:glm::io::format_punct
next	vendor/imgui/imstb_rectpack.h	/^   stbrp_node  *next;$/;"	m	struct:stbrp_node
next	vendor/imgui/imstb_truetype.h	/^   struct stbtt__active_edge *next;$/;"	m	struct:stbtt__active_edge	typeref:struct:stbtt__active_edge::stbtt__active_edge
next	vendor/imgui/imstb_truetype.h	/^   struct stbtt__hheap_chunk *next;$/;"	m	struct:stbtt__hheap_chunk	typeref:struct:stbtt__hheap_chunk::stbtt__hheap_chunk
nodes	vendor/imgui/imstb_truetype.h	/^   void  *nodes;$/;"	m	struct:stbtt_pack_context
nomore	vendor/stb_image/stb_image.h	/^   int            nomore;      \/\/ flag if we saw a marker so must stop$/;"	m	struct:__anon61
normalized	VertexBufferLayout/VertexBufferLayout.h	/^	unsigned char normalized;$/;"	m	struct:VertexBufferLayoutElement
numGlyphs	vendor/imgui/imstb_truetype.h	/^   int numGlyphs;                     \/\/ number of glyphs, needed for range checking$/;"	m	struct:stbtt_fontinfo
num_bits	vendor/stb_image/stb_image.h	/^   int num_bits;$/;"	m	struct:__anon65
num_channels	vendor/stb_image/stb_image.h	/^   int num_channels;$/;"	m	struct:__anon58
num_chars	vendor/imgui/imstb_textedit.h	/^   int num_chars;$/;"	m	struct:__anon51
num_chars	vendor/imgui/imstb_truetype.h	/^   int num_chars;$/;"	m	struct:__anon33
num_nodes	vendor/imgui/imstb_rectpack.h	/^   int num_nodes;$/;"	m	struct:stbrp_context
num_remaining_in_head_chunk	vendor/imgui/imstb_truetype.h	/^   int    num_remaining_in_head_chunk;$/;"	m	struct:stbtt__hheap
num_vertices	vendor/imgui/imstb_truetype.h	/^   int num_vertices;$/;"	m	struct:__anon43
offset	vendor/stb_image/stb_image.h	/^   int bpp, offset, hsz;$/;"	m	struct:__anon69
op_div	vendor/glm/detail/_swizzle.hpp	/^		struct op_div$/;"	s	struct:glm::detail::_swizzle_base2
op_equal	vendor/glm/detail/_swizzle.hpp	/^		struct op_equal$/;"	s	struct:glm::detail::_swizzle_base2
op_minus	vendor/glm/detail/_swizzle.hpp	/^		struct op_minus$/;"	s	struct:glm::detail::_swizzle_base2
op_mul	vendor/glm/detail/_swizzle.hpp	/^		struct op_mul$/;"	s	struct:glm::detail::_swizzle_base2
op_plus	vendor/glm/detail/_swizzle.hpp	/^		struct op_plus$/;"	s	struct:glm::detail::_swizzle_base2
operator ()	vendor/glm/detail/_swizzle.hpp	/^			GLM_FUNC_QUALIFIER void operator() (T& e, T& t) const{ e *= t; }$/;"	f	struct:glm::detail::_swizzle_base2::op_mul
operator ()	vendor/glm/detail/_swizzle.hpp	/^			GLM_FUNC_QUALIFIER void operator() (T& e, T& t) const{ e += t; }$/;"	f	struct:glm::detail::_swizzle_base2::op_plus
operator ()	vendor/glm/detail/_swizzle.hpp	/^			GLM_FUNC_QUALIFIER void operator() (T& e, T& t) const{ e -= t; }$/;"	f	struct:glm::detail::_swizzle_base2::op_minus
operator ()	vendor/glm/detail/_swizzle.hpp	/^			GLM_FUNC_QUALIFIER void operator() (T& e, T& t) const{ e = t; }$/;"	f	struct:glm::detail::_swizzle_base2::op_equal
operator ()	vendor/glm/detail/_swizzle.hpp	/^			GLM_FUNC_QUALIFIER void operator() (T& e, T& t) const{ e \/= t; }$/;"	f	struct:glm::detail::_swizzle_base2::op_div
operator ()	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER vec<2, T, Q> operator ()()  const { return vec<2, T, Q>(this->elem(E0), this->elem(E1)); }$/;"	f	struct:glm::detail::_swizzle_base1
operator ()	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER vec<3, T, Q> operator ()()  const { return vec<3, T, Q>(this->elem(E0), this->elem(E1), this->elem(E2)); }$/;"	f	struct:glm::detail::_swizzle_base1
operator ()	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER vec<4, T, Q> operator ()()  const { return vec<4, T, Q>(this->elem(E0), this->elem(E1), this->elem(E2), this->elem(E3)); }$/;"	f	struct:glm::detail::_swizzle_base1
operator *	vendor/imgui/imgui_internal.h	/^static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x*rhs.x, lhs.y*rhs.y); }$/;"	f
operator *	vendor/imgui/imgui_internal.h	/^static inline ImVec2 operator*(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x*rhs, lhs.y*rhs); }$/;"	f
operator *	vendor/imgui/imgui_internal.h	/^static inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x*rhs.x, lhs.y*rhs.y, lhs.z*rhs.z, lhs.w*rhs.w); }$/;"	f
operator *=	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER void operator *= (vec<N, T, Q> const& that)$/;"	f	struct:glm::detail::_swizzle_base2
operator *=	vendor/imgui/imgui_internal.h	/^static inline ImVec2& operator*=(ImVec2& lhs, const float rhs)                  { lhs.x *= rhs; lhs.y *= rhs; return lhs; }$/;"	f
operator +	vendor/imgui/imgui_internal.h	/^static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x+rhs.x, lhs.y+rhs.y); }$/;"	f
operator +	vendor/imgui/imgui_internal.h	/^static inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x+rhs.x, lhs.y+rhs.y, lhs.z+rhs.z, lhs.w+rhs.w); }$/;"	f
operator +=	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER void operator += (vec<N, T, Q> const& that)$/;"	f	struct:glm::detail::_swizzle_base2
operator +=	vendor/imgui/imgui_internal.h	/^static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }$/;"	f
operator -	vendor/imgui/imgui_internal.h	/^static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x-rhs.x, lhs.y-rhs.y); }$/;"	f
operator -	vendor/imgui/imgui_internal.h	/^static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs)            { return ImVec4(lhs.x-rhs.x, lhs.y-rhs.y, lhs.z-rhs.z, lhs.w-rhs.w); }$/;"	f
operator -=	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER void operator -= (vec<N, T, Q> const& that)$/;"	f	struct:glm::detail::_swizzle_base2
operator -=	vendor/imgui/imgui_internal.h	/^static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs)                { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }$/;"	f
operator /	vendor/imgui/imgui_internal.h	/^static inline ImVec2 operator\/(const ImVec2& lhs, const ImVec2& rhs)            { return ImVec2(lhs.x\/rhs.x, lhs.y\/rhs.y); }$/;"	f
operator /	vendor/imgui/imgui_internal.h	/^static inline ImVec2 operator\/(const ImVec2& lhs, const float rhs)              { return ImVec2(lhs.x\/rhs, lhs.y\/rhs); }$/;"	f
operator /=	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER void operator \/= (vec<N, T, Q> const& that)$/;"	f	struct:glm::detail::_swizzle_base2
operator /=	vendor/imgui/imgui_internal.h	/^static inline ImVec2& operator\/=(ImVec2& lhs, const float rhs)                  { lhs.x \/= rhs; lhs.y \/= rhs; return lhs; }$/;"	f
operator =	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER _swizzle_base2& operator= (Stub const&) { return *this; }$/;"	f	struct:glm::detail::_swizzle_base2
operator =	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER _swizzle_base2& operator= (const T& t)$/;"	f	struct:glm::detail::_swizzle_base2
operator =	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER _swizzle_base2& operator= (vec<N, T, Q> const& that)$/;"	f	struct:glm::detail::_swizzle_base2
operator =	vendor/glm/detail/type_float.hpp	/^		GLM_CONSTEXPR float_t& operator=(float_t const& x)$/;"	f	union:glm::detail::float_t
operator =	vendor/imgui/imgui.h	/^    inline ImVector<T>& operator=(const ImVector<T>& src)   { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(T)); return *this; }$/;"	f	struct:ImVector
operator ImU32	vendor/imgui/imgui.h	/^    inline operator ImU32() const                                   { return ImGui::ColorConvertFloat4ToU32(Value); }$/;"	f	struct:ImColor
operator ImVec4	vendor/imgui/imgui.h	/^    inline operator ImVec4() const                                  { return Value; }$/;"	f	struct:ImColor
operator []	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER T operator[]  (size_t i) const$/;"	f	struct:glm::detail::_swizzle_base2
operator []	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER T operator[](size_t i) const$/;"	f	struct:glm::detail::_swizzle_base2
operator []	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER T& operator[](size_t i)$/;"	f	struct:glm::detail::_swizzle_base2
operator []	vendor/imgui/imgui.h	/^    float  operator[] (size_t idx) const { IM_ASSERT(idx <= 1); return (&x)[idx]; }    \/\/ We very rarely use this [] operator, the assert overhead is fine.$/;"	f	struct:ImVec2
operator []	vendor/imgui/imgui.h	/^    float& operator[] (size_t idx)       { IM_ASSERT(idx <= 1); return (&x)[idx]; }    \/\/ We very rarely use this [] operator, the assert overhead is fine.$/;"	f	struct:ImVec2
operator []	vendor/imgui/imgui.h	/^    inline T&           operator[](int i)                   { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	struct:ImVector
operator []	vendor/imgui/imgui.h	/^    inline char         operator[](int i)       { IM_ASSERT(Buf.Data != NULL); return Buf.Data[i]; }$/;"	f	struct:ImGuiTextBuffer
operator []	vendor/imgui/imgui.h	/^    inline const T&     operator[](int i) const             { IM_ASSERT(i < Size); return Data[i]; }$/;"	f	struct:ImVector
operator bool	vendor/imgui/imgui.h	/^    operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }$/;"	f	struct:ImGuiOnceUponAFrame
operator delete	vendor/imgui/imgui.h	/^inline void  operator delete(void*, ImNewDummy, void*)   {} \/\/ This is only required so we can use the symmetrical new()$/;"	f
operator new	vendor/imgui/imgui.h	/^inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }$/;"	f
operator vec<N, T, Q>	vendor/glm/detail/_swizzle.hpp	/^		GLM_FUNC_QUALIFIER operator vec<N, T, Q> () const { return (*this)(); }$/;"	f	struct:glm::detail::_swizzle
order	vendor/glm/gtx/io.hpp	/^			order_type order;$/;"	m	class:glm::io::format_punct
order	vendor/glm/gtx/io.hpp	/^		struct order$/;"	s	namespace:glm::io
order	vendor/stb_image/stb_image.h	/^   int scan_n, order[4];$/;"	m	struct:__anon61
order_type	vendor/glm/gtx/io.hpp	/^		enum order_type { column_major, row_major};$/;"	g	namespace:glm::io
out	vendor/stb_image/stb_image.h	/^   stbi_uc *idata, *expanded, *out;$/;"	m	struct:__anon67
out	vendor/stb_image/stb_image.h	/^   stbi_uc *out;                 \/\/ output buffer (always 4 components)$/;"	m	struct:__anon72
outerProduct_trait	vendor/glm/matrix.hpp	/^	struct outerProduct_trait<2, 2, T, Q>$/;"	s	namespace:glm::detail
outerProduct_trait	vendor/glm/matrix.hpp	/^	struct outerProduct_trait<2, 3, T, Q>$/;"	s	namespace:glm::detail
outerProduct_trait	vendor/glm/matrix.hpp	/^	struct outerProduct_trait<2, 4, T, Q>$/;"	s	namespace:glm::detail
outerProduct_trait	vendor/glm/matrix.hpp	/^	struct outerProduct_trait<3, 2, T, Q>$/;"	s	namespace:glm::detail
outerProduct_trait	vendor/glm/matrix.hpp	/^	struct outerProduct_trait<3, 3, T, Q>$/;"	s	namespace:glm::detail
outerProduct_trait	vendor/glm/matrix.hpp	/^	struct outerProduct_trait<3, 4, T, Q>$/;"	s	namespace:glm::detail
outerProduct_trait	vendor/glm/matrix.hpp	/^	struct outerProduct_trait<4, 2, T, Q>$/;"	s	namespace:glm::detail
outerProduct_trait	vendor/glm/matrix.hpp	/^	struct outerProduct_trait<4, 3, T, Q>$/;"	s	namespace:glm::detail
outerProduct_trait	vendor/glm/matrix.hpp	/^	struct outerProduct_trait<4, 4, T, Q>$/;"	s	namespace:glm::detail
outerProduct_trait	vendor/glm/matrix.hpp	/^	struct outerProduct_trait{};$/;"	s	namespace:glm::detail
p	vendor/glm/detail/type_vec3.hpp	/^				struct{ T s, t, p; };$/;"	m	struct:glm::vec::__anon3::__anon6
p	vendor/glm/detail/type_vec3.hpp	/^			union { T z, b, p; };$/;"	m	union:glm::vec::__anon9
p	vendor/glm/detail/type_vec4.hpp	/^				struct { T s, t, p, q; };$/;"	m	struct:glm::vec::__anon18::__anon21
p	vendor/glm/detail/type_vec4.hpp	/^			union { T z, b, p; };$/;"	m	union:glm::vec::__anon24
pack_info	vendor/imgui/imstb_truetype.h	/^   void *pack_info;$/;"	m	struct:stbtt_pack_context
packed	vendor/glm/detail/qualifier.hpp	/^		packed = packed_highp, \/\/\/< By default packed qualifier is also high precision$/;"	e	enum:glm::qualifier
packed_bvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_bvec1			packed_bvec1;$/;"	t	namespace:glm
packed_bvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_bvec2			packed_bvec2;$/;"	t	namespace:glm
packed_bvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_bvec3			packed_bvec3;$/;"	t	namespace:glm
packed_bvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_bvec4			packed_bvec4;$/;"	t	namespace:glm
packed_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat2			packed_dmat2;$/;"	t	namespace:glm
packed_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat2			packed_dmat2;$/;"	t	namespace:glm
packed_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat2		packed_dmat2;$/;"	t	namespace:glm
packed_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat2x2		packed_dmat2x2;$/;"	t	namespace:glm
packed_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat2x2			packed_dmat2x2;$/;"	t	namespace:glm
packed_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat2x2		packed_dmat2x2;$/;"	t	namespace:glm
packed_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat2x3		packed_dmat2x3;$/;"	t	namespace:glm
packed_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat2x3			packed_dmat2x3;$/;"	t	namespace:glm
packed_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat2x3		packed_dmat2x3;$/;"	t	namespace:glm
packed_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat2x4		packed_dmat2x4;$/;"	t	namespace:glm
packed_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat2x4			packed_dmat2x4;$/;"	t	namespace:glm
packed_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat2x4		packed_dmat2x4;$/;"	t	namespace:glm
packed_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat3			packed_dmat3;$/;"	t	namespace:glm
packed_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat3			packed_dmat3;$/;"	t	namespace:glm
packed_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat3		packed_dmat3;$/;"	t	namespace:glm
packed_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat3x2		packed_dmat3x2;$/;"	t	namespace:glm
packed_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat3x2			packed_dmat3x2;$/;"	t	namespace:glm
packed_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat3x2		packed_dmat3x2;$/;"	t	namespace:glm
packed_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat3x3		packed_dmat3x3;$/;"	t	namespace:glm
packed_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat3x3			packed_dmat3x3;$/;"	t	namespace:glm
packed_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat3x3		packed_dmat3x3;$/;"	t	namespace:glm
packed_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat3x4		packed_dmat3x4;$/;"	t	namespace:glm
packed_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat3x4			packed_dmat3x4;$/;"	t	namespace:glm
packed_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat3x4		packed_dmat3x4;$/;"	t	namespace:glm
packed_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat4			packed_dmat4;$/;"	t	namespace:glm
packed_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat4			packed_dmat4;$/;"	t	namespace:glm
packed_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat4		packed_dmat4;$/;"	t	namespace:glm
packed_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat4x2		packed_dmat4x2;$/;"	t	namespace:glm
packed_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat4x2			packed_dmat4x2;$/;"	t	namespace:glm
packed_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat4x2		packed_dmat4x2;$/;"	t	namespace:glm
packed_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat4x3		packed_dmat4x3;$/;"	t	namespace:glm
packed_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat4x3			packed_dmat4x3;$/;"	t	namespace:glm
packed_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat4x3		packed_dmat4x3;$/;"	t	namespace:glm
packed_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dmat4x4		packed_dmat4x4;$/;"	t	namespace:glm
packed_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dmat4x4			packed_dmat4x4;$/;"	t	namespace:glm
packed_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dmat4x4		packed_dmat4x4;$/;"	t	namespace:glm
packed_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dvec1			packed_dvec1;$/;"	t	namespace:glm
packed_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dvec1			packed_dvec1;$/;"	t	namespace:glm
packed_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dvec1		packed_dvec1;$/;"	t	namespace:glm
packed_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dvec2			packed_dvec2;$/;"	t	namespace:glm
packed_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dvec2			packed_dvec2;$/;"	t	namespace:glm
packed_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dvec2		packed_dvec2;$/;"	t	namespace:glm
packed_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dvec3			packed_dvec3;$/;"	t	namespace:glm
packed_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dvec3			packed_dvec3;$/;"	t	namespace:glm
packed_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dvec3		packed_dvec3;$/;"	t	namespace:glm
packed_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_dvec4			packed_dvec4;$/;"	t	namespace:glm
packed_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_dvec4			packed_dvec4;$/;"	t	namespace:glm
packed_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_dvec4		packed_dvec4;$/;"	t	namespace:glm
packed_highp	vendor/glm/detail/qualifier.hpp	/^		packed_highp, \/\/\/< Typed data is tightly packed in memory and operations are executed with high precision in term of ULPs$/;"	e	enum:glm::qualifier
packed_highp_bvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, bool, packed_highp>		packed_highp_bvec1;$/;"	t	namespace:glm
packed_highp_bvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, bool, packed_highp>		packed_highp_bvec2;$/;"	t	namespace:glm
packed_highp_bvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, bool, packed_highp>		packed_highp_bvec3;$/;"	t	namespace:glm
packed_highp_bvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, bool, packed_highp>		packed_highp_bvec4;$/;"	t	namespace:glm
packed_highp_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, packed_highp>		packed_highp_dmat2;$/;"	t	namespace:glm
packed_highp_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, packed_highp>		packed_highp_dmat2x2;$/;"	t	namespace:glm
packed_highp_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, double, packed_highp>		packed_highp_dmat2x3;$/;"	t	namespace:glm
packed_highp_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, double, packed_highp>		packed_highp_dmat2x4;$/;"	t	namespace:glm
packed_highp_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, packed_highp>		packed_highp_dmat3;$/;"	t	namespace:glm
packed_highp_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, double, packed_highp>		packed_highp_dmat3x2;$/;"	t	namespace:glm
packed_highp_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, packed_highp>		packed_highp_dmat3x3;$/;"	t	namespace:glm
packed_highp_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, double, packed_highp>		packed_highp_dmat3x4;$/;"	t	namespace:glm
packed_highp_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, packed_highp>		packed_highp_dmat4;$/;"	t	namespace:glm
packed_highp_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, double, packed_highp>		packed_highp_dmat4x2;$/;"	t	namespace:glm
packed_highp_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, double, packed_highp>		packed_highp_dmat4x3;$/;"	t	namespace:glm
packed_highp_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, packed_highp>		packed_highp_dmat4x4;$/;"	t	namespace:glm
packed_highp_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, double, packed_highp>	packed_highp_dvec1;$/;"	t	namespace:glm
packed_highp_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, double, packed_highp>	packed_highp_dvec2;$/;"	t	namespace:glm
packed_highp_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, double, packed_highp>	packed_highp_dvec3;$/;"	t	namespace:glm
packed_highp_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, double, packed_highp>	packed_highp_dvec4;$/;"	t	namespace:glm
packed_highp_ivec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, int, packed_highp>		packed_highp_ivec1;$/;"	t	namespace:glm
packed_highp_ivec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, int, packed_highp>		packed_highp_ivec2;$/;"	t	namespace:glm
packed_highp_ivec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, int, packed_highp>		packed_highp_ivec3;$/;"	t	namespace:glm
packed_highp_ivec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, int, packed_highp>		packed_highp_ivec4;$/;"	t	namespace:glm
packed_highp_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, packed_highp>		packed_highp_mat2;$/;"	t	namespace:glm
packed_highp_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, packed_highp>		packed_highp_mat2x2;$/;"	t	namespace:glm
packed_highp_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, float, packed_highp>		packed_highp_mat2x3;$/;"	t	namespace:glm
packed_highp_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, float, packed_highp>		packed_highp_mat2x4;$/;"	t	namespace:glm
packed_highp_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, packed_highp>		packed_highp_mat3;$/;"	t	namespace:glm
packed_highp_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, float, packed_highp>		packed_highp_mat3x2;$/;"	t	namespace:glm
packed_highp_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, packed_highp>		packed_highp_mat3x3;$/;"	t	namespace:glm
packed_highp_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, float, packed_highp>		packed_highp_mat3x4;$/;"	t	namespace:glm
packed_highp_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, packed_highp>		packed_highp_mat4;$/;"	t	namespace:glm
packed_highp_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, float, packed_highp>		packed_highp_mat4x2;$/;"	t	namespace:glm
packed_highp_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, float, packed_highp>		packed_highp_mat4x3;$/;"	t	namespace:glm
packed_highp_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, packed_highp>		packed_highp_mat4x4;$/;"	t	namespace:glm
packed_highp_uvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, uint, packed_highp>		packed_highp_uvec1;$/;"	t	namespace:glm
packed_highp_uvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, uint, packed_highp>		packed_highp_uvec2;$/;"	t	namespace:glm
packed_highp_uvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, uint, packed_highp>		packed_highp_uvec3;$/;"	t	namespace:glm
packed_highp_uvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, uint, packed_highp>		packed_highp_uvec4;$/;"	t	namespace:glm
packed_highp_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, float, packed_highp>		packed_highp_vec1;$/;"	t	namespace:glm
packed_highp_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, float, packed_highp>		packed_highp_vec2;$/;"	t	namespace:glm
packed_highp_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, float, packed_highp>		packed_highp_vec3;$/;"	t	namespace:glm
packed_highp_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, float, packed_highp>		packed_highp_vec4;$/;"	t	namespace:glm
packed_ivec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_ivec1			packed_ivec1;$/;"	t	namespace:glm
packed_ivec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_ivec2			packed_ivec2;$/;"	t	namespace:glm
packed_ivec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_ivec3			packed_ivec3;$/;"	t	namespace:glm
packed_ivec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_ivec4			packed_ivec4;$/;"	t	namespace:glm
packed_lowp	vendor/glm/detail/qualifier.hpp	/^		packed_lowp, \/\/\/< Typed data is tightly packed in memory  and operations are executed with low precision in term of ULPs to maximize performance$/;"	e	enum:glm::qualifier
packed_lowp_bvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, bool, packed_lowp>		packed_lowp_bvec1;$/;"	t	namespace:glm
packed_lowp_bvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, bool, packed_lowp>		packed_lowp_bvec2;$/;"	t	namespace:glm
packed_lowp_bvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, bool, packed_lowp>		packed_lowp_bvec3;$/;"	t	namespace:glm
packed_lowp_bvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, bool, packed_lowp>		packed_lowp_bvec4;$/;"	t	namespace:glm
packed_lowp_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, packed_lowp>		packed_lowp_dmat2;$/;"	t	namespace:glm
packed_lowp_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, packed_lowp>		packed_lowp_dmat2x2;$/;"	t	namespace:glm
packed_lowp_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, double, packed_lowp>		packed_lowp_dmat2x3;$/;"	t	namespace:glm
packed_lowp_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, double, packed_lowp>		packed_lowp_dmat2x4;$/;"	t	namespace:glm
packed_lowp_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, packed_lowp>		packed_lowp_dmat3;$/;"	t	namespace:glm
packed_lowp_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, double, packed_lowp>		packed_lowp_dmat3x2;$/;"	t	namespace:glm
packed_lowp_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, packed_lowp>		packed_lowp_dmat3x3;$/;"	t	namespace:glm
packed_lowp_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, double, packed_lowp>		packed_lowp_dmat3x4;$/;"	t	namespace:glm
packed_lowp_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, packed_lowp>		packed_lowp_dmat4;$/;"	t	namespace:glm
packed_lowp_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, double, packed_lowp>		packed_lowp_dmat4x2;$/;"	t	namespace:glm
packed_lowp_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, double, packed_lowp>		packed_lowp_dmat4x3;$/;"	t	namespace:glm
packed_lowp_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, packed_lowp>		packed_lowp_dmat4x4;$/;"	t	namespace:glm
packed_lowp_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, double, packed_lowp>		packed_lowp_dvec1;$/;"	t	namespace:glm
packed_lowp_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, double, packed_lowp>		packed_lowp_dvec2;$/;"	t	namespace:glm
packed_lowp_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, double, packed_lowp>		packed_lowp_dvec3;$/;"	t	namespace:glm
packed_lowp_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, double, packed_lowp>		packed_lowp_dvec4;$/;"	t	namespace:glm
packed_lowp_ivec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, int, packed_lowp>		packed_lowp_ivec1;$/;"	t	namespace:glm
packed_lowp_ivec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, int, packed_lowp>		packed_lowp_ivec2;$/;"	t	namespace:glm
packed_lowp_ivec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, int, packed_lowp>		packed_lowp_ivec3;$/;"	t	namespace:glm
packed_lowp_ivec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, int, packed_lowp>		packed_lowp_ivec4;$/;"	t	namespace:glm
packed_lowp_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, packed_lowp>		packed_lowp_mat2;$/;"	t	namespace:glm
packed_lowp_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, packed_lowp>		packed_lowp_mat2x2;$/;"	t	namespace:glm
packed_lowp_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, float, packed_lowp>		packed_lowp_mat2x3;$/;"	t	namespace:glm
packed_lowp_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, float, packed_lowp>		packed_lowp_mat2x4;$/;"	t	namespace:glm
packed_lowp_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, packed_lowp>		packed_lowp_mat3;$/;"	t	namespace:glm
packed_lowp_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, float, packed_lowp>		packed_lowp_mat3x2;$/;"	t	namespace:glm
packed_lowp_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, packed_lowp>		packed_lowp_mat3x3;$/;"	t	namespace:glm
packed_lowp_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, float, packed_lowp>		packed_lowp_mat3x4;$/;"	t	namespace:glm
packed_lowp_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, packed_lowp>		packed_lowp_mat4;$/;"	t	namespace:glm
packed_lowp_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, float, packed_lowp>		packed_lowp_mat4x2;$/;"	t	namespace:glm
packed_lowp_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, float, packed_lowp>		packed_lowp_mat4x3;$/;"	t	namespace:glm
packed_lowp_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, packed_lowp>		packed_lowp_mat4x4;$/;"	t	namespace:glm
packed_lowp_uvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, uint, packed_lowp>		packed_lowp_uvec1;$/;"	t	namespace:glm
packed_lowp_uvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, uint, packed_lowp>		packed_lowp_uvec2;$/;"	t	namespace:glm
packed_lowp_uvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, uint, packed_lowp>		packed_lowp_uvec3;$/;"	t	namespace:glm
packed_lowp_uvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, uint, packed_lowp>		packed_lowp_uvec4;$/;"	t	namespace:glm
packed_lowp_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, float, packed_lowp>		packed_lowp_vec1;$/;"	t	namespace:glm
packed_lowp_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, float, packed_lowp>		packed_lowp_vec2;$/;"	t	namespace:glm
packed_lowp_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, float, packed_lowp>		packed_lowp_vec3;$/;"	t	namespace:glm
packed_lowp_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, float, packed_lowp>		packed_lowp_vec4;$/;"	t	namespace:glm
packed_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat2			packed_mat2;$/;"	t	namespace:glm
packed_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat2			packed_mat2;$/;"	t	namespace:glm
packed_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat2			packed_mat2;$/;"	t	namespace:glm
packed_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat2x2			packed_mat2x2;$/;"	t	namespace:glm
packed_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat2x2			packed_mat2x2;$/;"	t	namespace:glm
packed_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat2x2		packed_mat2x2;$/;"	t	namespace:glm
packed_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat2x3			packed_mat2x3;$/;"	t	namespace:glm
packed_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat2x3			packed_mat2x3;$/;"	t	namespace:glm
packed_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat2x3		packed_mat2x3;$/;"	t	namespace:glm
packed_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat2x4			packed_mat2x4;$/;"	t	namespace:glm
packed_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat2x4			packed_mat2x4;$/;"	t	namespace:glm
packed_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat2x4		packed_mat2x4;$/;"	t	namespace:glm
packed_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat3			packed_mat3;$/;"	t	namespace:glm
packed_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat3			packed_mat3;$/;"	t	namespace:glm
packed_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat3			packed_mat3;$/;"	t	namespace:glm
packed_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat3x2			packed_mat3x2;$/;"	t	namespace:glm
packed_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat3x2			packed_mat3x2;$/;"	t	namespace:glm
packed_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat3x2		packed_mat3x2;$/;"	t	namespace:glm
packed_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat3x3			packed_mat3x3;$/;"	t	namespace:glm
packed_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat3x3			packed_mat3x3;$/;"	t	namespace:glm
packed_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat3x3		packed_mat3x3;$/;"	t	namespace:glm
packed_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat3x4			packed_mat3x4;$/;"	t	namespace:glm
packed_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat3x4			packed_mat3x4;$/;"	t	namespace:glm
packed_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat3x4		packed_mat3x4;$/;"	t	namespace:glm
packed_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat4			packed_mat4;$/;"	t	namespace:glm
packed_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat4			packed_mat4;$/;"	t	namespace:glm
packed_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat4			packed_mat4;$/;"	t	namespace:glm
packed_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat4x2			packed_mat4x2;$/;"	t	namespace:glm
packed_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat4x2			packed_mat4x2;$/;"	t	namespace:glm
packed_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat4x2		packed_mat4x2;$/;"	t	namespace:glm
packed_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat4x3			packed_mat4x3;$/;"	t	namespace:glm
packed_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat4x3			packed_mat4x3;$/;"	t	namespace:glm
packed_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat4x3		packed_mat4x3;$/;"	t	namespace:glm
packed_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_mat4x4			packed_mat4x4;$/;"	t	namespace:glm
packed_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_mat4x4			packed_mat4x4;$/;"	t	namespace:glm
packed_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_mat4x4		packed_mat4x4;$/;"	t	namespace:glm
packed_mediump	vendor/glm/detail/qualifier.hpp	/^		packed_mediump, \/\/\/< Typed data is tightly packed in memory  and operations are executed with medium precision in term of ULPs for higher performance$/;"	e	enum:glm::qualifier
packed_mediump_bvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, bool, packed_mediump>	packed_mediump_bvec1;$/;"	t	namespace:glm
packed_mediump_bvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, bool, packed_mediump>	packed_mediump_bvec2;$/;"	t	namespace:glm
packed_mediump_bvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, bool, packed_mediump>	packed_mediump_bvec3;$/;"	t	namespace:glm
packed_mediump_bvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, bool, packed_mediump>	packed_mediump_bvec4;$/;"	t	namespace:glm
packed_mediump_dmat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, packed_mediump>	packed_mediump_dmat2;$/;"	t	namespace:glm
packed_mediump_dmat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, double, packed_mediump>	packed_mediump_dmat2x2;$/;"	t	namespace:glm
packed_mediump_dmat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, double, packed_mediump>	packed_mediump_dmat2x3;$/;"	t	namespace:glm
packed_mediump_dmat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, double, packed_mediump>	packed_mediump_dmat2x4;$/;"	t	namespace:glm
packed_mediump_dmat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, packed_mediump>	packed_mediump_dmat3;$/;"	t	namespace:glm
packed_mediump_dmat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, double, packed_mediump>	packed_mediump_dmat3x2;$/;"	t	namespace:glm
packed_mediump_dmat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, double, packed_mediump>	packed_mediump_dmat3x3;$/;"	t	namespace:glm
packed_mediump_dmat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, double, packed_mediump>	packed_mediump_dmat3x4;$/;"	t	namespace:glm
packed_mediump_dmat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, packed_mediump>	packed_mediump_dmat4;$/;"	t	namespace:glm
packed_mediump_dmat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, double, packed_mediump>	packed_mediump_dmat4x2;$/;"	t	namespace:glm
packed_mediump_dmat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, double, packed_mediump>	packed_mediump_dmat4x3;$/;"	t	namespace:glm
packed_mediump_dmat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, double, packed_mediump>	packed_mediump_dmat4x4;$/;"	t	namespace:glm
packed_mediump_dvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, double, packed_mediump>	packed_mediump_dvec1;$/;"	t	namespace:glm
packed_mediump_dvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, double, packed_mediump>	packed_mediump_dvec2;$/;"	t	namespace:glm
packed_mediump_dvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, double, packed_mediump>	packed_mediump_dvec3;$/;"	t	namespace:glm
packed_mediump_dvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, double, packed_mediump>	packed_mediump_dvec4;$/;"	t	namespace:glm
packed_mediump_ivec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, int, packed_mediump>		packed_mediump_ivec1;$/;"	t	namespace:glm
packed_mediump_ivec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, int, packed_mediump>		packed_mediump_ivec2;$/;"	t	namespace:glm
packed_mediump_ivec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, int, packed_mediump>		packed_mediump_ivec3;$/;"	t	namespace:glm
packed_mediump_ivec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, int, packed_mediump>		packed_mediump_ivec4;$/;"	t	namespace:glm
packed_mediump_mat2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, packed_mediump>	packed_mediump_mat2;$/;"	t	namespace:glm
packed_mediump_mat2x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 2, float, packed_mediump>	packed_mediump_mat2x2;$/;"	t	namespace:glm
packed_mediump_mat2x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 3, float, packed_mediump>	packed_mediump_mat2x3;$/;"	t	namespace:glm
packed_mediump_mat2x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<2, 4, float, packed_mediump>	packed_mediump_mat2x4;$/;"	t	namespace:glm
packed_mediump_mat3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, packed_mediump>	packed_mediump_mat3;$/;"	t	namespace:glm
packed_mediump_mat3x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 2, float, packed_mediump>	packed_mediump_mat3x2;$/;"	t	namespace:glm
packed_mediump_mat3x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 3, float, packed_mediump>	packed_mediump_mat3x3;$/;"	t	namespace:glm
packed_mediump_mat3x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<3, 4, float, packed_mediump>	packed_mediump_mat3x4;$/;"	t	namespace:glm
packed_mediump_mat4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, packed_mediump>	packed_mediump_mat4;$/;"	t	namespace:glm
packed_mediump_mat4x2	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 2, float, packed_mediump>	packed_mediump_mat4x2;$/;"	t	namespace:glm
packed_mediump_mat4x3	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 3, float, packed_mediump>	packed_mediump_mat4x3;$/;"	t	namespace:glm
packed_mediump_mat4x4	vendor/glm/gtc/type_aligned.hpp	/^	typedef mat<4, 4, float, packed_mediump>	packed_mediump_mat4x4;$/;"	t	namespace:glm
packed_mediump_uvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, uint, packed_mediump>	packed_mediump_uvec1;$/;"	t	namespace:glm
packed_mediump_uvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, uint, packed_mediump>	packed_mediump_uvec2;$/;"	t	namespace:glm
packed_mediump_uvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, uint, packed_mediump>	packed_mediump_uvec3;$/;"	t	namespace:glm
packed_mediump_uvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, uint, packed_mediump>	packed_mediump_uvec4;$/;"	t	namespace:glm
packed_mediump_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<1, float, packed_mediump>	packed_mediump_vec1;$/;"	t	namespace:glm
packed_mediump_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<2, float, packed_mediump>	packed_mediump_vec2;$/;"	t	namespace:glm
packed_mediump_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<3, float, packed_mediump>	packed_mediump_vec3;$/;"	t	namespace:glm
packed_mediump_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef vec<4, float, packed_mediump>	packed_mediump_vec4;$/;"	t	namespace:glm
packed_uvec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_uvec1			packed_uvec1;$/;"	t	namespace:glm
packed_uvec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_uvec2			packed_uvec2;$/;"	t	namespace:glm
packed_uvec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_uvec3			packed_uvec3;$/;"	t	namespace:glm
packed_uvec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_uvec4			packed_uvec4;$/;"	t	namespace:glm
packed_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_vec1			packed_vec1;$/;"	t	namespace:glm
packed_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_vec1			packed_vec1;$/;"	t	namespace:glm
packed_vec1	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_vec1			packed_vec1;$/;"	t	namespace:glm
packed_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_vec2			packed_vec2;$/;"	t	namespace:glm
packed_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_vec2			packed_vec2;$/;"	t	namespace:glm
packed_vec2	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_vec2			packed_vec2;$/;"	t	namespace:glm
packed_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_vec3			packed_vec3;$/;"	t	namespace:glm
packed_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_vec3			packed_vec3;$/;"	t	namespace:glm
packed_vec3	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_vec3			packed_vec3;$/;"	t	namespace:glm
packed_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_highp_vec4			packed_vec4;$/;"	t	namespace:glm
packed_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_lowp_vec4			packed_vec4;$/;"	t	namespace:glm
packed_vec4	vendor/glm/gtc/type_aligned.hpp	/^	typedef packed_mediump_vec4			packed_vec4;$/;"	t	namespace:glm
padding	vendor/imgui/imstb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon35
padding	vendor/imgui/imstb_truetype.h	/^   int   padding;$/;"	m	struct:stbtt_pack_context
padding1	vendor/imgui/imstb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon50
padding2	vendor/imgui/imstb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon50
padding3	vendor/imgui/imstb_textedit.h	/^   unsigned char padding1, padding2, padding3;$/;"	m	struct:__anon50
pal	vendor/stb_image/stb_image.h	/^   stbi_uc  pal[256][4];$/;"	m	struct:__anon72
parse	vendor/stb_image/stb_image.h	/^   int parse, step;$/;"	m	struct:__anon72
part_type	vendor/glm/gtx/dual_quaternion.hpp	/^		typedef qua<T, Q> part_type;$/;"	t	struct:glm::tdualquat
permute	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER T permute(T const& x)$/;"	f	namespace:glm::detail
permute	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER vec<2, T, Q> permute(vec<2, T, Q> const& x)$/;"	f	namespace:glm::detail
permute	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER vec<3, T, Q> permute(vec<3, T, Q> const& x)$/;"	f	namespace:glm::detail
permute	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER vec<4, T, Q> permute(vec<4, T, Q> const& x)$/;"	f	namespace:glm::detail
pixels	vendor/imgui/imstb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:__anon36
pixels	vendor/imgui/imstb_truetype.h	/^   unsigned char *pixels;$/;"	m	struct:stbtt_pack_context
pop_back	vendor/imgui/imgui.h	/^    inline void         pop_back()                          { IM_ASSERT(Size > 0); Size--; }$/;"	f	struct:ImVector
pos	vendor/imgui/imgui.h	/^    ImVec2  pos;$/;"	m	struct:ImDrawVert
precision	vendor/glm/detail/qualifier.hpp	/^	typedef qualifier precision;$/;"	t	namespace:glm
precision	vendor/glm/gtx/io.hpp	/^			unsigned   precision;$/;"	m	class:glm::io::format_punct
precision	vendor/glm/gtx/io.hpp	/^		struct precision$/;"	s	namespace:glm::io
precision_	vendor/glm/gtx/io.hpp	/^			streamsize_type precision_;$/;"	m	class:glm::io::basic_state_saver
preferred_x	vendor/imgui/imstb_textedit.h	/^   float preferred_x; \/\/ this determines where the cursor up\/down tries to seek to along x$/;"	m	struct:__anon50
prefix	vendor/stb_image/stb_image.h	/^   stbi__int16 prefix;$/;"	m	struct:__anon71
prev_first	vendor/imgui/imstb_textedit.h	/^   int prev_first;  \/\/ first char of previous row$/;"	m	struct:__anon52
prev_link	vendor/imgui/imstb_rectpack.h	/^   stbrp_node **prev_link;$/;"	m	struct:__anon28
proggy_clean_ttf_compressed_data_base85	vendor/imgui/imgui_draw.cpp	/^static const char proggy_clean_ttf_compressed_data_base85[11980+1] =$/;"	v	file:
progressive	vendor/stb_image/stb_image.h	/^   int            progressive;$/;"	m	struct:__anon61
push_back	vendor/imgui/imgui.h	/^    inline void         push_back(const T& v)               { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }$/;"	f	struct:ImVector
push_front	vendor/imgui/imgui.h	/^    inline void         push_front(const T& v)              { if (Size == 0) push_back(v); else insert(Data, v); }$/;"	f	struct:ImVector
pvertices	vendor/imgui/imstb_truetype.h	/^   stbtt_vertex *pvertices;$/;"	m	struct:__anon43
q	vendor/glm/detail/type_vec4.hpp	/^				struct { T s, t, p, q; };$/;"	m	struct:glm::vec::__anon18::__anon21
q	vendor/glm/detail/type_vec4.hpp	/^			union { T w, a, q; };$/;"	m	union:glm::vec::__anon25
qua	vendor/glm/detail/type_quat.hpp	/^	struct qua$/;"	s	namespace:glm
qualifier	vendor/glm/detail/qualifier.hpp	/^	enum qualifier$/;"	g	namespace:glm
quat	vendor/glm/ext/quaternion_float.hpp	/^	typedef qua<float, defaultp>		quat;$/;"	t	namespace:glm
quat	vendor/glm/fwd.hpp	/^	typedef qua<float, defaultp>		quat;$/;"	t	namespace:glm
qword	vendor/glm/gtx/raw_data.hpp	/^	typedef detail::uint64		qword;$/;"	t	namespace:glm
r	vendor/glm/detail/type_vec1.hpp	/^				T r;$/;"	m	union:glm::vec::__anon1
r	vendor/glm/detail/type_vec1.hpp	/^			union {T x, r, s;};$/;"	m	union:glm::vec::__anon2
r	vendor/glm/detail/type_vec2.hpp	/^				struct{ T r, g; };$/;"	m	struct:glm::vec::__anon10::__anon12
r	vendor/glm/detail/type_vec2.hpp	/^			union {T x, r, s;};$/;"	m	union:glm::vec::__anon14
r	vendor/glm/detail/type_vec3.hpp	/^				struct{ T r, g, b; };$/;"	m	struct:glm::vec::__anon3::__anon5
r	vendor/glm/detail/type_vec3.hpp	/^			union { T x, r, s; };$/;"	m	union:glm::vec::__anon7
r	vendor/glm/detail/type_vec4.hpp	/^				struct { T r, g, b, a; };$/;"	m	struct:glm::vec::__anon18::__anon20
r	vendor/glm/detail/type_vec4.hpp	/^			union { T x, r, s; };$/;"	m	union:glm::vec::__anon22
ratio	vendor/stb_image/stb_image.h	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:__anon72
raw_coeff	vendor/stb_image/stb_image.h	/^      void *raw_data, *raw_coeff;$/;"	m	struct:__anon61::__anon62
raw_data	vendor/stb_image/stb_image.h	/^      void *raw_data, *raw_coeff;$/;"	m	struct:__anon61::__anon62
read	vendor/stb_image/stb_image.h	/^   int      (*read)  (void *user,char *data,int size);   \/\/ fill 'data' with 'size' bytes.  return number of bytes actually read$/;"	m	struct:__anon55
read_from_callbacks	vendor/stb_image/stb_image.h	/^   int read_from_callbacks;$/;"	m	struct:__anon56
real	vendor/glm/gtx/dual_quaternion.hpp	/^		qua<T, Q> real, dual;$/;"	m	struct:glm::tdualquat
rect_height_compare	vendor/imgui/imstb_rectpack.h	/^static int STBRP__CDECL rect_height_compare(const void *a, const void *b)$/;"	f
rect_original_order	vendor/imgui/imstb_rectpack.h	/^static int STBRP__CDECL rect_original_order(const void *a, const void *b)$/;"	f
redo_char_point	vendor/imgui/imstb_textedit.h	/^   int undo_char_point, redo_char_point;$/;"	m	struct:__anon49
redo_point	vendor/imgui/imstb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon49
rendererID	IndexBuffer/IndexBuffer.h	/^	unsigned int rendererID;$/;"	m	class:IndexBuffer
rendererID	VertexBuffer/VertexBuffer.h	/^	unsigned int rendererID;$/;"	m	class:VertexBuffer
rendererId	Shader/Shader.h	/^	unsigned int rendererId;$/;"	m	class:Shader
rendererId	Texture/Texture.h	/^	unsigned int 	rendererId;$/;"	m	class:Texture
rendererId	VertexArray/VertexArray.h	/^		unsigned int rendererId;$/;"	m	class:VertexArray
resample	vendor/stb_image/stb_image.h	/^   resample_row_func resample;$/;"	m	struct:__anon63
resample_row_1	vendor/stb_image/stb_image.h	/^static stbi_uc *resample_row_1(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)$/;"	f
resample_row_func	vendor/stb_image/stb_image.h	/^typedef stbi_uc *(*resample_row_func)(stbi_uc *out, stbi_uc *in0, stbi_uc *in1,$/;"	t
resample_row_hv_2_kernel	vendor/stb_image/stb_image.h	/^   stbi_uc *(*resample_row_hv_2_kernel)(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs);$/;"	m	struct:__anon61
reserve	vendor/imgui/imgui.h	/^    inline void         reserve(int new_capacity)           { if (new_capacity <= Capacity) return; T* new_data = (T*)IM_ALLOC((size_t)new_capacity * sizeof(T)); if (Data) { memcpy(new_data, Data, (size_t)Size * sizeof(T)); IM_FREE(Data); } Data = new_data; Capacity = new_capacity; }$/;"	f	struct:ImVector
reserve	vendor/imgui/imgui.h	/^    void                reserve(int capacity)   { Buf.reserve(capacity); }$/;"	f	struct:ImGuiTextBuffer
resize	vendor/imgui/imgui.h	/^    inline void         resize(int new_size)                { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }$/;"	f	struct:ImVector
resize	vendor/imgui/imgui.h	/^    inline void         resize(int new_size, const T& v)    { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }$/;"	f	struct:ImVector
resize_grip_def	vendor/imgui/imgui.cpp	/^static const ImGuiResizeGripDef resize_grip_def[4] =$/;"	v	file:
restart_interval	vendor/stb_image/stb_image.h	/^   int restart_interval, todo;$/;"	m	struct:__anon61
rgb	vendor/stb_image/stb_image.h	/^   int            rgb;$/;"	m	struct:__anon61
row_major	vendor/glm/gtx/io.hpp	/^		enum order_type { column_major, row_major};$/;"	e	enum:glm::io::order_type
row_type	vendor/glm/detail/type_mat2x2.hpp	/^		typedef vec<2, T, Q> row_type;$/;"	t	struct:glm::mat
row_type	vendor/glm/detail/type_mat2x3.hpp	/^		typedef vec<2, T, Q> row_type;$/;"	t	struct:glm::mat
row_type	vendor/glm/detail/type_mat2x4.hpp	/^		typedef vec<2, T, Q> row_type;$/;"	t	struct:glm::mat
row_type	vendor/glm/detail/type_mat3x2.hpp	/^		typedef vec<3, T, Q> row_type;$/;"	t	struct:glm::mat
row_type	vendor/glm/detail/type_mat3x3.hpp	/^		typedef vec<3, T, Q> row_type;$/;"	t	struct:glm::mat
row_type	vendor/glm/detail/type_mat3x4.hpp	/^		typedef vec<3, T, Q> row_type;$/;"	t	struct:glm::mat
row_type	vendor/glm/detail/type_mat4x2.hpp	/^		typedef vec<4, T, Q> row_type;$/;"	t	struct:glm::mat
row_type	vendor/glm/detail/type_mat4x3.hpp	/^		typedef vec<4, T, Q> row_type;$/;"	t	struct:glm::mat
row_type	vendor/glm/detail/type_mat4x4.hpp	/^		typedef vec<4, T, Q> row_type;$/;"	t	struct:glm::mat
rows	vendor/glm/gtx/type_trait.hpp	/^		static length_t const rows = 0;$/;"	m	struct:glm::type
rows	vendor/glm/gtx/type_trait.hpp	/^		static length_t const rows = R;$/;"	m	struct:glm::type
s	vendor/glm/detail/type_vec1.hpp	/^				T s;$/;"	m	union:glm::vec::__anon1
s	vendor/glm/detail/type_vec1.hpp	/^			union {T x, r, s;};$/;"	m	union:glm::vec::__anon2
s	vendor/glm/detail/type_vec2.hpp	/^				struct{ T s, t; };$/;"	m	struct:glm::vec::__anon10::__anon13
s	vendor/glm/detail/type_vec2.hpp	/^			union {T x, r, s;};$/;"	m	union:glm::vec::__anon14
s	vendor/glm/detail/type_vec3.hpp	/^				struct{ T s, t, p; };$/;"	m	struct:glm::vec::__anon3::__anon6
s	vendor/glm/detail/type_vec3.hpp	/^			union { T x, r, s; };$/;"	m	union:glm::vec::__anon7
s	vendor/glm/detail/type_vec4.hpp	/^				struct { T s, t, p, q; };$/;"	m	struct:glm::vec::__anon18::__anon21
s	vendor/glm/detail/type_vec4.hpp	/^			union { T x, r, s; };$/;"	m	union:glm::vec::__anon22
s	vendor/stb_image/stb_image.h	/^   stbi__context *s;$/;"	m	struct:__anon61
s	vendor/stb_image/stb_image.h	/^   stbi__context *s;$/;"	m	struct:__anon67
s0	vendor/imgui/imstb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon31
s1	vendor/imgui/imstb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon31
saturate	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER T saturate(T x){return clamp(x, T(0), T(1));}														\/\/!< \\brief Returns clamp(x, 0, 1) for each component in x. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
saturate	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<2, T, Q> saturate(const vec<2, T, Q>& x){return clamp(x, T(0), T(1));}					\/\/!< \\brief Returns clamp(x, 0, 1) for each component in x. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
saturate	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<3, T, Q> saturate(const vec<3, T, Q>& x){return clamp(x, T(0), T(1));}					\/\/!< \\brief Returns clamp(x, 0, 1) for each component in x. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
saturate	vendor/glm/gtx/compatibility.hpp	/^	template<typename T, qualifier Q> GLM_FUNC_QUALIFIER vec<4, T, Q> saturate(const vec<4, T, Q>& x){return clamp(x, T(0), T(1));}					\/\/!< \\brief Returns clamp(x, 0, 1) for each component in x. (From GLM_GTX_compatibility)$/;"	f	namespace:glm
scan_n	vendor/stb_image/stb_image.h	/^   int scan_n, order[4];$/;"	m	struct:__anon61
select_end	vendor/imgui/imstb_textedit.h	/^   int select_end;$/;"	m	struct:__anon50
select_start	vendor/imgui/imstb_textedit.h	/^   int select_start;          \/\/ selection start point$/;"	m	struct:__anon50
separator	vendor/glm/gtx/io.hpp	/^			char_type  separator;$/;"	m	class:glm::io::format_punct
single_line	vendor/imgui/imstb_textedit.h	/^   unsigned char single_line;$/;"	m	struct:__anon50
sint	vendor/glm/gtx/integer.hpp	/^	typedef signed int					sint;$/;"	t	namespace:glm
size	vendor/imgui/imgui.h	/^    inline int          size() const                        { return Size; }$/;"	f	struct:ImVector
size	vendor/imgui/imgui.h	/^    int                 size() const            { return Buf.Size ? Buf.Size - 1 : 0; }$/;"	f	struct:ImGuiTextBuffer
size	vendor/imgui/imstb_truetype.h	/^   int size;$/;"	m	struct:__anon29
size	vendor/stb_image/stb_image.h	/^   stbi_uc  size[257];$/;"	m	struct:__anon60
size	vendor/stb_image/stb_image.h	/^   stbi_uc  size[288];$/;"	m	struct:__anon64
size	vendor/stb_image/stb_image.h	/^   stbi_uc size,type,channel;$/;"	m	struct:__anon70
size1	vendor/glm/gtx/std_based_type.hpp	/^	typedef vec<1, std::size_t, defaultp>		size1;$/;"	t	namespace:glm
size1_t	vendor/glm/gtx/std_based_type.hpp	/^	typedef vec<1, std::size_t, defaultp>		size1_t;$/;"	t	namespace:glm
size2	vendor/glm/gtx/std_based_type.hpp	/^	typedef vec<2, std::size_t, defaultp>		size2;$/;"	t	namespace:glm
size2_t	vendor/glm/gtx/std_based_type.hpp	/^	typedef vec<2, std::size_t, defaultp>		size2_t;$/;"	t	namespace:glm
size3	vendor/glm/gtx/std_based_type.hpp	/^	typedef vec<3, std::size_t, defaultp>		size3;$/;"	t	namespace:glm
size3_t	vendor/glm/gtx/std_based_type.hpp	/^	typedef vec<3, std::size_t, defaultp>		size3_t;$/;"	t	namespace:glm
size4	vendor/glm/gtx/std_based_type.hpp	/^	typedef vec<4, std::size_t, defaultp>		size4;$/;"	t	namespace:glm
size4_t	vendor/glm/gtx/std_based_type.hpp	/^	typedef vec<4, std::size_t, defaultp>		size4_t;$/;"	t	namespace:glm
size_in_bytes	vendor/imgui/imgui.h	/^    inline int          size_in_bytes() const               { return Size * (int)sizeof(T); }$/;"	f	struct:ImVector
skip	vendor/stb_image/stb_image.h	/^   void     (*skip)  (void *user,int n);                 \/\/ skip the next 'n' bytes, or 'unget' the last -n bytes if negative$/;"	m	struct:__anon55
skip_missing	vendor/imgui/imstb_truetype.h	/^   int   skip_missing;$/;"	m	struct:stbtt_pack_context
snprintf	vendor/imgui/imgui_demo.cpp	103;"	d	file:
space	vendor/glm/gtx/io.hpp	/^			char_type  space;$/;"	m	class:glm::io::format_punct
spec_end	vendor/stb_image/stb_image.h	/^   int            spec_end;$/;"	m	struct:__anon61
spec_start	vendor/stb_image/stb_image.h	/^   int            spec_start;$/;"	m	struct:__anon61
split	vendor/imgui/imgui.cpp	/^void ImGuiTextFilter::ImGuiTextRange::split(char separator, ImVector<ImGuiTextRange>* out) const$/;"	f	class:ImGuiTextFilter::ImGuiTextRange
start_x	vendor/stb_image/stb_image.h	/^   int start_x, start_y;$/;"	m	struct:__anon72
start_y	vendor/stb_image/stb_image.h	/^   int start_x, start_y;$/;"	m	struct:__anon72
started	vendor/imgui/imstb_truetype.h	/^   int started;$/;"	m	struct:__anon43
state_	vendor/glm/gtx/io.hpp	/^			state_type&     state_;$/;"	m	class:glm::io::basic_state_saver
state_saver	vendor/glm/gtx/io.hpp	/^		typedef basic_state_saver<char>     state_saver;$/;"	t	namespace:glm::io
state_type	vendor/glm/gtx/io.hpp	/^			typedef ::std::basic_ios<CTy,CTr>      state_type;$/;"	t	class:glm::io::basic_state_saver
stb__barrier_in_b	vendor/imgui/imgui_draw.cpp	/^static const unsigned char *stb__barrier_in_b;$/;"	v	file:
stb__barrier_out_b	vendor/imgui/imgui_draw.cpp	/^static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;$/;"	v	file:
stb__barrier_out_e	vendor/imgui/imgui_draw.cpp	/^static unsigned char *stb__barrier_out_e, *stb__barrier_out_b;$/;"	v	file:
stb__dout	vendor/imgui/imgui_draw.cpp	/^static unsigned char *stb__dout;$/;"	v	file:
stb__in2	vendor/imgui/imgui_draw.cpp	3170;"	d	file:
stb__in3	vendor/imgui/imgui_draw.cpp	3171;"	d	file:
stb__in4	vendor/imgui/imgui_draw.cpp	3172;"	d	file:
stb__lit	vendor/imgui/imgui_draw.cpp	/^static void stb__lit(const unsigned char *data, unsigned int length)$/;"	f	file:
stb__match	vendor/imgui/imgui_draw.cpp	/^static void stb__match(const unsigned char *data, unsigned int length)$/;"	f	file:
stb_adler32	vendor/imgui/imgui_draw.cpp	/^static unsigned int stb_adler32(unsigned int adler32, unsigned char *buffer, unsigned int buflen)$/;"	f	file:
stb_decompress	vendor/imgui/imgui_draw.cpp	/^static unsigned int stb_decompress(unsigned char *output, const unsigned char *i, unsigned int \/*length*\/)$/;"	f	file:
stb_decompress_length	vendor/imgui/imgui_draw.cpp	/^static unsigned int stb_decompress_length(const unsigned char *input)$/;"	f	file:
stb_decompress_token	vendor/imgui/imgui_draw.cpp	/^static const unsigned char *stb_decompress_token(const unsigned char *i)$/;"	f	file:
stb_text_create_undo_record	vendor/imgui/imstb_textedit.h	/^static StbUndoRecord *stb_text_create_undo_record(StbUndoState *state, int numchars)$/;"	f
stb_text_createundo	vendor/imgui/imstb_textedit.h	/^static STB_TEXTEDIT_CHARTYPE *stb_text_createundo(StbUndoState *state, int pos, int insert_len, int delete_len)$/;"	f
stb_text_locate_coord	vendor/imgui/imstb_textedit.h	/^static int stb_text_locate_coord(STB_TEXTEDIT_STRING *str, float x, float y)$/;"	f
stb_text_makeundo_delete	vendor/imgui/imstb_textedit.h	/^static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int length)$/;"	f
stb_text_makeundo_insert	vendor/imgui/imstb_textedit.h	/^static void stb_text_makeundo_insert(STB_TexteditState *state, int where, int length)$/;"	f
stb_text_makeundo_replace	vendor/imgui/imstb_textedit.h	/^static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int old_length, int new_length)$/;"	f
stb_text_redo	vendor/imgui/imstb_textedit.h	/^static void stb_text_redo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_text_undo	vendor/imgui/imstb_textedit.h	/^static void stb_text_undo(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_clamp	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_clamp(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_clear_state	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_clear_state(STB_TexteditState *state, int is_single_line)$/;"	f
stb_textedit_click	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)$/;"	f
stb_textedit_cut	vendor/imgui/imstb_textedit.h	/^static int stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_delete	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_delete(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int where, int len)$/;"	f
stb_textedit_delete_selection	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_discard_redo	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_discard_redo(StbUndoState *state)$/;"	f
stb_textedit_discard_undo	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_discard_undo(StbUndoState *state)$/;"	f
stb_textedit_drag	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)$/;"	f
stb_textedit_find_charpos	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_find_charpos(StbFindState *find, STB_TEXTEDIT_STRING *str, int n, int single_line)$/;"	f
stb_textedit_flush_redo	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_flush_redo(StbUndoState *state)$/;"	f
stb_textedit_initialize_state	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)$/;"	f
stb_textedit_key	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_KEYTYPE key)$/;"	f
stb_textedit_move_to_first	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_move_to_first(STB_TexteditState *state)$/;"	f
stb_textedit_move_to_last	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)$/;"	f
stb_textedit_move_to_word_next	vendor/imgui/imstb_textedit.h	/^static int stb_textedit_move_to_word_next( STB_TEXTEDIT_STRING *str, int c )$/;"	f
stb_textedit_move_to_word_previous	vendor/imgui/imstb_textedit.h	/^static int stb_textedit_move_to_word_previous( STB_TEXTEDIT_STRING *str, int c )$/;"	f
stb_textedit_paste	vendor/imgui/imstb_textedit.h	/^static int stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE const *ctext, int len)$/;"	f
stb_textedit_paste_internal	vendor/imgui/imstb_textedit.h	/^static int stb_textedit_paste_internal(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)$/;"	f
stb_textedit_prep_selection_at_cursor	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_prep_selection_at_cursor(STB_TexteditState *state)$/;"	f
stb_textedit_sortselection	vendor/imgui/imstb_textedit.h	/^static void stb_textedit_sortselection(STB_TexteditState *state)$/;"	f
stbi__DNL	vendor/stb_image/stb_image.h	3150;"	d
stbi__EOI	vendor/stb_image/stb_image.h	3152;"	d
stbi__SOF	vendor/stb_image/stb_image.h	3153;"	d
stbi__SOF_progressive	vendor/stb_image/stb_image.h	3156;"	d
stbi__SOI	vendor/stb_image/stb_image.h	3151;"	d
stbi__SOS	vendor/stb_image/stb_image.h	3154;"	d
stbi__YCbCr_to_RGB_row	vendor/stb_image/stb_image.h	/^static void stbi__YCbCr_to_RGB_row(stbi_uc *out, const stbi_uc *y, const stbi_uc *pcb, const stbi_uc *pcr, int count, int step)$/;"	f
stbi__YCbCr_to_RGB_simd	vendor/stb_image/stb_image.h	/^static void stbi__YCbCr_to_RGB_simd(stbi_uc *out, stbi_uc const *y, stbi_uc const *pcb, stbi_uc const *pcr, int count, int step)$/;"	f
stbi__addsizes_valid	vendor/stb_image/stb_image.h	/^static int stbi__addsizes_valid(int a, int b)$/;"	f
stbi__at_eof	vendor/stb_image/stb_image.h	/^stbi_inline static int stbi__at_eof(stbi__context *s)$/;"	f
stbi__bit_reverse	vendor/stb_image/stb_image.h	/^stbi_inline static int stbi__bit_reverse(int v, int bits)$/;"	f
stbi__bitcount	vendor/stb_image/stb_image.h	/^static int stbi__bitcount(unsigned int a)$/;"	f
stbi__bitreverse16	vendor/stb_image/stb_image.h	/^stbi_inline static int stbi__bitreverse16(int n)$/;"	f
stbi__blinn_8x8	vendor/stb_image/stb_image.h	/^static stbi_uc stbi__blinn_8x8(stbi_uc x, stbi_uc y)$/;"	f
stbi__bmask	vendor/stb_image/stb_image.h	/^static const stbi__uint32 stbi__bmask[17]={0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535};$/;"	v
stbi__bmp_data	vendor/stb_image/stb_image.h	/^} stbi__bmp_data;$/;"	t	typeref:struct:__anon69
stbi__bmp_info	vendor/stb_image/stb_image.h	/^static int stbi__bmp_info(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__bmp_load	vendor/stb_image/stb_image.h	/^static void *stbi__bmp_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)$/;"	f
stbi__bmp_parse_header	vendor/stb_image/stb_image.h	/^static void *stbi__bmp_parse_header(stbi__context *s, stbi__bmp_data *info)$/;"	f
stbi__bmp_test	vendor/stb_image/stb_image.h	/^static int stbi__bmp_test(stbi__context *s)$/;"	f
stbi__bmp_test_raw	vendor/stb_image/stb_image.h	/^static int stbi__bmp_test_raw(stbi__context *s)$/;"	f
stbi__build_fast_ac	vendor/stb_image/stb_image.h	/^static void stbi__build_fast_ac(stbi__int16 *fast_ac, stbi__huffman *h)$/;"	f
stbi__build_huffman	vendor/stb_image/stb_image.h	/^static int stbi__build_huffman(stbi__huffman *h, int *count)$/;"	f
stbi__check_png_header	vendor/stb_image/stb_image.h	/^static int stbi__check_png_header(stbi__context *s)$/;"	f
stbi__clamp	vendor/stb_image/stb_image.h	/^stbi_inline static stbi_uc stbi__clamp(int x)$/;"	f
stbi__cleanup_jpeg	vendor/stb_image/stb_image.h	/^static void stbi__cleanup_jpeg(stbi__jpeg *j)$/;"	f
stbi__compute_huffman_codes	vendor/stb_image/stb_image.h	/^static int stbi__compute_huffman_codes(stbi__zbuf *a)$/;"	f
stbi__compute_transparency	vendor/stb_image/stb_image.h	/^static int stbi__compute_transparency(stbi__png *z, stbi_uc tc[3], int out_n)$/;"	f
stbi__compute_transparency16	vendor/stb_image/stb_image.h	/^static int stbi__compute_transparency16(stbi__png *z, stbi__uint16 tc[3], int out_n)$/;"	f
stbi__compute_y	vendor/stb_image/stb_image.h	/^static stbi_uc stbi__compute_y(int r, int g, int b)$/;"	f
stbi__compute_y_16	vendor/stb_image/stb_image.h	/^static stbi__uint16 stbi__compute_y_16(int r, int g, int b)$/;"	f
stbi__context	vendor/stb_image/stb_image.h	/^} stbi__context;$/;"	t	typeref:struct:__anon56
stbi__convert_16_to_8	vendor/stb_image/stb_image.h	/^static stbi_uc *stbi__convert_16_to_8(stbi__uint16 *orig, int w, int h, int channels)$/;"	f
stbi__convert_8_to_16	vendor/stb_image/stb_image.h	/^static stbi__uint16 *stbi__convert_8_to_16(stbi_uc *orig, int w, int h, int channels)$/;"	f
stbi__convert_format	vendor/stb_image/stb_image.h	/^static unsigned char *stbi__convert_format(unsigned char *data, int img_n, int req_comp, unsigned int x, unsigned int y)$/;"	f
stbi__convert_format16	vendor/stb_image/stb_image.h	/^static stbi__uint16 *stbi__convert_format16(stbi__uint16 *data, int img_n, int req_comp, unsigned int x, unsigned int y)$/;"	f
stbi__copyval	vendor/stb_image/stb_image.h	/^static void stbi__copyval(int channel,stbi_uc *dest,const stbi_uc *src)$/;"	f
stbi__cpuid3	vendor/stb_image/stb_image.h	/^static int stbi__cpuid3(void)$/;"	f
stbi__create_png_image	vendor/stb_image/stb_image.h	/^static int stbi__create_png_image(stbi__png *a, stbi_uc *image_data, stbi__uint32 image_data_len, int out_n, int depth, int color, int interlaced)$/;"	f
stbi__create_png_image_raw	vendor/stb_image/stb_image.h	/^static int stbi__create_png_image_raw(stbi__png *a, stbi_uc *raw, stbi__uint32 raw_len, int out_n, stbi__uint32 x, stbi__uint32 y, int depth, int color)$/;"	f
stbi__de_iphone	vendor/stb_image/stb_image.h	/^static void stbi__de_iphone(stbi__png *z)$/;"	f
stbi__de_iphone_flag	vendor/stb_image/stb_image.h	/^static int stbi__de_iphone_flag = 0;$/;"	v
stbi__decode_jpeg_header	vendor/stb_image/stb_image.h	/^static int stbi__decode_jpeg_header(stbi__jpeg *z, int scan)$/;"	f
stbi__decode_jpeg_image	vendor/stb_image/stb_image.h	/^static int stbi__decode_jpeg_image(stbi__jpeg *j)$/;"	f
stbi__depth_scale_table	vendor/stb_image/stb_image.h	/^static const stbi_uc stbi__depth_scale_table[9] = { 0, 0xff, 0x55, 0, 0x11, 0,0,0, 0x01 };$/;"	v
stbi__div16	vendor/stb_image/stb_image.h	3277;"	d
stbi__div4	vendor/stb_image/stb_image.h	3228;"	d
stbi__do_png	vendor/stb_image/stb_image.h	/^static void *stbi__do_png(stbi__png *p, int *x, int *y, int *n, int req_comp, stbi__result_info *ri)$/;"	f
stbi__do_zlib	vendor/stb_image/stb_image.h	/^static int stbi__do_zlib(stbi__zbuf *a, char *obuf, int olen, int exp, int parse_header)$/;"	f
stbi__err	vendor/stb_image/stb_image.h	/^static int stbi__err(const char *str)$/;"	f
stbi__err	vendor/stb_image/stb_image.h	974;"	d
stbi__err	vendor/stb_image/stb_image.h	976;"	d
stbi__err	vendor/stb_image/stb_image.h	978;"	d
stbi__errpf	vendor/stb_image/stb_image.h	981;"	d
stbi__errpuc	vendor/stb_image/stb_image.h	982;"	d
stbi__expand_png_palette	vendor/stb_image/stb_image.h	/^static int stbi__expand_png_palette(stbi__png *a, stbi_uc *palette, int len, int pal_img_n)$/;"	f
stbi__extend_receive	vendor/stb_image/stb_image.h	/^stbi_inline static int stbi__extend_receive(stbi__jpeg *j, int n)$/;"	f
stbi__f2f	vendor/stb_image/stb_image.h	2229;"	d
stbi__fill_bits	vendor/stb_image/stb_image.h	/^static void stbi__fill_bits(stbi__zbuf *z)$/;"	f
stbi__float2fixed	vendor/stb_image/stb_image.h	3433;"	d
stbi__float2int	vendor/stb_image/stb_image.h	1700;"	d
stbi__float_postprocess	vendor/stb_image/stb_image.h	/^static void stbi__float_postprocess(float *result, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi__fopen	vendor/stb_image/stb_image.h	/^static FILE *stbi__fopen(char const *filename, char const *mode)$/;"	f
stbi__free_jpeg_components	vendor/stb_image/stb_image.h	/^static int stbi__free_jpeg_components(stbi__jpeg *z, int ncomp, int why)$/;"	f
stbi__fsh	vendor/stb_image/stb_image.h	2230;"	d
stbi__g_failure_reason	vendor/stb_image/stb_image.h	/^static const char *stbi__g_failure_reason;$/;"	v
stbi__get16be	vendor/stb_image/stb_image.h	/^static int stbi__get16be(stbi__context *s)$/;"	f
stbi__get16le	vendor/stb_image/stb_image.h	/^static int stbi__get16le(stbi__context *s)$/;"	f
stbi__get32be	vendor/stb_image/stb_image.h	/^static stbi__uint32 stbi__get32be(stbi__context *s)$/;"	f
stbi__get32le	vendor/stb_image/stb_image.h	/^static stbi__uint32 stbi__get32le(stbi__context *s)$/;"	f
stbi__get8	vendor/stb_image/stb_image.h	/^stbi_inline static stbi_uc stbi__get8(stbi__context *s)$/;"	f
stbi__get_chunk_header	vendor/stb_image/stb_image.h	/^static stbi__pngchunk stbi__get_chunk_header(stbi__context *s)$/;"	f
stbi__get_marker	vendor/stb_image/stb_image.h	/^static stbi_uc stbi__get_marker(stbi__jpeg *j)$/;"	f
stbi__getn	vendor/stb_image/stb_image.h	/^static int stbi__getn(stbi__context *s, stbi_uc *buffer, int n)$/;"	f
stbi__gif	vendor/stb_image/stb_image.h	/^} stbi__gif;$/;"	t	typeref:struct:__anon72
stbi__gif_header	vendor/stb_image/stb_image.h	/^static int stbi__gif_header(stbi__context *s, stbi__gif *g, int *comp, int is_info)$/;"	f
stbi__gif_info	vendor/stb_image/stb_image.h	/^static int stbi__gif_info(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__gif_info_raw	vendor/stb_image/stb_image.h	/^static int stbi__gif_info_raw(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__gif_load	vendor/stb_image/stb_image.h	/^static void *stbi__gif_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)$/;"	f
stbi__gif_load_next	vendor/stb_image/stb_image.h	/^static stbi_uc *stbi__gif_load_next(stbi__context *s, stbi__gif *g, int *comp, int req_comp, stbi_uc *two_back)$/;"	f
stbi__gif_lzw	vendor/stb_image/stb_image.h	/^} stbi__gif_lzw;$/;"	t	typeref:struct:__anon71
stbi__gif_parse_colortable	vendor/stb_image/stb_image.h	/^static void stbi__gif_parse_colortable(stbi__context *s, stbi_uc pal[256][4], int num_entries, int transp)$/;"	f
stbi__gif_test	vendor/stb_image/stb_image.h	/^static int stbi__gif_test(stbi__context *s)$/;"	f
stbi__gif_test_raw	vendor/stb_image/stb_image.h	/^static int stbi__gif_test_raw(stbi__context *s)$/;"	f
stbi__grow_buffer_unsafe	vendor/stb_image/stb_image.h	/^static void stbi__grow_buffer_unsafe(stbi__jpeg *j)$/;"	f
stbi__h2l_gamma_i	vendor/stb_image/stb_image.h	/^static float stbi__h2l_gamma_i=1.0f\/2.2f, stbi__h2l_scale_i=1.0f;$/;"	v
stbi__h2l_scale_i	vendor/stb_image/stb_image.h	/^static float stbi__h2l_gamma_i=1.0f\/2.2f, stbi__h2l_scale_i=1.0f;$/;"	v
stbi__hdr_convert	vendor/stb_image/stb_image.h	/^static void stbi__hdr_convert(float *output, stbi_uc *input, int req_comp)$/;"	f
stbi__hdr_gettoken	vendor/stb_image/stb_image.h	/^static char *stbi__hdr_gettoken(stbi__context *z, char *buffer)$/;"	f
stbi__hdr_info	vendor/stb_image/stb_image.h	/^static int stbi__hdr_info(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__hdr_load	vendor/stb_image/stb_image.h	/^static float *stbi__hdr_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)$/;"	f
stbi__hdr_test	vendor/stb_image/stb_image.h	/^static int stbi__hdr_test(stbi__context* s)$/;"	f
stbi__hdr_test_core	vendor/stb_image/stb_image.h	/^static int stbi__hdr_test_core(stbi__context *s, const char *signature)$/;"	f
stbi__hdr_to_ldr	vendor/stb_image/stb_image.h	/^static stbi_uc *stbi__hdr_to_ldr(float   *data, int x, int y, int comp)$/;"	f
stbi__high_bit	vendor/stb_image/stb_image.h	/^static int stbi__high_bit(unsigned int z)$/;"	f
stbi__huffman	vendor/stb_image/stb_image.h	/^} stbi__huffman;$/;"	t	typeref:struct:__anon60
stbi__idct_block	vendor/stb_image/stb_image.h	/^static void stbi__idct_block(stbi_uc *out, int out_stride, short data[64])$/;"	f
stbi__idct_simd	vendor/stb_image/stb_image.h	/^static void stbi__idct_simd(stbi_uc *out, int out_stride, short data[64])$/;"	f
stbi__info_main	vendor/stb_image/stb_image.h	/^static int stbi__info_main(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__int16	vendor/stb_image/stb_image.h	/^typedef   signed short stbi__int16;$/;"	t
stbi__int16	vendor/stb_image/stb_image.h	/^typedef int16_t  stbi__int16;$/;"	t
stbi__int32	vendor/stb_image/stb_image.h	/^typedef   signed int   stbi__int32;$/;"	t
stbi__int32	vendor/stb_image/stb_image.h	/^typedef int32_t  stbi__int32;$/;"	t
stbi__is_16_main	vendor/stb_image/stb_image.h	/^static int stbi__is_16_main(stbi__context *s)$/;"	f
stbi__jbias	vendor/stb_image/stb_image.h	/^static const int stbi__jbias[16] = {0,-1,-3,-7,-15,-31,-63,-127,-255,-511,-1023,-2047,-4095,-8191,-16383,-32767};$/;"	v
stbi__jpeg	vendor/stb_image/stb_image.h	/^} stbi__jpeg;$/;"	t	typeref:struct:__anon61
stbi__jpeg_decode_block	vendor/stb_image/stb_image.h	/^static int stbi__jpeg_decode_block(stbi__jpeg *j, short data[64], stbi__huffman *hdc, stbi__huffman *hac, stbi__int16 *fac, int b, stbi__uint16 *dequant)$/;"	f
stbi__jpeg_decode_block_prog_ac	vendor/stb_image/stb_image.h	/^static int stbi__jpeg_decode_block_prog_ac(stbi__jpeg *j, short data[64], stbi__huffman *hac, stbi__int16 *fac)$/;"	f
stbi__jpeg_decode_block_prog_dc	vendor/stb_image/stb_image.h	/^static int stbi__jpeg_decode_block_prog_dc(stbi__jpeg *j, short data[64], stbi__huffman *hdc, int b)$/;"	f
stbi__jpeg_dequantize	vendor/stb_image/stb_image.h	/^static void stbi__jpeg_dequantize(short *data, stbi__uint16 *dequant)$/;"	f
stbi__jpeg_dezigzag	vendor/stb_image/stb_image.h	/^static const stbi_uc stbi__jpeg_dezigzag[64+15] =$/;"	v
stbi__jpeg_finish	vendor/stb_image/stb_image.h	/^static void stbi__jpeg_finish(stbi__jpeg *z)$/;"	f
stbi__jpeg_get_bit	vendor/stb_image/stb_image.h	/^stbi_inline static int stbi__jpeg_get_bit(stbi__jpeg *j)$/;"	f
stbi__jpeg_get_bits	vendor/stb_image/stb_image.h	/^stbi_inline static int stbi__jpeg_get_bits(stbi__jpeg *j, int n)$/;"	f
stbi__jpeg_huff_decode	vendor/stb_image/stb_image.h	/^stbi_inline static int stbi__jpeg_huff_decode(stbi__jpeg *j, stbi__huffman *h)$/;"	f
stbi__jpeg_info	vendor/stb_image/stb_image.h	/^static int stbi__jpeg_info(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__jpeg_info_raw	vendor/stb_image/stb_image.h	/^static int stbi__jpeg_info_raw(stbi__jpeg *j, int *x, int *y, int *comp)$/;"	f
stbi__jpeg_load	vendor/stb_image/stb_image.h	/^static void *stbi__jpeg_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)$/;"	f
stbi__jpeg_reset	vendor/stb_image/stb_image.h	/^static void stbi__jpeg_reset(stbi__jpeg *j)$/;"	f
stbi__jpeg_test	vendor/stb_image/stb_image.h	/^static int stbi__jpeg_test(stbi__context *s)$/;"	f
stbi__l2h_gamma	vendor/stb_image/stb_image.h	/^static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;$/;"	v
stbi__l2h_scale	vendor/stb_image/stb_image.h	/^static float stbi__l2h_gamma=2.2f, stbi__l2h_scale=1.0f;$/;"	v
stbi__ldr_to_hdr	vendor/stb_image/stb_image.h	/^static float   *stbi__ldr_to_hdr(stbi_uc *data, int x, int y, int comp)$/;"	f
stbi__load_and_postprocess_16bit	vendor/stb_image/stb_image.h	/^static stbi__uint16 *stbi__load_and_postprocess_16bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi__load_and_postprocess_8bit	vendor/stb_image/stb_image.h	/^static unsigned char *stbi__load_and_postprocess_8bit(stbi__context *s, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi__load_gif_main	vendor/stb_image/stb_image.h	/^static void *stbi__load_gif_main(stbi__context *s, int **delays, int *x, int *y, int *z, int *comp, int req_comp)$/;"	f
stbi__load_main	vendor/stb_image/stb_image.h	/^static void *stbi__load_main(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)$/;"	f
stbi__loadf_main	vendor/stb_image/stb_image.h	/^static float *stbi__loadf_main(stbi__context *s, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi__mad2sizes_valid	vendor/stb_image/stb_image.h	/^static int stbi__mad2sizes_valid(int a, int b, int add)$/;"	f
stbi__mad3sizes_valid	vendor/stb_image/stb_image.h	/^static int stbi__mad3sizes_valid(int a, int b, int c, int add)$/;"	f
stbi__mad4sizes_valid	vendor/stb_image/stb_image.h	/^static int stbi__mad4sizes_valid(int a, int b, int c, int d, int add)$/;"	f
stbi__malloc	vendor/stb_image/stb_image.h	/^static void *stbi__malloc(size_t size)$/;"	f
stbi__malloc_mad2	vendor/stb_image/stb_image.h	/^static void *stbi__malloc_mad2(int a, int b, int add)$/;"	f
stbi__malloc_mad3	vendor/stb_image/stb_image.h	/^static void *stbi__malloc_mad3(int a, int b, int c, int add)$/;"	f
stbi__malloc_mad4	vendor/stb_image/stb_image.h	/^static void *stbi__malloc_mad4(int a, int b, int c, int d, int add)$/;"	f
stbi__mul2sizes_valid	vendor/stb_image/stb_image.h	/^static int stbi__mul2sizes_valid(int a, int b)$/;"	f
stbi__out_gif_code	vendor/stb_image/stb_image.h	/^static void stbi__out_gif_code(stbi__gif *g, stbi__uint16 code)$/;"	f
stbi__paeth	vendor/stb_image/stb_image.h	/^static int stbi__paeth(int a, int b, int c)$/;"	f
stbi__parse_entropy_coded_data	vendor/stb_image/stb_image.h	/^static int stbi__parse_entropy_coded_data(stbi__jpeg *z)$/;"	f
stbi__parse_huffman_block	vendor/stb_image/stb_image.h	/^static int stbi__parse_huffman_block(stbi__zbuf *a)$/;"	f
stbi__parse_png_file	vendor/stb_image/stb_image.h	/^static int stbi__parse_png_file(stbi__png *z, int scan, int req_comp)$/;"	f
stbi__parse_uncompressed_block	vendor/stb_image/stb_image.h	/^static int stbi__parse_uncompressed_block(stbi__zbuf *a)$/;"	f
stbi__parse_zlib	vendor/stb_image/stb_image.h	/^static int stbi__parse_zlib(stbi__zbuf *a, int parse_header)$/;"	f
stbi__parse_zlib_header	vendor/stb_image/stb_image.h	/^static int stbi__parse_zlib_header(stbi__zbuf *a)$/;"	f
stbi__pic_info	vendor/stb_image/stb_image.h	/^static int stbi__pic_info(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__pic_is4	vendor/stb_image/stb_image.h	/^static int stbi__pic_is4(stbi__context *s,const char *str)$/;"	f
stbi__pic_load	vendor/stb_image/stb_image.h	/^static void *stbi__pic_load(stbi__context *s,int *px,int *py,int *comp,int req_comp, stbi__result_info *ri)$/;"	f
stbi__pic_load_core	vendor/stb_image/stb_image.h	/^static stbi_uc *stbi__pic_load_core(stbi__context *s,int width,int height,int *comp, stbi_uc *result)$/;"	f
stbi__pic_packet	vendor/stb_image/stb_image.h	/^} stbi__pic_packet;$/;"	t	typeref:struct:__anon70
stbi__pic_test	vendor/stb_image/stb_image.h	/^static int stbi__pic_test(stbi__context *s)$/;"	f
stbi__pic_test_core	vendor/stb_image/stb_image.h	/^static int stbi__pic_test_core(stbi__context *s)$/;"	f
stbi__png	vendor/stb_image/stb_image.h	/^} stbi__png;$/;"	t	typeref:struct:__anon67
stbi__png_info	vendor/stb_image/stb_image.h	/^static int stbi__png_info(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__png_info_raw	vendor/stb_image/stb_image.h	/^static int stbi__png_info_raw(stbi__png *p, int *x, int *y, int *comp)$/;"	f
stbi__png_is16	vendor/stb_image/stb_image.h	/^static int stbi__png_is16(stbi__context *s)$/;"	f
stbi__png_load	vendor/stb_image/stb_image.h	/^static void *stbi__png_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)$/;"	f
stbi__png_test	vendor/stb_image/stb_image.h	/^static int stbi__png_test(stbi__context *s)$/;"	f
stbi__pngchunk	vendor/stb_image/stb_image.h	/^} stbi__pngchunk;$/;"	t	typeref:struct:__anon66
stbi__pnm_getinteger	vendor/stb_image/stb_image.h	/^static int      stbi__pnm_getinteger(stbi__context *s, char *c)$/;"	f
stbi__pnm_info	vendor/stb_image/stb_image.h	/^static int      stbi__pnm_info(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__pnm_isdigit	vendor/stb_image/stb_image.h	/^static int      stbi__pnm_isdigit(char c)$/;"	f
stbi__pnm_isspace	vendor/stb_image/stb_image.h	/^static int      stbi__pnm_isspace(char c)$/;"	f
stbi__pnm_load	vendor/stb_image/stb_image.h	/^static void *stbi__pnm_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)$/;"	f
stbi__pnm_skip_whitespace	vendor/stb_image/stb_image.h	/^static void     stbi__pnm_skip_whitespace(stbi__context *s, char *c)$/;"	f
stbi__pnm_test	vendor/stb_image/stb_image.h	/^static int      stbi__pnm_test(stbi__context *s)$/;"	f
stbi__process_frame_header	vendor/stb_image/stb_image.h	/^static int stbi__process_frame_header(stbi__jpeg *z, int scan)$/;"	f
stbi__process_gif_raster	vendor/stb_image/stb_image.h	/^static stbi_uc *stbi__process_gif_raster(stbi__context *s, stbi__gif *g)$/;"	f
stbi__process_marker	vendor/stb_image/stb_image.h	/^static int stbi__process_marker(stbi__jpeg *z, int m)$/;"	f
stbi__process_scan_header	vendor/stb_image/stb_image.h	/^static int stbi__process_scan_header(stbi__jpeg *z)$/;"	f
stbi__psd_decode_rle	vendor/stb_image/stb_image.h	/^static int stbi__psd_decode_rle(stbi__context *s, stbi_uc *p, int pixelCount)$/;"	f
stbi__psd_info	vendor/stb_image/stb_image.h	/^static int stbi__psd_info(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__psd_is16	vendor/stb_image/stb_image.h	/^static int stbi__psd_is16(stbi__context *s)$/;"	f
stbi__psd_load	vendor/stb_image/stb_image.h	/^static void *stbi__psd_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri, int bpc)$/;"	f
stbi__psd_test	vendor/stb_image/stb_image.h	/^static int stbi__psd_test(stbi__context *s)$/;"	f
stbi__readval	vendor/stb_image/stb_image.h	/^static stbi_uc *stbi__readval(stbi__context *s, int channel, stbi_uc *dest)$/;"	f
stbi__refill_buffer	vendor/stb_image/stb_image.h	/^static void stbi__refill_buffer(stbi__context *s)$/;"	f
stbi__resample	vendor/stb_image/stb_image.h	/^} stbi__resample;$/;"	t	typeref:struct:__anon63
stbi__resample_row_generic	vendor/stb_image/stb_image.h	/^static stbi_uc *stbi__resample_row_generic(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)$/;"	f
stbi__resample_row_h_2	vendor/stb_image/stb_image.h	/^static stbi_uc*  stbi__resample_row_h_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)$/;"	f
stbi__resample_row_hv_2	vendor/stb_image/stb_image.h	/^static stbi_uc *stbi__resample_row_hv_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)$/;"	f
stbi__resample_row_hv_2_simd	vendor/stb_image/stb_image.h	/^static stbi_uc *stbi__resample_row_hv_2_simd(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)$/;"	f
stbi__resample_row_v_2	vendor/stb_image/stb_image.h	/^static stbi_uc* stbi__resample_row_v_2(stbi_uc *out, stbi_uc *in_near, stbi_uc *in_far, int w, int hs)$/;"	f
stbi__result_info	vendor/stb_image/stb_image.h	/^} stbi__result_info;$/;"	t	typeref:struct:__anon58
stbi__rewind	vendor/stb_image/stb_image.h	/^static void stbi__rewind(stbi__context *s)$/;"	f
stbi__setup_jpeg	vendor/stb_image/stb_image.h	/^static void stbi__setup_jpeg(stbi__jpeg *j)$/;"	f
stbi__shiftsigned	vendor/stb_image/stb_image.h	/^static int stbi__shiftsigned(unsigned int v, int shift, int bits)$/;"	f
stbi__skip	vendor/stb_image/stb_image.h	/^static void stbi__skip(stbi__context *s, int n)$/;"	f
stbi__sse2_available	vendor/stb_image/stb_image.h	/^static int stbi__sse2_available(void)$/;"	f
stbi__start_callbacks	vendor/stb_image/stb_image.h	/^static void stbi__start_callbacks(stbi__context *s, stbi_io_callbacks *c, void *user)$/;"	f
stbi__start_file	vendor/stb_image/stb_image.h	/^static void stbi__start_file(stbi__context *s, FILE *f)$/;"	f
stbi__start_mem	vendor/stb_image/stb_image.h	/^static void stbi__start_mem(stbi__context *s, stbi_uc const *buffer, int len)$/;"	f
stbi__stdio_callbacks	vendor/stb_image/stb_image.h	/^static stbi_io_callbacks stbi__stdio_callbacks =$/;"	v
stbi__stdio_eof	vendor/stb_image/stb_image.h	/^static int stbi__stdio_eof(void *user)$/;"	f
stbi__stdio_read	vendor/stb_image/stb_image.h	/^static int stbi__stdio_read(void *user, char *data, int size)$/;"	f
stbi__stdio_skip	vendor/stb_image/stb_image.h	/^static void stbi__stdio_skip(void *user, int n)$/;"	f
stbi__tga_get_comp	vendor/stb_image/stb_image.h	/^static int stbi__tga_get_comp(int bits_per_pixel, int is_grey, int* is_rgb16)$/;"	f
stbi__tga_info	vendor/stb_image/stb_image.h	/^static int stbi__tga_info(stbi__context *s, int *x, int *y, int *comp)$/;"	f
stbi__tga_load	vendor/stb_image/stb_image.h	/^static void *stbi__tga_load(stbi__context *s, int *x, int *y, int *comp, int req_comp, stbi__result_info *ri)$/;"	f
stbi__tga_read_rgb16	vendor/stb_image/stb_image.h	/^static void stbi__tga_read_rgb16(stbi__context *s, stbi_uc* out)$/;"	f
stbi__tga_test	vendor/stb_image/stb_image.h	/^static int stbi__tga_test(stbi__context *s)$/;"	f
stbi__uint16	vendor/stb_image/stb_image.h	/^typedef uint16_t stbi__uint16;$/;"	t
stbi__uint16	vendor/stb_image/stb_image.h	/^typedef unsigned short stbi__uint16;$/;"	t
stbi__uint32	vendor/stb_image/stb_image.h	/^typedef uint32_t stbi__uint32;$/;"	t
stbi__uint32	vendor/stb_image/stb_image.h	/^typedef unsigned int   stbi__uint32;$/;"	t
stbi__unpremultiply_on_load	vendor/stb_image/stb_image.h	/^static int stbi__unpremultiply_on_load = 0;$/;"	v
stbi__vertical_flip	vendor/stb_image/stb_image.h	/^static void stbi__vertical_flip(void *image, int w, int h, int bytes_per_pixel)$/;"	f
stbi__vertical_flip_slices	vendor/stb_image/stb_image.h	/^static void stbi__vertical_flip_slices(void *image, int w, int h, int z, int bytes_per_pixel)$/;"	f
stbi__vertically_flip_on_load	vendor/stb_image/stb_image.h	/^static int stbi__vertically_flip_on_load = 0;$/;"	v
stbi__zbuf	vendor/stb_image/stb_image.h	/^} stbi__zbuf;$/;"	t	typeref:struct:__anon65
stbi__zbuild_huffman	vendor/stb_image/stb_image.h	/^static int stbi__zbuild_huffman(stbi__zhuffman *z, const stbi_uc *sizelist, int num)$/;"	f
stbi__zdefault_distance	vendor/stb_image/stb_image.h	/^static const stbi_uc stbi__zdefault_distance[32] =$/;"	v
stbi__zdefault_length	vendor/stb_image/stb_image.h	/^static const stbi_uc stbi__zdefault_length[288] =$/;"	v
stbi__zdist_base	vendor/stb_image/stb_image.h	/^static const int stbi__zdist_base[32] = { 1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,$/;"	v
stbi__zdist_extra	vendor/stb_image/stb_image.h	/^static const int stbi__zdist_extra[32] =$/;"	v
stbi__zexpand	vendor/stb_image/stb_image.h	/^static int stbi__zexpand(stbi__zbuf *z, char *zout, int n)  \/\/ need to make room for n bytes$/;"	f
stbi__zget8	vendor/stb_image/stb_image.h	/^stbi_inline static stbi_uc stbi__zget8(stbi__zbuf *z)$/;"	f
stbi__zhuffman	vendor/stb_image/stb_image.h	/^} stbi__zhuffman;$/;"	t	typeref:struct:__anon64
stbi__zhuffman_decode	vendor/stb_image/stb_image.h	/^stbi_inline static int stbi__zhuffman_decode(stbi__zbuf *a, stbi__zhuffman *z)$/;"	f
stbi__zhuffman_decode_slowpath	vendor/stb_image/stb_image.h	/^static int stbi__zhuffman_decode_slowpath(stbi__zbuf *a, stbi__zhuffman *z)$/;"	f
stbi__zlength_base	vendor/stb_image/stb_image.h	/^static const int stbi__zlength_base[31] = {$/;"	v
stbi__zlength_extra	vendor/stb_image/stb_image.h	/^static const int stbi__zlength_extra[31]=$/;"	v
stbi__zreceive	vendor/stb_image/stb_image.h	/^stbi_inline static unsigned int stbi__zreceive(stbi__zbuf *z, int n)$/;"	f
stbi_convert_iphone_png_to_rgb	vendor/stb_image/stb_image.h	/^STBIDEF void stbi_convert_iphone_png_to_rgb(int flag_true_if_should_convert)$/;"	f
stbi_convert_wchar_to_utf8	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_convert_wchar_to_utf8(char *buffer, size_t bufferlen, const wchar_t* input)$/;"	f
stbi_failure_reason	vendor/stb_image/stb_image.h	/^STBIDEF const char *stbi_failure_reason(void)$/;"	f
stbi_hdr_to_ldr_gamma	vendor/stb_image/stb_image.h	/^STBIDEF void   stbi_hdr_to_ldr_gamma(float gamma) { stbi__h2l_gamma_i = 1\/gamma; }$/;"	f
stbi_hdr_to_ldr_scale	vendor/stb_image/stb_image.h	/^STBIDEF void   stbi_hdr_to_ldr_scale(float scale) { stbi__h2l_scale_i = 1\/scale; }$/;"	f
stbi_image_free	vendor/stb_image/stb_image.h	/^STBIDEF void stbi_image_free(void *retval_from_stbi_load)$/;"	f
stbi_info	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_info(char const *filename, int *x, int *y, int *comp)$/;"	f
stbi_info_from_callbacks	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_info_from_callbacks(stbi_io_callbacks const *c, void *user, int *x, int *y, int *comp)$/;"	f
stbi_info_from_file	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_info_from_file(FILE *f, int *x, int *y, int *comp)$/;"	f
stbi_info_from_memory	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_info_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp)$/;"	f
stbi_inline	vendor/stb_image/stb_image.h	557;"	d
stbi_inline	vendor/stb_image/stb_image.h	559;"	d
stbi_inline	vendor/stb_image/stb_image.h	562;"	d
stbi_io_callbacks	vendor/stb_image/stb_image.h	/^} stbi_io_callbacks;$/;"	t	typeref:struct:__anon55
stbi_is_16_bit	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_is_16_bit(char const *filename)$/;"	f
stbi_is_16_bit_from_callbacks	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_is_16_bit_from_callbacks(stbi_io_callbacks const *c, void *user)$/;"	f
stbi_is_16_bit_from_file	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_is_16_bit_from_file(FILE *f)$/;"	f
stbi_is_16_bit_from_memory	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_is_16_bit_from_memory(stbi_uc const *buffer, int len)$/;"	f
stbi_is_hdr	vendor/stb_image/stb_image.h	/^STBIDEF int      stbi_is_hdr          (char const *filename)$/;"	f
stbi_is_hdr_from_callbacks	vendor/stb_image/stb_image.h	/^STBIDEF int      stbi_is_hdr_from_callbacks(stbi_io_callbacks const *clbk, void *user)$/;"	f
stbi_is_hdr_from_file	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_is_hdr_from_file(FILE *f)$/;"	f
stbi_is_hdr_from_memory	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_is_hdr_from_memory(stbi_uc const *buffer, int len)$/;"	f
stbi_ldr_to_hdr_gamma	vendor/stb_image/stb_image.h	/^STBIDEF void   stbi_ldr_to_hdr_gamma(float gamma) { stbi__l2h_gamma = gamma; }$/;"	f
stbi_ldr_to_hdr_scale	vendor/stb_image/stb_image.h	/^STBIDEF void   stbi_ldr_to_hdr_scale(float scale) { stbi__l2h_scale = scale; }$/;"	f
stbi_load	vendor/stb_image/stb_image.h	/^STBIDEF stbi_uc *stbi_load(char const *filename, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_16	vendor/stb_image/stb_image.h	/^STBIDEF stbi_us *stbi_load_16(char const *filename, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_16_from_callbacks	vendor/stb_image/stb_image.h	/^STBIDEF stbi_us *stbi_load_16_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *channels_in_file, int desired_channels)$/;"	f
stbi_load_16_from_memory	vendor/stb_image/stb_image.h	/^STBIDEF stbi_us *stbi_load_16_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *channels_in_file, int desired_channels)$/;"	f
stbi_load_from_callbacks	vendor/stb_image/stb_image.h	/^STBIDEF stbi_uc *stbi_load_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_from_file	vendor/stb_image/stb_image.h	/^STBIDEF stbi_uc *stbi_load_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_from_file_16	vendor/stb_image/stb_image.h	/^STBIDEF stbi__uint16 *stbi_load_from_file_16(FILE *f, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_from_memory	vendor/stb_image/stb_image.h	/^STBIDEF stbi_uc *stbi_load_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_load_gif_from_memory	vendor/stb_image/stb_image.h	/^STBIDEF stbi_uc *stbi_load_gif_from_memory(stbi_uc const *buffer, int len, int **delays, int *x, int *y, int *z, int *comp, int req_comp)$/;"	f
stbi_loadf	vendor/stb_image/stb_image.h	/^STBIDEF float *stbi_loadf(char const *filename, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_from_callbacks	vendor/stb_image/stb_image.h	/^STBIDEF float *stbi_loadf_from_callbacks(stbi_io_callbacks const *clbk, void *user, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_from_file	vendor/stb_image/stb_image.h	/^STBIDEF float *stbi_loadf_from_file(FILE *f, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_loadf_from_memory	vendor/stb_image/stb_image.h	/^STBIDEF float *stbi_loadf_from_memory(stbi_uc const *buffer, int len, int *x, int *y, int *comp, int req_comp)$/;"	f
stbi_lrot	vendor/stb_image/stb_image.h	593;"	d
stbi_lrot	vendor/stb_image/stb_image.h	595;"	d
stbi_set_flip_vertically_on_load	vendor/stb_image/stb_image.h	/^STBIDEF void stbi_set_flip_vertically_on_load(int flag_true_if_should_flip)$/;"	f
stbi_set_unpremultiply_on_load	vendor/stb_image/stb_image.h	/^STBIDEF void stbi_set_unpremultiply_on_load(int flag_true_if_should_unpremultiply)$/;"	f
stbi_uc	vendor/stb_image/stb_image.h	/^typedef unsigned char stbi_uc;$/;"	t
stbi_us	vendor/stb_image/stb_image.h	/^typedef unsigned short stbi_us;$/;"	t
stbi_zlib_decode_buffer	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_zlib_decode_buffer(char *obuffer, int olen, char const *ibuffer, int ilen)$/;"	f
stbi_zlib_decode_malloc	vendor/stb_image/stb_image.h	/^STBIDEF char *stbi_zlib_decode_malloc(char const *buffer, int len, int *outlen)$/;"	f
stbi_zlib_decode_malloc_guesssize	vendor/stb_image/stb_image.h	/^STBIDEF char *stbi_zlib_decode_malloc_guesssize(const char *buffer, int len, int initial_size, int *outlen)$/;"	f
stbi_zlib_decode_malloc_guesssize_headerflag	vendor/stb_image/stb_image.h	/^STBIDEF char *stbi_zlib_decode_malloc_guesssize_headerflag(const char *buffer, int len, int initial_size, int *outlen, int parse_header)$/;"	f
stbi_zlib_decode_noheader_buffer	vendor/stb_image/stb_image.h	/^STBIDEF int stbi_zlib_decode_noheader_buffer(char *obuffer, int olen, const char *ibuffer, int ilen)$/;"	f
stbi_zlib_decode_noheader_malloc	vendor/stb_image/stb_image.h	/^STBIDEF char *stbi_zlib_decode_noheader_malloc(char const *buffer, int len, int *outlen)$/;"	f
stbrp__findresult	vendor/imgui/imstb_rectpack.h	/^} stbrp__findresult;$/;"	t	typeref:struct:__anon28
stbrp__skyline_find_best_pos	vendor/imgui/imstb_rectpack.h	/^static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context *c, int width, int height)$/;"	f
stbrp__skyline_find_min_y	vendor/imgui/imstb_rectpack.h	/^static int stbrp__skyline_find_min_y(stbrp_context *c, stbrp_node *first, int x0, int width, int *pwaste)$/;"	f
stbrp__skyline_pack_rectangle	vendor/imgui/imstb_rectpack.h	/^static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context *context, int width, int height)$/;"	f
stbrp_context	vendor/imgui/imstb_rectpack.h	/^struct stbrp_context$/;"	s
stbrp_context	vendor/imgui/imstb_rectpack.h	/^typedef struct stbrp_context stbrp_context;$/;"	t	typeref:struct:stbrp_context
stbrp_context	vendor/imgui/imstb_truetype.h	/^} stbrp_context;$/;"	t	typeref:struct:__anon45
stbrp_coord	vendor/imgui/imstb_rectpack.h	/^typedef int            stbrp_coord;$/;"	t
stbrp_coord	vendor/imgui/imstb_rectpack.h	/^typedef unsigned short stbrp_coord;$/;"	t
stbrp_coord	vendor/imgui/imstb_truetype.h	/^typedef int stbrp_coord;$/;"	t
stbrp_init_target	vendor/imgui/imstb_rectpack.h	/^STBRP_DEF void stbrp_init_target(stbrp_context *context, int width, int height, stbrp_node *nodes, int num_nodes)$/;"	f
stbrp_init_target	vendor/imgui/imstb_truetype.h	/^static void stbrp_init_target(stbrp_context *con, int pw, int ph, stbrp_node *nodes, int num_nodes)$/;"	f
stbrp_node	vendor/imgui/imstb_rectpack.h	/^struct stbrp_node$/;"	s
stbrp_node	vendor/imgui/imstb_rectpack.h	/^typedef struct stbrp_node    stbrp_node;$/;"	t	typeref:struct:stbrp_node
stbrp_node	vendor/imgui/imstb_truetype.h	/^} stbrp_node;$/;"	t	typeref:struct:__anon46
stbrp_pack_rects	vendor/imgui/imstb_rectpack.h	/^STBRP_DEF int stbrp_pack_rects(stbrp_context *context, stbrp_rect *rects, int num_rects)$/;"	f
stbrp_pack_rects	vendor/imgui/imstb_truetype.h	/^static void stbrp_pack_rects(stbrp_context *con, stbrp_rect *rects, int num_rects)$/;"	f
stbrp_rect	vendor/imgui/imstb_rectpack.h	/^struct stbrp_rect$/;"	s
stbrp_rect	vendor/imgui/imstb_rectpack.h	/^typedef struct stbrp_rect    stbrp_rect;$/;"	t	typeref:struct:stbrp_rect
stbrp_rect	vendor/imgui/imstb_truetype.h	/^struct stbrp_rect$/;"	s
stbrp_rect	vendor/imgui/imstb_truetype.h	/^typedef struct stbrp_rect stbrp_rect;$/;"	t	typeref:struct:stbrp_rect
stbrp_setup_allow_out_of_mem	vendor/imgui/imstb_rectpack.h	/^STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context *context, int allow_out_of_mem)$/;"	f
stbrp_setup_heuristic	vendor/imgui/imstb_rectpack.h	/^STBRP_DEF void stbrp_setup_heuristic(stbrp_context *context, int heuristic)$/;"	f
stbtt_BakeFontBitmap	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char *data, int offset,$/;"	f
stbtt_BakeFontBitmap_internal	vendor/imgui/imstb_truetype.h	/^static int stbtt_BakeFontBitmap_internal(unsigned char *data, int offset,  \/\/ font location (use offset=0 for plain .ttf)$/;"	f
stbtt_CompareUTF8toUTF16_bigendian	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char *s1, int len1, const char *s2, int len2)$/;"	f
stbtt_CompareUTF8toUTF16_bigendian_internal	vendor/imgui/imstb_truetype.h	/^static int stbtt_CompareUTF8toUTF16_bigendian_internal(char *s1, int len1, char *s2, int len2) $/;"	f
stbtt_FindGlyphIndex	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo *info, int unicode_codepoint)$/;"	f
stbtt_FindMatchingFont	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_FindMatchingFont(const unsigned char *fontdata, const char *name, int flags)$/;"	f
stbtt_FindMatchingFont_internal	vendor/imgui/imstb_truetype.h	/^static int stbtt_FindMatchingFont_internal(unsigned char *font_collection, char *name_utf8, stbtt_int32 flags)$/;"	f
stbtt_FlattenCurves	vendor/imgui/imstb_truetype.h	/^static stbtt__point *stbtt_FlattenCurves(stbtt_vertex *vertices, int num_verts, float objspace_flatness, int **contour_lengths, int *num_contours, void *userdata)$/;"	f
stbtt_FreeBitmap	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_FreeBitmap(unsigned char *bitmap, void *userdata)$/;"	f
stbtt_FreeSDF	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_FreeSDF(unsigned char *bitmap, void *userdata)$/;"	f
stbtt_FreeShape	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo *info, stbtt_vertex *v)$/;"	f
stbtt_GetBakedQuad	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetBakedQuad(const stbtt_bakedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int opengl_fillrule)$/;"	f
stbtt_GetCodepointBitmap	vendor/imgui/imstb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetCodepointBitmapBox	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetCodepointBitmapBoxSubpixel	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo *font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetCodepointBitmapSubpixel	vendor/imgui/imstb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetCodepointBox	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo *info, int codepoint, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetCodepointHMetrics	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo *info, int codepoint, int *advanceWidth, int *leftSideBearing)$/;"	f
stbtt_GetCodepointKernAdvance	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo *info, int ch1, int ch2)$/;"	f
stbtt_GetCodepointSDF	vendor/imgui/imstb_truetype.h	/^STBTT_DEF unsigned char * stbtt_GetCodepointSDF(const stbtt_fontinfo *info, float scale, int codepoint, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetCodepointShape	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo *info, int unicode_codepoint, stbtt_vertex **vertices)$/;"	f
stbtt_GetFontBoundingBox	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo *info, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetFontNameString	vendor/imgui/imstb_truetype.h	/^STBTT_DEF const char *stbtt_GetFontNameString(const stbtt_fontinfo *font, int *length, int platformID, int encodingID, int languageID, int nameID)$/;"	f
stbtt_GetFontOffsetForIndex	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char *data, int index)$/;"	f
stbtt_GetFontOffsetForIndex_internal	vendor/imgui/imstb_truetype.h	/^static int stbtt_GetFontOffsetForIndex_internal(unsigned char *font_collection, int index)$/;"	f
stbtt_GetFontVMetrics	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo *info, int *ascent, int *descent, int *lineGap)$/;"	f
stbtt_GetFontVMetricsOS2	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int  stbtt_GetFontVMetricsOS2(const stbtt_fontinfo *info, int *typoAscent, int *typoDescent, int *typoLineGap)$/;"	f
stbtt_GetGlyphBitmap	vendor/imgui/imstb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmap(const stbtt_fontinfo *info, float scale_x, float scale_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetGlyphBitmapBox	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetGlyphBitmapBoxSubpixel	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo *font, int glyph, float scale_x, float scale_y,float shift_x, float shift_y, int *ix0, int *iy0, int *ix1, int *iy1)$/;"	f
stbtt_GetGlyphBitmapSubpixel	vendor/imgui/imstb_truetype.h	/^STBTT_DEF unsigned char *stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo *info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetGlyphBox	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt_GetGlyphHMetrics	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo *info, int glyph_index, int *advanceWidth, int *leftSideBearing)$/;"	f
stbtt_GetGlyphKernAdvance	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo *info, int g1, int g2)$/;"	f
stbtt_GetGlyphSDF	vendor/imgui/imstb_truetype.h	/^STBTT_DEF unsigned char * stbtt_GetGlyphSDF(const stbtt_fontinfo *info, float scale, int glyph, int padding, unsigned char onedge_value, float pixel_dist_scale, int *width, int *height, int *xoff, int *yoff)$/;"	f
stbtt_GetGlyphShape	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f
stbtt_GetNumberOfFonts	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char *data)$/;"	f
stbtt_GetNumberOfFonts_internal	vendor/imgui/imstb_truetype.h	/^static int stbtt_GetNumberOfFonts_internal(unsigned char *font_collection)$/;"	f
stbtt_GetPackedQuad	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetPackedQuad(const stbtt_packedchar *chardata, int pw, int ph, int char_index, float *xpos, float *ypos, stbtt_aligned_quad *q, int align_to_integer)$/;"	f
stbtt_GetScaledFontVMetrics	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_GetScaledFontVMetrics(const unsigned char *fontdata, int index, float size, float *ascent, float *descent, float *lineGap)$/;"	f
stbtt_InitFont	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_InitFont(stbtt_fontinfo *info, const unsigned char *data, int offset)$/;"	f
stbtt_InitFont_internal	vendor/imgui/imstb_truetype.h	/^static int stbtt_InitFont_internal(stbtt_fontinfo *info, unsigned char *data, int fontstart)$/;"	f
stbtt_IsGlyphEmpty	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo *info, int glyph_index)$/;"	f
stbtt_MakeCodepointBitmap	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)$/;"	f
stbtt_MakeCodepointBitmapSubpixel	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)$/;"	f
stbtt_MakeCodepointBitmapSubpixelPrefilter	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_MakeCodepointBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int oversample_x, int oversample_y, float *sub_x, float *sub_y, int codepoint)$/;"	f
stbtt_MakeGlyphBitmap	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)$/;"	f
stbtt_MakeGlyphBitmapSubpixel	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)$/;"	f
stbtt_MakeGlyphBitmapSubpixelPrefilter	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_MakeGlyphBitmapSubpixelPrefilter(const stbtt_fontinfo *info, unsigned char *output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int prefilter_x, int prefilter_y, float *sub_x, float *sub_y, int glyph)$/;"	f
stbtt_PackBegin	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_PackBegin(stbtt_pack_context *spc, unsigned char *pixels, int pw, int ph, int stride_in_bytes, int padding, void *alloc_context)$/;"	f
stbtt_PackEnd	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_PackEnd  (stbtt_pack_context *spc)$/;"	f
stbtt_PackFontRange	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, float font_size,$/;"	f
stbtt_PackFontRanges	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context *spc, const unsigned char *fontdata, int font_index, stbtt_pack_range *ranges, int num_ranges)$/;"	f
stbtt_PackFontRangesGatherRects	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)$/;"	f
stbtt_PackFontRangesPackRects	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context *spc, stbrp_rect *rects, int num_rects)$/;"	f
stbtt_PackFontRangesRenderIntoRects	vendor/imgui/imstb_truetype.h	/^STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context *spc, const stbtt_fontinfo *info, stbtt_pack_range *ranges, int num_ranges, stbrp_rect *rects)$/;"	f
stbtt_PackSetOversampling	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context *spc, unsigned int h_oversample, unsigned int v_oversample)$/;"	f
stbtt_PackSetSkipMissingCodepoints	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_PackSetSkipMissingCodepoints(stbtt_pack_context *spc, int skip)$/;"	f
stbtt_Rasterize	vendor/imgui/imstb_truetype.h	/^STBTT_DEF void stbtt_Rasterize(stbtt__bitmap *result, float flatness_in_pixels, stbtt_vertex *vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void *userdata)$/;"	f
stbtt_ScaleForMappingEmToPixels	vendor/imgui/imstb_truetype.h	/^STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo *info, float pixels)$/;"	f
stbtt_ScaleForPixelHeight	vendor/imgui/imstb_truetype.h	/^STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo *info, float height)$/;"	f
stbtt__CompareUTF8toUTF16_bigendian_prefix	vendor/imgui/imstb_truetype.h	/^static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8 *s1, stbtt_int32 len1, stbtt_uint8 *s2, stbtt_int32 len2) $/;"	f
stbtt__GetCoverageIndex	vendor/imgui/imstb_truetype.h	/^static stbtt_int32  stbtt__GetCoverageIndex(stbtt_uint8 *coverageTable, int glyph)$/;"	f
stbtt__GetGlyfOffset	vendor/imgui/imstb_truetype.h	/^static int stbtt__GetGlyfOffset(const stbtt_fontinfo *info, int glyph_index)$/;"	f
stbtt__GetGlyphClass	vendor/imgui/imstb_truetype.h	/^static stbtt_int32  stbtt__GetGlyphClass(stbtt_uint8 *classDefTable, int glyph)$/;"	f
stbtt__GetGlyphGPOSInfoAdvance	vendor/imgui/imstb_truetype.h	/^static stbtt_int32  stbtt__GetGlyphGPOSInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)$/;"	f
stbtt__GetGlyphInfoT2	vendor/imgui/imstb_truetype.h	/^static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo *info, int glyph_index, int *x0, int *y0, int *x1, int *y1)$/;"	f
stbtt__GetGlyphKernInfoAdvance	vendor/imgui/imstb_truetype.h	/^static int  stbtt__GetGlyphKernInfoAdvance(const stbtt_fontinfo *info, int glyph1, int glyph2)$/;"	f
stbtt__GetGlyphShapeT2	vendor/imgui/imstb_truetype.h	/^static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f
stbtt__GetGlyphShapeTT	vendor/imgui/imstb_truetype.h	/^static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo *info, int glyph_index, stbtt_vertex **pvertices)$/;"	f
stbtt__active_edge	vendor/imgui/imstb_truetype.h	/^typedef struct stbtt__active_edge$/;"	s
stbtt__active_edge	vendor/imgui/imstb_truetype.h	/^} stbtt__active_edge;$/;"	t	typeref:struct:stbtt__active_edge
stbtt__add_point	vendor/imgui/imstb_truetype.h	/^static void stbtt__add_point(stbtt__point *points, int n, float x, float y)$/;"	f
stbtt__bitmap	vendor/imgui/imstb_truetype.h	/^} stbtt__bitmap;$/;"	t	typeref:struct:__anon36
stbtt__buf	vendor/imgui/imstb_truetype.h	/^} stbtt__buf;$/;"	t	typeref:struct:__anon29
stbtt__buf_get	vendor/imgui/imstb_truetype.h	/^static stbtt_uint32 stbtt__buf_get(stbtt__buf *b, int n)$/;"	f
stbtt__buf_get16	vendor/imgui/imstb_truetype.h	1161;"	d
stbtt__buf_get32	vendor/imgui/imstb_truetype.h	1162;"	d
stbtt__buf_get8	vendor/imgui/imstb_truetype.h	/^static stbtt_uint8 stbtt__buf_get8(stbtt__buf *b)$/;"	f
stbtt__buf_peek8	vendor/imgui/imstb_truetype.h	/^static stbtt_uint8 stbtt__buf_peek8(stbtt__buf *b)$/;"	f
stbtt__buf_range	vendor/imgui/imstb_truetype.h	/^static stbtt__buf stbtt__buf_range(const stbtt__buf *b, int o, int s)$/;"	f
stbtt__buf_seek	vendor/imgui/imstb_truetype.h	/^static void stbtt__buf_seek(stbtt__buf *b, int o)$/;"	f
stbtt__buf_skip	vendor/imgui/imstb_truetype.h	/^static void stbtt__buf_skip(stbtt__buf *b, int o)$/;"	f
stbtt__cff_get_index	vendor/imgui/imstb_truetype.h	/^static stbtt__buf stbtt__cff_get_index(stbtt__buf *b)$/;"	f
stbtt__cff_index_count	vendor/imgui/imstb_truetype.h	/^static int stbtt__cff_index_count(stbtt__buf *b)$/;"	f
stbtt__cff_index_get	vendor/imgui/imstb_truetype.h	/^static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)$/;"	f
stbtt__cff_int	vendor/imgui/imstb_truetype.h	/^static stbtt_uint32 stbtt__cff_int(stbtt__buf *b)$/;"	f
stbtt__cff_skip_operand	vendor/imgui/imstb_truetype.h	/^static void stbtt__cff_skip_operand(stbtt__buf *b) {$/;"	f
stbtt__check_size16	vendor/imgui/imstb_truetype.h	/^   typedef char stbtt__check_size16[sizeof(stbtt_int16)==2 ? 1 : -1];$/;"	t
stbtt__check_size32	vendor/imgui/imstb_truetype.h	/^   typedef char stbtt__check_size32[sizeof(stbtt_int32)==4 ? 1 : -1];$/;"	t
stbtt__cid_get_glyph_subrs	vendor/imgui/imstb_truetype.h	/^static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo *info, int glyph_index)$/;"	f
stbtt__close_shape	vendor/imgui/imstb_truetype.h	/^static int stbtt__close_shape(stbtt_vertex *vertices, int num_vertices, int was_off, int start_off,$/;"	f
stbtt__compute_crossings_x	vendor/imgui/imstb_truetype.h	/^static int stbtt__compute_crossings_x(float x, float y, int nverts, stbtt_vertex *verts)$/;"	f
stbtt__csctx	vendor/imgui/imstb_truetype.h	/^} stbtt__csctx;$/;"	t	typeref:struct:__anon43
stbtt__csctx_close_shape	vendor/imgui/imstb_truetype.h	/^static void stbtt__csctx_close_shape(stbtt__csctx *ctx)$/;"	f
stbtt__csctx_rccurve_to	vendor/imgui/imstb_truetype.h	/^static void stbtt__csctx_rccurve_to(stbtt__csctx *ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)$/;"	f
stbtt__csctx_rline_to	vendor/imgui/imstb_truetype.h	/^static void stbtt__csctx_rline_to(stbtt__csctx *ctx, float dx, float dy)$/;"	f
stbtt__csctx_rmove_to	vendor/imgui/imstb_truetype.h	/^static void stbtt__csctx_rmove_to(stbtt__csctx *ctx, float dx, float dy)$/;"	f
stbtt__csctx_v	vendor/imgui/imstb_truetype.h	/^static void stbtt__csctx_v(stbtt__csctx *c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)$/;"	f
stbtt__cuberoot	vendor/imgui/imstb_truetype.h	/^static float stbtt__cuberoot( float x )$/;"	f
stbtt__dict_get	vendor/imgui/imstb_truetype.h	/^static stbtt__buf stbtt__dict_get(stbtt__buf *b, int key)$/;"	f
stbtt__dict_get_ints	vendor/imgui/imstb_truetype.h	/^static void stbtt__dict_get_ints(stbtt__buf *b, int key, int outcount, stbtt_uint32 *out)$/;"	f
stbtt__edge	vendor/imgui/imstb_truetype.h	/^typedef struct stbtt__edge {$/;"	s
stbtt__edge	vendor/imgui/imstb_truetype.h	/^} stbtt__edge;$/;"	t	typeref:struct:stbtt__edge
stbtt__fill_active_edges	vendor/imgui/imstb_truetype.h	/^static void stbtt__fill_active_edges(unsigned char *scanline, int len, stbtt__active_edge *e, int max_weight)$/;"	f
stbtt__fill_active_edges_new	vendor/imgui/imstb_truetype.h	/^static void stbtt__fill_active_edges_new(float *scanline, float *scanline_fill, int len, stbtt__active_edge *e, float y_top)$/;"	f
stbtt__find_table	vendor/imgui/imstb_truetype.h	/^static stbtt_uint32 stbtt__find_table(stbtt_uint8 *data, stbtt_uint32 fontstart, const char *tag)$/;"	f
stbtt__get_subr	vendor/imgui/imstb_truetype.h	/^static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)$/;"	f
stbtt__get_subrs	vendor/imgui/imstb_truetype.h	/^static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)$/;"	f
stbtt__h_prefilter	vendor/imgui/imstb_truetype.h	/^static void stbtt__h_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)$/;"	f
stbtt__handle_clipped_edge	vendor/imgui/imstb_truetype.h	/^static void stbtt__handle_clipped_edge(float *scanline, int x, stbtt__active_edge *e, float x0, float y0, float x1, float y1)$/;"	f
stbtt__hheap	vendor/imgui/imstb_truetype.h	/^typedef struct stbtt__hheap$/;"	s
stbtt__hheap	vendor/imgui/imstb_truetype.h	/^} stbtt__hheap;$/;"	t	typeref:struct:stbtt__hheap
stbtt__hheap_alloc	vendor/imgui/imstb_truetype.h	/^static void *stbtt__hheap_alloc(stbtt__hheap *hh, size_t size, void *userdata)$/;"	f
stbtt__hheap_chunk	vendor/imgui/imstb_truetype.h	/^typedef struct stbtt__hheap_chunk$/;"	s
stbtt__hheap_chunk	vendor/imgui/imstb_truetype.h	/^} stbtt__hheap_chunk;$/;"	t	typeref:struct:stbtt__hheap_chunk
stbtt__hheap_cleanup	vendor/imgui/imstb_truetype.h	/^static void stbtt__hheap_cleanup(stbtt__hheap *hh, void *userdata)$/;"	f
stbtt__hheap_free	vendor/imgui/imstb_truetype.h	/^static void stbtt__hheap_free(stbtt__hheap *hh, void *p)$/;"	f
stbtt__isfont	vendor/imgui/imstb_truetype.h	/^static int stbtt__isfont(stbtt_uint8 *font)$/;"	f
stbtt__matches	vendor/imgui/imstb_truetype.h	/^static int stbtt__matches(stbtt_uint8 *fc, stbtt_uint32 offset, stbtt_uint8 *name, stbtt_int32 flags)$/;"	f
stbtt__matchpair	vendor/imgui/imstb_truetype.h	/^static int stbtt__matchpair(stbtt_uint8 *fc, stbtt_uint32 nm, stbtt_uint8 *name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)$/;"	f
stbtt__new_active	vendor/imgui/imstb_truetype.h	/^static stbtt__active_edge *stbtt__new_active(stbtt__hheap *hh, stbtt__edge *e, int off_x, float start_point, void *userdata)$/;"	f
stbtt__new_buf	vendor/imgui/imstb_truetype.h	/^static stbtt__buf stbtt__new_buf(const void *p, size_t size)$/;"	f
stbtt__oversample_shift	vendor/imgui/imstb_truetype.h	/^static float stbtt__oversample_shift(int oversample)$/;"	f
stbtt__point	vendor/imgui/imstb_truetype.h	/^} stbtt__point;$/;"	t	typeref:struct:__anon44
stbtt__rasterize	vendor/imgui/imstb_truetype.h	/^static void stbtt__rasterize(stbtt__bitmap *result, stbtt__point *pts, int *wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void *userdata)$/;"	f
stbtt__rasterize_sorted_edges	vendor/imgui/imstb_truetype.h	/^static void stbtt__rasterize_sorted_edges(stbtt__bitmap *result, stbtt__edge *e, int n, int vsubsample, int off_x, int off_y, void *userdata)$/;"	f
stbtt__ray_intersect_bezier	vendor/imgui/imstb_truetype.h	/^static int stbtt__ray_intersect_bezier(float orig[2], float ray[2], float q0[2], float q1[2], float q2[2], float hits[2][2])$/;"	f
stbtt__run_charstring	vendor/imgui/imstb_truetype.h	/^static int stbtt__run_charstring(const stbtt_fontinfo *info, int glyph_index, stbtt__csctx *c)$/;"	f
stbtt__solve_cubic	vendor/imgui/imstb_truetype.h	/^static int stbtt__solve_cubic(float a, float b, float c, float* r)$/;"	f
stbtt__sort_edges	vendor/imgui/imstb_truetype.h	/^static void stbtt__sort_edges(stbtt__edge *p, int n)$/;"	f
stbtt__sort_edges_ins_sort	vendor/imgui/imstb_truetype.h	/^static void stbtt__sort_edges_ins_sort(stbtt__edge *p, int n)$/;"	f
stbtt__sort_edges_quicksort	vendor/imgui/imstb_truetype.h	/^static void stbtt__sort_edges_quicksort(stbtt__edge *p, int n)$/;"	f
stbtt__tesselate_cubic	vendor/imgui/imstb_truetype.h	/^static void stbtt__tesselate_cubic(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)$/;"	f
stbtt__tesselate_curve	vendor/imgui/imstb_truetype.h	/^static int stbtt__tesselate_curve(stbtt__point *points, int *num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)$/;"	f
stbtt__test_oversample_pow2	vendor/imgui/imstb_truetype.h	/^typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE-1)) == 0 ? 1 : -1];$/;"	t
stbtt__track_vertex	vendor/imgui/imstb_truetype.h	/^static void stbtt__track_vertex(stbtt__csctx *c, stbtt_int32 x, stbtt_int32 y)$/;"	f
stbtt__v_prefilter	vendor/imgui/imstb_truetype.h	/^static void stbtt__v_prefilter(unsigned char *pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)$/;"	f
stbtt_aligned_quad	vendor/imgui/imstb_truetype.h	/^} stbtt_aligned_quad;$/;"	t	typeref:struct:__anon31
stbtt_bakedchar	vendor/imgui/imstb_truetype.h	/^} stbtt_bakedchar;$/;"	t	typeref:struct:__anon30
stbtt_fontinfo	vendor/imgui/imstb_truetype.h	/^struct stbtt_fontinfo$/;"	s
stbtt_fontinfo	vendor/imgui/imstb_truetype.h	/^typedef struct stbtt_fontinfo stbtt_fontinfo;$/;"	t	typeref:struct:stbtt_fontinfo
stbtt_int16	vendor/imgui/imstb_truetype.h	/^   typedef signed   short  stbtt_int16;$/;"	t
stbtt_int32	vendor/imgui/imstb_truetype.h	/^   typedef signed   int    stbtt_int32;$/;"	t
stbtt_int8	vendor/imgui/imstb_truetype.h	/^   typedef signed   char   stbtt_int8;$/;"	t
stbtt_pack_context	vendor/imgui/imstb_truetype.h	/^struct stbtt_pack_context {$/;"	s
stbtt_pack_context	vendor/imgui/imstb_truetype.h	/^typedef struct stbtt_pack_context stbtt_pack_context;$/;"	t	typeref:struct:stbtt_pack_context
stbtt_pack_range	vendor/imgui/imstb_truetype.h	/^} stbtt_pack_range;$/;"	t	typeref:struct:__anon33
stbtt_packedchar	vendor/imgui/imstb_truetype.h	/^} stbtt_packedchar;$/;"	t	typeref:struct:__anon32
stbtt_setvertex	vendor/imgui/imstb_truetype.h	/^static void stbtt_setvertex(stbtt_vertex *v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)$/;"	f
stbtt_tag	vendor/imgui/imstb_truetype.h	1275;"	d
stbtt_tag4	vendor/imgui/imstb_truetype.h	1274;"	d
stbtt_uint16	vendor/imgui/imstb_truetype.h	/^   typedef unsigned short  stbtt_uint16;$/;"	t
stbtt_uint32	vendor/imgui/imstb_truetype.h	/^   typedef unsigned int    stbtt_uint32;$/;"	t
stbtt_uint8	vendor/imgui/imstb_truetype.h	/^   typedef unsigned char   stbtt_uint8;$/;"	t
stbtt_vertex	vendor/imgui/imstb_truetype.h	/^   } stbtt_vertex;$/;"	t	typeref:struct:__anon35
stbtt_vertex_type	vendor/imgui/imstb_truetype.h	823;"	d
std	vendor/glm/gtx/hash.hpp	/^namespace std$/;"	n
step	vendor/stb_image/stb_image.h	/^   int parse, step;$/;"	m	struct:__anon72
storage	vendor/glm/detail/qualifier.hpp	/^		struct storage<3, T, true>$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^		struct storage<L, T, true>$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^	struct storage$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^	struct storage<2, detail::int64, true>$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^	struct storage<2, detail::uint64, true>$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^	struct storage<2, double, true>$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^	struct storage<4, detail::int64, true>$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^	struct storage<4, detail::uint64, true>$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^	struct storage<4, double, true>$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^	struct storage<4, float, true>$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^	struct storage<4, int, true>$/;"	s	namespace:glm::detail
storage	vendor/glm/detail/qualifier.hpp	/^	struct storage<4, unsigned int, true>$/;"	s	namespace:glm::detail
streamsize_type	vendor/glm/gtx/io.hpp	/^			typedef ::std::streamsize              streamsize_type;$/;"	t	class:glm::io::basic_state_saver
stride	VertexBufferLayout/VertexBufferLayout.h	/^	unsigned int stride;$/;"	m	class:VertexBufferLayout
stride	vendor/imgui/imstb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon36
stride_in_bytes	vendor/imgui/imstb_truetype.h	/^   int   stride_in_bytes;$/;"	m	struct:stbtt_pack_context
subrs	vendor/imgui/imstb_truetype.h	/^   stbtt__buf subrs;                  \/\/ private charstring subroutines index$/;"	m	struct:stbtt_fontinfo
succ_high	vendor/stb_image/stb_image.h	/^   int            succ_high;$/;"	m	struct:__anon61
succ_low	vendor/stb_image/stb_image.h	/^   int            succ_low;$/;"	m	struct:__anon61
suffix	vendor/stb_image/stb_image.h	/^   stbi_uc suffix;$/;"	m	struct:__anon71
swap	vendor/imgui/imgui.h	/^    inline void         swap(ImVector<T>& rhs)              { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; T* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }$/;"	f	struct:ImVector
sy	vendor/imgui/imstb_truetype.h	/^   float sy;$/;"	m	struct:stbtt__active_edge
t	vendor/glm/detail/type_vec2.hpp	/^				struct{ T s, t; };$/;"	m	struct:glm::vec::__anon10::__anon13
t	vendor/glm/detail/type_vec2.hpp	/^			union {T y, g, t;};$/;"	m	union:glm::vec::__anon15
t	vendor/glm/detail/type_vec3.hpp	/^				struct{ T s, t, p; };$/;"	m	struct:glm::vec::__anon3::__anon6
t	vendor/glm/detail/type_vec3.hpp	/^			union { T y, g, t; };$/;"	m	union:glm::vec::__anon8
t	vendor/glm/detail/type_vec4.hpp	/^				struct { T s, t, p, q; };$/;"	m	struct:glm::vec::__anon18::__anon21
t	vendor/glm/detail/type_vec4.hpp	/^			union { T y, g, t; };$/;"	m	union:glm::vec::__anon23
t0	vendor/imgui/imstb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon31
t1	vendor/imgui/imstb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon31
taylorInvSqrt	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER T taylorInvSqrt(T const& r)$/;"	f	namespace:glm::detail
taylorInvSqrt	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER vec<2, T, Q> taylorInvSqrt(vec<2, T, Q> const& r)$/;"	f	namespace:glm::detail
taylorInvSqrt	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER vec<3, T, Q> taylorInvSqrt(vec<3, T, Q> const& r)$/;"	f	namespace:glm::detail
taylorInvSqrt	vendor/glm/detail/_noise.hpp	/^	GLM_FUNC_QUALIFIER vec<4, T, Q> taylorInvSqrt(vec<4, T, Q> const& r)$/;"	f	namespace:glm::detail
tdualquat	vendor/glm/gtx/dual_quaternion.hpp	/^	struct tdualquat$/;"	s	namespace:glm
temp_bitmap	vendor/imgui/imstb_truetype.h	/^unsigned char temp_bitmap[512*512];$/;"	v
test	vendor/glm/detail/setup.hpp	/^		enum test {value = 0};$/;"	g	struct:glm::detail::is_int
test	vendor/glm/detail/setup.hpp	/^		enum test {value = ~0};$/;"	g	struct:glm::detail::is_int
test	vendor/glm/ext/scalar_int_sized.hpp	/^		enum test {value = ~0};$/;"	g	struct:glm::detail::is_int
test	vendor/glm/ext/scalar_uint_sized.hpp	/^		enum test {value = ~0};$/;"	g	struct:glm::detail::is_int
toMat3	vendor/glm/gtx/quaternion.hpp	/^	GLM_FUNC_DECL mat<3, 3, T, Q> toMat3($/;"	f	namespace:glm
toMat4	vendor/glm/gtx/quaternion.hpp	/^	GLM_FUNC_DECL mat<4, 4, T, Q> toMat4($/;"	f	namespace:glm
toQuat	vendor/glm/gtx/quaternion.hpp	/^	GLM_FUNC_DECL qua<T, Q> toQuat($/;"	f	namespace:glm
todo	vendor/stb_image/stb_image.h	/^   int restart_interval, todo;$/;"	m	struct:__anon61
tq	vendor/stb_image/stb_image.h	/^      int tq;$/;"	m	struct:__anon61::__anon62
transparent	vendor/stb_image/stb_image.h	/^   int flags, bgindex, ratio, transparent, eflags;$/;"	m	struct:__anon72
transpose_type	vendor/glm/detail/type_mat2x2.hpp	/^		typedef mat<2, 2, T, Q> transpose_type;$/;"	t	struct:glm::mat
transpose_type	vendor/glm/detail/type_mat2x3.hpp	/^		typedef mat<3, 2, T, Q> transpose_type;$/;"	t	struct:glm::mat
transpose_type	vendor/glm/detail/type_mat2x4.hpp	/^		typedef mat<4, 2, T, Q> transpose_type;$/;"	t	struct:glm::mat
transpose_type	vendor/glm/detail/type_mat3x2.hpp	/^		typedef mat<2, 3, T, Q> transpose_type;$/;"	t	struct:glm::mat
transpose_type	vendor/glm/detail/type_mat3x3.hpp	/^		typedef mat<3, 3, T, Q> transpose_type;$/;"	t	struct:glm::mat
transpose_type	vendor/glm/detail/type_mat3x4.hpp	/^		typedef mat<4, 3, T, Q> transpose_type;$/;"	t	struct:glm::mat
transpose_type	vendor/glm/detail/type_mat4x2.hpp	/^		typedef mat<2, 4, T, Q> transpose_type;$/;"	t	struct:glm::mat
transpose_type	vendor/glm/detail/type_mat4x3.hpp	/^		typedef mat<3, 4, T, Q> transpose_type;$/;"	t	struct:glm::mat
transpose_type	vendor/glm/detail/type_mat4x4.hpp	/^		typedef mat<4, 4, T, Q> transpose_type;$/;"	t	struct:glm::mat
ttBYTE	vendor/imgui/imstb_truetype.h	1265;"	d
ttCHAR	vendor/imgui/imstb_truetype.h	1266;"	d
ttFixed	vendor/imgui/imstb_truetype.h	1267;"	d
ttLONG	vendor/imgui/imstb_truetype.h	/^static stbtt_int32 ttLONG(stbtt_uint8 *p)    { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f
ttSHORT	vendor/imgui/imstb_truetype.h	/^static stbtt_int16 ttSHORT(stbtt_uint8 *p)   { return p[0]*256 + p[1]; }$/;"	f
ttULONG	vendor/imgui/imstb_truetype.h	/^static stbtt_uint32 ttULONG(stbtt_uint8 *p)  { return (p[0]<<24) + (p[1]<<16) + (p[2]<<8) + p[3]; }$/;"	f
ttUSHORT	vendor/imgui/imstb_truetype.h	/^static stbtt_uint16 ttUSHORT(stbtt_uint8 *p) { return p[0]*256 + p[1]; }$/;"	f
ttf_buffer	vendor/imgui/imstb_truetype.h	/^char ttf_buffer[1<<25];$/;"	v
ttf_buffer	vendor/imgui/imstb_truetype.h	/^unsigned char ttf_buffer[1<<20];$/;"	v
type	VertexBufferLayout/VertexBufferLayout.h	/^	unsigned int type;$/;"	m	struct:VertexBufferLayoutElement
type	vendor/glm/detail/qualifier.hpp	/^			typedef struct alignas(L * sizeof(T)) type {$/;"	s	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^			} type;$/;"	m	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^			} type;$/;"	t	struct:glm::detail::storage	typeref:struct:glm::detail::storage::type
type	vendor/glm/detail/qualifier.hpp	/^		typedef glm_f32vec4 type;$/;"	t	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^		typedef glm_f64vec2 type;$/;"	t	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^		typedef glm_f64vec4 type;$/;"	t	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^		typedef glm_i32vec4 type;$/;"	t	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^		typedef glm_i64vec2 type;$/;"	t	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^		typedef glm_i64vec4 type;$/;"	t	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^		typedef glm_u32vec4 type;$/;"	t	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^		typedef glm_u64vec2 type;$/;"	t	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^		typedef glm_u64vec4 type;$/;"	t	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^		typedef struct type {$/;"	s	struct:glm::detail::storage
type	vendor/glm/detail/qualifier.hpp	/^		} type;$/;"	t	struct:glm::detail::storage	typeref:struct:glm::detail::storage::type
type	vendor/glm/detail/type_mat2x2.hpp	/^		typedef mat<2, 2, T, Q> type;$/;"	t	struct:glm::mat
type	vendor/glm/detail/type_mat2x3.hpp	/^		typedef mat<2, 3, T, Q> type;$/;"	t	struct:glm::mat
type	vendor/glm/detail/type_mat2x4.hpp	/^		typedef mat<2, 4, T, Q> type;$/;"	t	struct:glm::mat
type	vendor/glm/detail/type_mat3x2.hpp	/^		typedef mat<3, 2, T, Q> type;$/;"	t	struct:glm::mat
type	vendor/glm/detail/type_mat3x3.hpp	/^		typedef mat<3, 3, T, Q> type;$/;"	t	struct:glm::mat
type	vendor/glm/detail/type_mat3x4.hpp	/^		typedef mat<3, 4, T, Q> type;$/;"	t	struct:glm::mat
type	vendor/glm/detail/type_mat4x2.hpp	/^		typedef mat<4, 2, T, Q> type;$/;"	t	struct:glm::mat
type	vendor/glm/detail/type_mat4x3.hpp	/^		typedef mat<4, 3, T, Q> type;$/;"	t	struct:glm::mat
type	vendor/glm/detail/type_mat4x4.hpp	/^		typedef mat<4, 4, T, Q> type;$/;"	t	struct:glm::mat
type	vendor/glm/detail/type_quat.hpp	/^		typedef qua<T, Q> type;$/;"	t	struct:glm::qua
type	vendor/glm/detail/type_vec1.hpp	/^		typedef vec<1, T, Q> type;$/;"	t	struct:glm::vec
type	vendor/glm/detail/type_vec2.hpp	/^		typedef vec<2, T, Q> type;$/;"	t	struct:glm::vec
type	vendor/glm/detail/type_vec3.hpp	/^		typedef vec<3, T, Q> type;$/;"	t	struct:glm::vec
type	vendor/glm/detail/type_vec4.hpp	/^		typedef vec<4, T, Q> type;$/;"	t	struct:glm::vec
type	vendor/glm/gtx/type_trait.hpp	/^	struct type$/;"	s	namespace:glm
type	vendor/glm/gtx/type_trait.hpp	/^	struct type<mat<C, R, T, Q> >$/;"	s	namespace:glm
type	vendor/glm/gtx/type_trait.hpp	/^	struct type<qua<T, Q> >$/;"	s	namespace:glm
type	vendor/glm/gtx/type_trait.hpp	/^	struct type<tdualquat<T, Q> >$/;"	s	namespace:glm
type	vendor/glm/gtx/type_trait.hpp	/^	struct type<vec<L, T, Q> >$/;"	s	namespace:glm
type	vendor/glm/matrix.hpp	/^		typedef mat<2, 2, T, Q> type;$/;"	t	struct:glm::detail::outerProduct_trait
type	vendor/glm/matrix.hpp	/^		typedef mat<2, 3, T, Q> type;$/;"	t	struct:glm::detail::outerProduct_trait
type	vendor/glm/matrix.hpp	/^		typedef mat<2, 4, T, Q> type;$/;"	t	struct:glm::detail::outerProduct_trait
type	vendor/glm/matrix.hpp	/^		typedef mat<3, 2, T, Q> type;$/;"	t	struct:glm::detail::outerProduct_trait
type	vendor/glm/matrix.hpp	/^		typedef mat<3, 3, T, Q> type;$/;"	t	struct:glm::detail::outerProduct_trait
type	vendor/glm/matrix.hpp	/^		typedef mat<3, 4, T, Q> type;$/;"	t	struct:glm::detail::outerProduct_trait
type	vendor/glm/matrix.hpp	/^		typedef mat<4, 2, T, Q> type;$/;"	t	struct:glm::detail::outerProduct_trait
type	vendor/glm/matrix.hpp	/^		typedef mat<4, 3, T, Q> type;$/;"	t	struct:glm::detail::outerProduct_trait
type	vendor/glm/matrix.hpp	/^		typedef mat<4, 4, T, Q> type;$/;"	t	struct:glm::detail::outerProduct_trait
type	vendor/imgui/imstb_truetype.h	/^      unsigned char type,padding;$/;"	m	struct:__anon35
type	vendor/stb_image/stb_image.h	/^   stbi__uint32 type;$/;"	m	struct:__anon66
type	vendor/stb_image/stb_image.h	/^   stbi_uc size,type,channel;$/;"	m	struct:__anon70
u16	vendor/glm/fwd.hpp	/^	typedef uint16					u16;$/;"	t	namespace:glm
u16	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint16 u16;$/;"	t	namespace:glm
u16vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u16, defaultp>	u16vec1;$/;"	t	namespace:glm
u16vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u16, defaultp> u16vec1;$/;"	t	namespace:glm
u16vec1	vendor/glm/gtx/number_precision.hpp	/^	typedef u16			u16vec1;    \/\/!< \\brief 16bit unsigned integer scalar. (from GLM_GTX_number_precision extension)$/;"	t	namespace:glm::gtx
u16vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u16, defaultp>	u16vec2;$/;"	t	namespace:glm
u16vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u16, defaultp> u16vec2;$/;"	t	namespace:glm
u16vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u16, defaultp>	u16vec3;$/;"	t	namespace:glm
u16vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u16, defaultp> u16vec3;$/;"	t	namespace:glm
u16vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u16, defaultp>	u16vec4;$/;"	t	namespace:glm
u16vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u16, defaultp> u16vec4;$/;"	t	namespace:glm
u32	vendor/glm/fwd.hpp	/^	typedef uint32					u32;$/;"	t	namespace:glm
u32	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint32 u32;$/;"	t	namespace:glm
u32vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u32, defaultp>	u32vec1;$/;"	t	namespace:glm
u32vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u32, defaultp> u32vec1;$/;"	t	namespace:glm
u32vec1	vendor/glm/gtx/number_precision.hpp	/^	typedef u32			u32vec1;    \/\/!< \\brief 32bit unsigned integer scalar. (from GLM_GTX_number_precision extension)$/;"	t	namespace:glm::gtx
u32vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u32, defaultp>	u32vec2;$/;"	t	namespace:glm
u32vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u32, defaultp> u32vec2;$/;"	t	namespace:glm
u32vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u32, defaultp>	u32vec3;$/;"	t	namespace:glm
u32vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u32, defaultp> u32vec3;$/;"	t	namespace:glm
u32vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u32, defaultp>	u32vec4;$/;"	t	namespace:glm
u32vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u32, defaultp> u32vec4;$/;"	t	namespace:glm
u64	vendor/glm/fwd.hpp	/^	typedef uint64					u64;$/;"	t	namespace:glm
u64	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint64 u64;$/;"	t	namespace:glm
u64vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u64, defaultp>	u64vec1;$/;"	t	namespace:glm
u64vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u64, defaultp> u64vec1;$/;"	t	namespace:glm
u64vec1	vendor/glm/gtx/number_precision.hpp	/^	typedef u64			u64vec1;    \/\/!< \\brief 64bit unsigned integer scalar. (from GLM_GTX_number_precision extension)$/;"	t	namespace:glm::gtx
u64vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u64, defaultp>	u64vec2;$/;"	t	namespace:glm
u64vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u64, defaultp> u64vec2;$/;"	t	namespace:glm
u64vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u64, defaultp>	u64vec3;$/;"	t	namespace:glm
u64vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u64, defaultp> u64vec3;$/;"	t	namespace:glm
u64vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u64, defaultp>	u64vec4;$/;"	t	namespace:glm
u64vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u64, defaultp> u64vec4;$/;"	t	namespace:glm
u8	vendor/glm/fwd.hpp	/^	typedef uint8					u8;$/;"	t	namespace:glm
u8	vendor/glm/gtc/type_precision.hpp	/^	typedef detail::uint8 u8;$/;"	t	namespace:glm
u8vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u8, defaultp>	u8vec1;$/;"	t	namespace:glm
u8vec1	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<1, u8, defaultp> u8vec1;$/;"	t	namespace:glm
u8vec1	vendor/glm/gtx/number_precision.hpp	/^	typedef u8			u8vec1;		\/\/!< \\brief 8bit unsigned integer scalar. (from GLM_GTX_number_precision extension)$/;"	t	namespace:glm::gtx
u8vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u8, defaultp>	u8vec2;$/;"	t	namespace:glm
u8vec2	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<2, u8, defaultp> u8vec2;$/;"	t	namespace:glm
u8vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u8, defaultp>	u8vec3;$/;"	t	namespace:glm
u8vec3	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<3, u8, defaultp> u8vec3;$/;"	t	namespace:glm
u8vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u8, defaultp>	u8vec4;$/;"	t	namespace:glm
u8vec4	vendor/glm/gtc/type_precision.hpp	/^	typedef vec<4, u8, defaultp> u8vec4;$/;"	t	namespace:glm
uint	vendor/glm/detail/setup.hpp	/^	typedef unsigned int	uint;$/;"	t	namespace:glm
uint16	vendor/glm/ext/scalar_uint_sized.hpp	/^		typedef std::uint16_t		uint16;$/;"	t	namespace:glm::detail
uint16	vendor/glm/ext/scalar_uint_sized.hpp	/^	typedef detail::uint16		uint16;$/;"	t	namespace:glm
uint16	vendor/glm/fwd.hpp	/^	typedef std::uint16_t			uint16;$/;"	t	namespace:glm
uint16_t	vendor/glm/fwd.hpp	/^	typedef uint16					uint16_t;$/;"	t	namespace:glm
uint32	vendor/glm/ext/scalar_uint_sized.hpp	/^		typedef std::uint32_t		uint32;$/;"	t	namespace:glm::detail
uint32	vendor/glm/ext/scalar_uint_sized.hpp	/^	typedef detail::uint32		uint32;$/;"	t	namespace:glm
uint32	vendor/glm/fwd.hpp	/^	typedef std::uint32_t			uint32;$/;"	t	namespace:glm
uint32_t	vendor/glm/fwd.hpp	/^	typedef uint32					uint32_t;$/;"	t	namespace:glm
uint64	vendor/glm/detail/setup.hpp	/^		typedef std::uint64_t						uint64;$/;"	t	namespace:glm::detail
uint64	vendor/glm/ext/scalar_uint_sized.hpp	/^	typedef detail::uint64		uint64;$/;"	t	namespace:glm
uint64	vendor/glm/fwd.hpp	/^	typedef std::uint64_t			uint64;$/;"	t	namespace:glm
uint64_t	vendor/glm/fwd.hpp	/^	typedef uint64					uint64_t;$/;"	t	namespace:glm
uint8	vendor/glm/ext/scalar_uint_sized.hpp	/^		typedef std::uint8_t		uint8;$/;"	t	namespace:glm::detail
uint8	vendor/glm/ext/scalar_uint_sized.hpp	/^	typedef detail::uint8		uint8;$/;"	t	namespace:glm
uint8	vendor/glm/fwd.hpp	/^	typedef std::uint8_t			uint8;$/;"	t	namespace:glm
uint8_t	vendor/glm/fwd.hpp	/^	typedef uint8					uint8_t;$/;"	t	namespace:glm
umat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat2								umat2;$/;"	t	namespace:glm
umat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat2								umat2;$/;"	t	namespace:glm
umat2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat2							umat2;$/;"	t	namespace:glm
umat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat2x2							umat2x2;$/;"	t	namespace:glm
umat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat2x2							umat2x2;$/;"	t	namespace:glm
umat2x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat2x2							umat2x2;$/;"	t	namespace:glm
umat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat2x3							umat2x3;$/;"	t	namespace:glm
umat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat2x3							umat2x3;$/;"	t	namespace:glm
umat2x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat2x3							umat2x3;$/;"	t	namespace:glm
umat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat2x4							umat2x4;$/;"	t	namespace:glm
umat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat2x4							umat2x4;$/;"	t	namespace:glm
umat2x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat2x4							umat2x4;$/;"	t	namespace:glm
umat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat3								umat3;$/;"	t	namespace:glm
umat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat3								umat3;$/;"	t	namespace:glm
umat3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat3							umat3;$/;"	t	namespace:glm
umat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat3x2							umat3x2;$/;"	t	namespace:glm
umat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat3x2							umat3x2;$/;"	t	namespace:glm
umat3x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat3x2							umat3x2;$/;"	t	namespace:glm
umat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat3x3							umat3x3;$/;"	t	namespace:glm
umat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat3x3							umat3x3;$/;"	t	namespace:glm
umat3x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat3x3							umat3x3;$/;"	t	namespace:glm
umat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat3x4							umat3x4;$/;"	t	namespace:glm
umat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat3x4							umat3x4;$/;"	t	namespace:glm
umat3x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat3x4							umat3x4;$/;"	t	namespace:glm
umat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat4								umat4;$/;"	t	namespace:glm
umat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat4								umat4;$/;"	t	namespace:glm
umat4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat4							umat4;$/;"	t	namespace:glm
umat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat4x2							umat4x2;$/;"	t	namespace:glm
umat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat4x2							umat4x2;$/;"	t	namespace:glm
umat4x2	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat4x2							umat4x2;$/;"	t	namespace:glm
umat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat4x3							umat4x3;$/;"	t	namespace:glm
umat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat4x3							umat4x3;$/;"	t	namespace:glm
umat4x3	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat4x3							umat4x3;$/;"	t	namespace:glm
umat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef highp_umat4x4							umat4x4;$/;"	t	namespace:glm
umat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef lowp_umat4x4							umat4x4;$/;"	t	namespace:glm
umat4x4	vendor/glm/gtc/matrix_integer.hpp	/^	typedef mediump_umat4x4							umat4x4;$/;"	t	namespace:glm
undo_char	vendor/imgui/imstb_textedit.h	/^   STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];$/;"	m	struct:__anon49
undo_char_point	vendor/imgui/imstb_textedit.h	/^   int undo_char_point, redo_char_point;$/;"	m	struct:__anon49
undo_point	vendor/imgui/imstb_textedit.h	/^   short undo_point, redo_point;$/;"	m	struct:__anon49
undo_rec	vendor/imgui/imstb_textedit.h	/^   StbUndoRecord          undo_rec [STB_TEXTEDIT_UNDOSTATECOUNT];$/;"	m	struct:__anon49
undostate	vendor/imgui/imstb_textedit.h	/^   StbUndoState undostate;$/;"	m	struct:__anon50
uniformLocationCache	Shader/Shader.h	/^	std::unordered_map<std::string, int> uniformLocationCache;$/;"	m	class:Shader
user_allocator_context	vendor/imgui/imstb_truetype.h	/^   void *user_allocator_context;$/;"	m	struct:stbtt_pack_context
userdata	vendor/imgui/imstb_truetype.h	/^   void           * userdata;$/;"	m	struct:stbtt_fontinfo
uv	vendor/imgui/imgui.h	/^    ImVec2  uv;$/;"	m	struct:ImDrawVert
uvec1	vendor/glm/ext/vector_uint1.hpp	/^	typedef vec<1, unsigned int, defaultp>			uvec1;$/;"	t	namespace:glm
uvec1	vendor/glm/fwd.hpp	/^	typedef vec<1, u32, defaultp>	uvec1;$/;"	t	namespace:glm
uvec2	vendor/glm/ext/vector_uint2.hpp	/^	typedef vec<2, unsigned int, defaultp>		uvec2;$/;"	t	namespace:glm
uvec2	vendor/glm/fwd.hpp	/^	typedef vec<2, u32, defaultp>	uvec2;$/;"	t	namespace:glm
uvec3	vendor/glm/ext/vector_uint3.hpp	/^	typedef vec<3, unsigned int, defaultp>		uvec3;$/;"	t	namespace:glm
uvec3	vendor/glm/fwd.hpp	/^	typedef vec<3, u32, defaultp>	uvec3;$/;"	t	namespace:glm
uvec4	vendor/glm/ext/vector_uint4.hpp	/^	typedef vec<4, unsigned int, defaultp>		uvec4;$/;"	t	namespace:glm
uvec4	vendor/glm/fwd.hpp	/^	typedef vec<4, u32, defaultp>	uvec4;$/;"	t	namespace:glm
v	vendor/stb_image/stb_image.h	/^      int h,v;$/;"	m	struct:__anon61::__anon62
v_oversample	vendor/imgui/imstb_truetype.h	/^   unsigned char h_oversample, v_oversample; \/\/ don't set these, they're used internally$/;"	m	struct:__anon33
v_oversample	vendor/imgui/imstb_truetype.h	/^   unsigned int   h_oversample, v_oversample;$/;"	m	struct:stbtt_pack_context
va_copy	vendor/imgui/imgui.cpp	2185;"	d	file:
va_copy	vendor/imgui/imgui.cpp	2187;"	d	file:
val_f	vendor/imgui/imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::ImGuiStoragePair::__anon47
val_i	vendor/imgui/imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::ImGuiStoragePair::__anon47
val_p	vendor/imgui/imgui.h	/^        union { int val_i; float val_f; void* val_p; };$/;"	m	union:ImGuiStorage::ImGuiStoragePair::__anon47
validate_uint32	vendor/stb_image/stb_image.h	/^typedef unsigned char validate_uint32[sizeof(stbi__uint32)==4 ? 1 : -1];$/;"	t
value	vendor/glm/detail/qualifier.hpp	/^			static const bool value = true;$/;"	m	struct:glm::detail::is_aligned
value	vendor/glm/detail/qualifier.hpp	/^		static const bool value = false;$/;"	m	struct:glm::detail::is_aligned
value	vendor/glm/detail/setup.hpp	/^		enum test {value = 0};$/;"	e	enum:glm::detail::is_int::test
value	vendor/glm/detail/setup.hpp	/^		enum test {value = ~0};$/;"	e	enum:glm::detail::is_int::test
value	vendor/glm/detail/type_mat2x2.hpp	/^		col_type value[2];$/;"	m	struct:glm::mat
value	vendor/glm/detail/type_mat2x3.hpp	/^		col_type value[2];$/;"	m	struct:glm::mat
value	vendor/glm/detail/type_mat2x4.hpp	/^		col_type value[2];$/;"	m	struct:glm::mat
value	vendor/glm/detail/type_mat3x2.hpp	/^		col_type value[3];$/;"	m	struct:glm::mat
value	vendor/glm/detail/type_mat3x3.hpp	/^		col_type value[3];$/;"	m	struct:glm::mat
value	vendor/glm/detail/type_mat3x4.hpp	/^		col_type value[3];$/;"	m	struct:glm::mat
value	vendor/glm/detail/type_mat4x2.hpp	/^		col_type value[4];$/;"	m	struct:glm::mat
value	vendor/glm/detail/type_mat4x3.hpp	/^		col_type value[4];$/;"	m	struct:glm::mat
value	vendor/glm/detail/type_mat4x4.hpp	/^		col_type value[4];$/;"	m	struct:glm::mat
value	vendor/glm/ext/scalar_int_sized.hpp	/^		enum test {value = ~0};$/;"	e	enum:glm::detail::is_int::test
value	vendor/glm/ext/scalar_uint_sized.hpp	/^		enum test {value = ~0};$/;"	e	enum:glm::detail::is_int::test
value	vendor/glm/gtx/io.hpp	/^			CTy value[3];$/;"	m	struct:glm::io::delimeter
value	vendor/glm/gtx/io.hpp	/^			order_type value;$/;"	m	struct:glm::io::order
value	vendor/glm/gtx/io.hpp	/^			unsigned value;$/;"	m	struct:glm::io::precision
value	vendor/glm/gtx/io.hpp	/^			unsigned value;$/;"	m	struct:glm::io::width
value	vendor/stb_image/stb_image.h	/^   stbi__uint16 value[288];$/;"	m	struct:__anon64
value_type	vendor/glm/detail/type_mat2x2.hpp	/^		typedef T value_type;$/;"	t	struct:glm::mat
value_type	vendor/glm/detail/type_mat2x3.hpp	/^		typedef T value_type;$/;"	t	struct:glm::mat
value_type	vendor/glm/detail/type_mat2x4.hpp	/^		typedef T value_type;$/;"	t	struct:glm::mat
value_type	vendor/glm/detail/type_mat3x2.hpp	/^		typedef T value_type;$/;"	t	struct:glm::mat
value_type	vendor/glm/detail/type_mat3x3.hpp	/^		typedef T value_type;$/;"	t	struct:glm::mat
value_type	vendor/glm/detail/type_mat3x4.hpp	/^		typedef T value_type;$/;"	t	struct:glm::mat
value_type	vendor/glm/detail/type_mat4x2.hpp	/^		typedef T value_type;$/;"	t	struct:glm::mat
value_type	vendor/glm/detail/type_mat4x3.hpp	/^		typedef T value_type;$/;"	t	struct:glm::mat
value_type	vendor/glm/detail/type_mat4x4.hpp	/^		typedef T value_type;$/;"	t	struct:glm::mat
value_type	vendor/glm/detail/type_quat.hpp	/^		typedef T value_type;$/;"	t	struct:glm::qua
value_type	vendor/glm/detail/type_vec1.hpp	/^		typedef T value_type;$/;"	t	struct:glm::vec
value_type	vendor/glm/detail/type_vec2.hpp	/^		typedef T value_type;$/;"	t	struct:glm::vec
value_type	vendor/glm/detail/type_vec3.hpp	/^		typedef T value_type;$/;"	t	struct:glm::vec
value_type	vendor/glm/detail/type_vec4.hpp	/^		typedef T value_type;$/;"	t	struct:glm::vec
value_type	vendor/glm/gtx/dual_quaternion.hpp	/^		typedef T value_type;$/;"	t	struct:glm::tdualquat
value_type	vendor/imgui/imgui.h	/^    typedef T                   value_type;$/;"	t	struct:ImVector
values	vendor/stb_image/stb_image.h	/^   stbi_uc  values[256];$/;"	m	struct:__anon60
vec	vendor/glm/detail/type_vec1.hpp	/^	struct vec<1, T, Q>$/;"	s	namespace:glm
vec	vendor/glm/detail/type_vec2.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(detail::_swizzle<2, T, Q, E0, E1,-1,-2> const& that)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec2.hpp	/^	struct vec<2, T, Q>$/;"	s	namespace:glm
vec	vendor/glm/detail/type_vec3.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(T const& scalar, detail::_swizzle<2, T, Q, E0, E1, -1, -2> const& v)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec3.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(detail::_swizzle<2, T, Q, E0, E1, -1, -2> const& v, T const& scalar)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec3.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(detail::_swizzle<3, T, Q, E0, E1, E2, -1> const& that)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec3.hpp	/^	struct vec<3, T, Q>$/;"	s	namespace:glm
vec	vendor/glm/detail/type_vec4.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(T const& x, T const& y, detail::_swizzle<2, T, Q, E0, E1, -1, -2> const& v)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec4.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(T const& x, detail::_swizzle<2, T, Q, E0, E1, -1, -2> const& v, T const& w)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec4.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(T const& x, detail::_swizzle<3, T, Q, E0, E1, E2, -1> const& v)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec4.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(detail::_swizzle<2, T, Q, E0, E1, -1, -2> const& v, T const& z, T const& w)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec4.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(detail::_swizzle<2, T, Q, E0, E1, -1, -2> const& v, detail::_swizzle<2, T, Q, F0, F1, -1, -2> const& u)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec4.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(detail::_swizzle<3, T, Q, E0, E1, E2, -1> const& v, T const& w)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec4.hpp	/^			GLM_FUNC_DECL GLM_CONSTEXPR vec(detail::_swizzle<4, T, Q, E0, E1, E2, E3> const& that)$/;"	f	struct:glm::vec
vec	vendor/glm/detail/type_vec4.hpp	/^	struct vec<4, T, Q>$/;"	s	namespace:glm
vec1	vendor/glm/ext/vector_float1.hpp	/^	typedef vec<1, float, defaultp>		vec1;$/;"	t	namespace:glm
vec1	vendor/glm/fwd.hpp	/^	typedef vec<1, float, defaultp>		vec1;$/;"	t	namespace:glm
vec2	vendor/glm/ext/vector_float2.hpp	/^	typedef vec<2, float, defaultp>	vec2;$/;"	t	namespace:glm
vec2	vendor/glm/fwd.hpp	/^	typedef vec<2, float, defaultp>		vec2;$/;"	t	namespace:glm
vec3	vendor/glm/ext/vector_float3.hpp	/^	typedef vec<3, float, defaultp>		vec3;$/;"	t	namespace:glm
vec3	vendor/glm/fwd.hpp	/^	typedef vec<3, float, defaultp>		vec3;$/;"	t	namespace:glm
vec4	vendor/glm/ext/vector_float4.hpp	/^	typedef vec<4, float, defaultp>		vec4;$/;"	t	namespace:glm
vec4	vendor/glm/fwd.hpp	/^	typedef vec<4, float, defaultp>		vec4;$/;"	t	namespace:glm
vs	vendor/stb_image/stb_image.h	/^   int hs,vs;   \/\/ expansion factor in each axis$/;"	m	struct:__anon63
vsnprintf	vendor/imgui/imgui.cpp	1470;"	d	file:
vsnprintf	vendor/imgui/imgui_demo.cpp	104;"	d	file:
w	vendor/glm/detail/type_quat.hpp	/^				struct { T x, y, z, w;};$/;"	m	struct:glm::qua::__anon16::__anon17
w	vendor/glm/detail/type_quat.hpp	/^			T x, y, z, w;$/;"	m	struct:glm::qua
w	vendor/glm/detail/type_vec4.hpp	/^				struct { T x, y, z, w; };$/;"	m	struct:glm::vec::__anon18::__anon19
w	vendor/glm/detail/type_vec4.hpp	/^			T x, y, z, w;$/;"	m	struct:glm::vec
w	vendor/glm/detail/type_vec4.hpp	/^			union { T w, a, q; };$/;"	m	union:glm::vec::__anon25
w	vendor/imgui/imgui.h	/^    float     x, y, z, w;$/;"	m	struct:ImVec4
w	vendor/imgui/imstb_rectpack.h	/^   stbrp_coord    w, h;$/;"	m	struct:stbrp_rect
w	vendor/imgui/imstb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
w	vendor/imgui/imstb_truetype.h	/^   int w,h,stride;$/;"	m	struct:__anon36
w	vendor/stb_image/stb_image.h	/^   int w,h;$/;"	m	struct:__anon72
w2	vendor/stb_image/stb_image.h	/^      int x,y,w2,h2;$/;"	m	struct:__anon61::__anon62
w_lores	vendor/stb_image/stb_image.h	/^   int w_lores; \/\/ horizontal pixels pre-expansion$/;"	m	struct:__anon63
was_packed	vendor/imgui/imstb_rectpack.h	/^   int            was_packed;  \/\/ non-zero if valid packing$/;"	m	struct:stbrp_rect
was_packed	vendor/imgui/imstb_truetype.h	/^   int id,w,h,was_packed;$/;"	m	struct:stbrp_rect
wformat_saver	vendor/glm/gtx/io.hpp	/^		typedef basic_format_saver<wchar_t> wformat_saver;$/;"	t	namespace:glm::io
where	vendor/imgui/imstb_textedit.h	/^   STB_TEXTEDIT_POSITIONTYPE  where;$/;"	m	struct:__anon48
width	Texture/Texture.h	/^	int 			width;$/;"	m	class:Texture
width	vendor/glm/gtx/io.hpp	/^			unsigned   width;$/;"	m	class:glm::io::format_punct
width	vendor/glm/gtx/io.hpp	/^		struct width$/;"	s	namespace:glm::io
width	vendor/imgui/imstb_rectpack.h	/^   int width;$/;"	m	struct:stbrp_context
width	vendor/imgui/imstb_truetype.h	/^   int   width;$/;"	m	struct:stbtt_pack_context
width	vendor/imgui/imstb_truetype.h	/^   int width,height;$/;"	m	struct:__anon45
width_	vendor/glm/gtx/io.hpp	/^			streamsize_type width_;$/;"	m	class:glm::io::basic_state_saver
word	vendor/glm/gtx/raw_data.hpp	/^	typedef detail::uint16		word;$/;"	t	namespace:glm
wstate_saver	vendor/glm/gtx/io.hpp	/^		typedef basic_state_saver<wchar_t> wstate_saver;$/;"	t	namespace:glm::io
ww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> ww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
www	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> www(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wwzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wwzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> wx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wxzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wxzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> wy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wywx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wywx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wywy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wywy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wywz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wywz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wyzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wyzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> wz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> wzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
wzzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> wzzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
x	vendor/glm/detail/type_quat.hpp	/^				struct { T x, y, z, w;};$/;"	m	struct:glm::qua::__anon16::__anon17
x	vendor/glm/detail/type_quat.hpp	/^			T x, y, z, w;$/;"	m	struct:glm::qua
x	vendor/glm/detail/type_vec1.hpp	/^				T x;$/;"	m	union:glm::vec::__anon1
x	vendor/glm/detail/type_vec1.hpp	/^			T x;$/;"	m	struct:glm::vec
x	vendor/glm/detail/type_vec1.hpp	/^			union {T x, r, s;};$/;"	m	union:glm::vec::__anon2
x	vendor/glm/detail/type_vec2.hpp	/^				struct{ T x, y; };$/;"	m	struct:glm::vec::__anon10::__anon11
x	vendor/glm/detail/type_vec2.hpp	/^			T x, y;$/;"	m	struct:glm::vec
x	vendor/glm/detail/type_vec2.hpp	/^			union {T x, r, s;};$/;"	m	union:glm::vec::__anon14
x	vendor/glm/detail/type_vec3.hpp	/^				struct{ T x, y, z; };$/;"	m	struct:glm::vec::__anon3::__anon4
x	vendor/glm/detail/type_vec3.hpp	/^			T x, y, z;$/;"	m	struct:glm::vec
x	vendor/glm/detail/type_vec3.hpp	/^			union { T x, r, s; };$/;"	m	union:glm::vec::__anon7
x	vendor/glm/detail/type_vec4.hpp	/^				struct { T x, y, z, w; };$/;"	m	struct:glm::vec::__anon18::__anon19
x	vendor/glm/detail/type_vec4.hpp	/^			T x, y, z, w;$/;"	m	struct:glm::vec
x	vendor/glm/detail/type_vec4.hpp	/^			union { T x, r, s; };$/;"	m	union:glm::vec::__anon22
x	vendor/imgui/imgui.h	/^    float     x, y, z, w;$/;"	m	struct:ImVec4
x	vendor/imgui/imgui.h	/^    float     x, y;$/;"	m	struct:ImVec2
x	vendor/imgui/imgui_internal.h	/^    float   x;$/;"	m	struct:ImVec1
x	vendor/imgui/imstb_rectpack.h	/^   int x,y;$/;"	m	struct:__anon28
x	vendor/imgui/imstb_rectpack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect
x	vendor/imgui/imstb_rectpack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node
x	vendor/imgui/imstb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon52
x	vendor/imgui/imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon35
x	vendor/imgui/imstb_truetype.h	/^   float x, y;$/;"	m	struct:__anon43
x	vendor/imgui/imstb_truetype.h	/^   float x,y;$/;"	m	struct:__anon44
x	vendor/imgui/imstb_truetype.h	/^   int x,dx;$/;"	m	struct:stbtt__active_edge
x	vendor/imgui/imstb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon45
x	vendor/imgui/imstb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect
x	vendor/imgui/imstb_truetype.h	/^   unsigned char x;$/;"	m	struct:__anon46
x	vendor/stb_image/stb_image.h	/^      int x,y,w2,h2;$/;"	m	struct:__anon61::__anon62
x0	vendor/imgui/imstb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon51
x0	vendor/imgui/imstb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
x0	vendor/imgui/imstb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon31
x0	vendor/imgui/imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon30
x0	vendor/imgui/imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon32
x1	vendor/imgui/imstb_textedit.h	/^   float x0,x1;             \/\/ starting x location, end x location (allows for align=right, etc)$/;"	m	struct:__anon51
x1	vendor/imgui/imstb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
x1	vendor/imgui/imstb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon31
x1	vendor/imgui/imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon30
x1	vendor/imgui/imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon32
xadvance	vendor/imgui/imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon30
xadvance	vendor/imgui/imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon32
xoff	vendor/imgui/imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon30
xoff	vendor/imgui/imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon32
xoff2	vendor/imgui/imstb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon32
xw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> xw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xwzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xwzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> xx(const glm::vec<1, T, Q> &v) {$/;"	f	namespace:glm
xx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> xx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> xx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> xx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xxx(const glm::vec<1, T, Q> &v) {$/;"	f	namespace:glm
xxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xxx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxxx(const glm::vec<1, T, Q> &v) {$/;"	f	namespace:glm
xxxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxxx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xxxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxxy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xxxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xxy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxyx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xxyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxyy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xxyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xxzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xxzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xxzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> xy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> xy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> xy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xywx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xywx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xywy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xywy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xywz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xywz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xyx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyxx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xyxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyxy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xyxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xyy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyyx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xyyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyyy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
xyyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xyzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xyzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xyzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> xz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> xz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> xzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
xzzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
xzzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> xzzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
y	vendor/glm/detail/type_quat.hpp	/^				struct { T x, y, z, w;};$/;"	m	struct:glm::qua::__anon16::__anon17
y	vendor/glm/detail/type_quat.hpp	/^			T x, y, z, w;$/;"	m	struct:glm::qua
y	vendor/glm/detail/type_vec2.hpp	/^				struct{ T x, y; };$/;"	m	struct:glm::vec::__anon10::__anon11
y	vendor/glm/detail/type_vec2.hpp	/^			T x, y;$/;"	m	struct:glm::vec
y	vendor/glm/detail/type_vec2.hpp	/^			union {T y, g, t;};$/;"	m	union:glm::vec::__anon15
y	vendor/glm/detail/type_vec3.hpp	/^				struct{ T x, y, z; };$/;"	m	struct:glm::vec::__anon3::__anon4
y	vendor/glm/detail/type_vec3.hpp	/^			T x, y, z;$/;"	m	struct:glm::vec
y	vendor/glm/detail/type_vec3.hpp	/^			union { T y, g, t; };$/;"	m	union:glm::vec::__anon8
y	vendor/glm/detail/type_vec4.hpp	/^				struct { T x, y, z, w; };$/;"	m	struct:glm::vec::__anon18::__anon19
y	vendor/glm/detail/type_vec4.hpp	/^			T x, y, z, w;$/;"	m	struct:glm::vec
y	vendor/glm/detail/type_vec4.hpp	/^			union { T y, g, t; };$/;"	m	union:glm::vec::__anon23
y	vendor/imgui/imgui.h	/^    float     x, y, z, w;$/;"	m	struct:ImVec4
y	vendor/imgui/imgui.h	/^    float     x, y;$/;"	m	struct:ImVec2
y	vendor/imgui/imstb_rectpack.h	/^   int x,y;$/;"	m	struct:__anon28
y	vendor/imgui/imstb_rectpack.h	/^   stbrp_coord    x, y;$/;"	m	struct:stbrp_rect
y	vendor/imgui/imstb_rectpack.h	/^   stbrp_coord  x,y;$/;"	m	struct:stbrp_node
y	vendor/imgui/imstb_textedit.h	/^   float x,y;    \/\/ position of n'th character$/;"	m	struct:__anon52
y	vendor/imgui/imstb_truetype.h	/^      stbtt_vertex_type x,y,cx,cy,cx1,cy1;$/;"	m	struct:__anon35
y	vendor/imgui/imstb_truetype.h	/^   float x, y;$/;"	m	struct:__anon43
y	vendor/imgui/imstb_truetype.h	/^   float x,y;$/;"	m	struct:__anon44
y	vendor/imgui/imstb_truetype.h	/^   int x,y,bottom_y;$/;"	m	struct:__anon45
y	vendor/imgui/imstb_truetype.h	/^   stbrp_coord x,y;$/;"	m	struct:stbrp_rect
y	vendor/stb_image/stb_image.h	/^      int x,y,w2,h2;$/;"	m	struct:__anon61::__anon62
y0	vendor/imgui/imstb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
y0	vendor/imgui/imstb_truetype.h	/^   float x0,y0,s0,t0; \/\/ top-left$/;"	m	struct:__anon31
y0	vendor/imgui/imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon30
y0	vendor/imgui/imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon32
y1	vendor/imgui/imstb_truetype.h	/^   float x0,y0, x1,y1;$/;"	m	struct:stbtt__edge
y1	vendor/imgui/imstb_truetype.h	/^   float x1,y1,s1,t1; \/\/ bottom-right$/;"	m	struct:__anon31
y1	vendor/imgui/imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon30
y1	vendor/imgui/imstb_truetype.h	/^   unsigned short x0,y0,x1,y1; \/\/ coordinates of bbox in bitmap$/;"	m	struct:__anon32
ymax	vendor/imgui/imstb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon51
ymin	vendor/imgui/imstb_textedit.h	/^   float ymin,ymax;         \/\/ height of row above and below baseline$/;"	m	struct:__anon51
yoff	vendor/imgui/imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon30
yoff	vendor/imgui/imstb_truetype.h	/^   float xoff,yoff,xadvance;$/;"	m	struct:__anon32
yoff2	vendor/imgui/imstb_truetype.h	/^   float xoff2,yoff2;$/;"	m	struct:__anon32
ypos	vendor/stb_image/stb_image.h	/^   int ypos;    \/\/ which pre-expansion row we're on$/;"	m	struct:__anon63
ystep	vendor/stb_image/stb_image.h	/^   int ystep;   \/\/ how far through vertical expansion we are$/;"	m	struct:__anon63
yw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> yw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> ywx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> ywy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> ywz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
ywzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> ywzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> yx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> yx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> yx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yxx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxxx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yxxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxxy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yxxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yxy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxyx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yxyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxyy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yxyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yxzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yxzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yxzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> yy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> yy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> yy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yywx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yywx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yywy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yywy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yywz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yywz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yyx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyxx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yyxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyxy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yyxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yyy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyyx(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yyyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyyy(const glm::vec<2, T, Q> &v) {$/;"	f	namespace:glm
yyyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yyzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yyzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yyzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> yz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> yz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> yzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
yzzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
yzzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> yzzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
z	vendor/glm/detail/type_quat.hpp	/^				struct { T x, y, z, w;};$/;"	m	struct:glm::qua::__anon16::__anon17
z	vendor/glm/detail/type_quat.hpp	/^			T x, y, z, w;$/;"	m	struct:glm::qua
z	vendor/glm/detail/type_vec3.hpp	/^				struct{ T x, y, z; };$/;"	m	struct:glm::vec::__anon3::__anon4
z	vendor/glm/detail/type_vec3.hpp	/^			T x, y, z;$/;"	m	struct:glm::vec
z	vendor/glm/detail/type_vec3.hpp	/^			union { T z, b, p; };$/;"	m	union:glm::vec::__anon9
z	vendor/glm/detail/type_vec4.hpp	/^				struct { T x, y, z, w; };$/;"	m	struct:glm::vec::__anon18::__anon19
z	vendor/glm/detail/type_vec4.hpp	/^			T x, y, z, w;$/;"	m	struct:glm::vec
z	vendor/glm/detail/type_vec4.hpp	/^			union { T z, b, p; };$/;"	m	union:glm::vec::__anon24
z	vendor/imgui/imgui.h	/^    float     x, y, z, w;$/;"	m	struct:ImVec4
z_distance	vendor/stb_image/stb_image.h	/^   stbi__zhuffman z_length, z_distance;$/;"	m	struct:__anon65
z_expandable	vendor/stb_image/stb_image.h	/^   int   z_expandable;$/;"	m	struct:__anon65
z_length	vendor/stb_image/stb_image.h	/^   stbi__zhuffman z_length, z_distance;$/;"	m	struct:__anon65
zbuffer	vendor/stb_image/stb_image.h	/^   stbi_uc *zbuffer, *zbuffer_end;$/;"	m	struct:__anon65
zbuffer_end	vendor/stb_image/stb_image.h	/^   stbi_uc *zbuffer, *zbuffer_end;$/;"	m	struct:__anon65
zout	vendor/stb_image/stb_image.h	/^   char *zout;$/;"	m	struct:__anon65
zout_end	vendor/stb_image/stb_image.h	/^   char *zout_end;$/;"	m	struct:__anon65
zout_start	vendor/stb_image/stb_image.h	/^   char *zout_start;$/;"	m	struct:__anon65
zw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> zw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zwzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zwzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> zx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> zx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zxzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zxzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zxzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> zy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> zy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zywx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zywx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zywy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zywy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zywz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zywz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zyzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zyzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zyzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> zz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<2, T, Q> zz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzww	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzww(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzwx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzwx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzwy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzwy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzwz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzwz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzxw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzxw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzxx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzxx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzxx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzxy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzxy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzxy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzxz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzxz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzxz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzyw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzyw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzyx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzyx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzyx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzyy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzyy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzyy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzyz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzyz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzyz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<3, T, Q> zzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzzw	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzzw(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzzx(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzzx	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzzx(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzzy(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzzy	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzzy(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
zzzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzzz(const glm::vec<3, T, Q> &v) {$/;"	f	namespace:glm
zzzz	vendor/glm/gtx/vec_swizzle.hpp	/^	GLM_INLINE glm::vec<4, T, Q> zzzz(const glm::vec<4, T, Q> &v) {$/;"	f	namespace:glm
~ExampleAppConsole	vendor/imgui/imgui_demo.cpp	/^    ~ExampleAppConsole()$/;"	f	struct:ExampleAppConsole
~ImDrawData	vendor/imgui/imgui.h	/^    ~ImDrawData()   { Clear(); }$/;"	f	struct:ImDrawData
~ImDrawList	vendor/imgui/imgui.h	/^    ~ImDrawList() { ClearFreeMemory(); }$/;"	f	struct:ImDrawList
~ImDrawListSplitter	vendor/imgui/imgui.h	/^    inline ~ImDrawListSplitter() { ClearFreeMemory(); }$/;"	f	struct:ImDrawListSplitter
~ImFont	vendor/imgui/imgui_draw.cpp	/^ImFont::~ImFont()$/;"	f	class:ImFont
~ImFontAtlas	vendor/imgui/imgui_draw.cpp	/^ImFontAtlas::~ImFontAtlas()$/;"	f	class:ImFontAtlas
~ImGuiListClipper	vendor/imgui/imgui.h	/^    ~ImGuiListClipper()                                                 { IM_ASSERT(ItemsCount == -1); }      \/\/ Assert if user forgot to call End() or Step() until false.$/;"	f	struct:ImGuiListClipper
~ImGuiWindow	vendor/imgui/imgui.cpp	/^ImGuiWindow::~ImGuiWindow()$/;"	f	class:ImGuiWindow
~ImPool	vendor/imgui/imgui_internal.h	/^    ~ImPool()   { Clear(); }$/;"	f	struct:ImPool
~ImVector	vendor/imgui/imgui.h	/^    inline ~ImVector()                                      { if (Data) IM_FREE(Data); }$/;"	f	struct:ImVector
~IndexBuffer	IndexBuffer/IndexBuffer.cpp	/^IndexBuffer::~IndexBuffer(){$/;"	f	class:IndexBuffer
~Shader	Shader/Shader.cpp	/^Shader::~Shader(){}$/;"	f	class:Shader
~Texture	Texture/Texture.cpp	/^Texture::~Texture(){$/;"	f	class:Texture
~VertexArray	VertexArray/VertexArray.cpp	/^VertexArray::~VertexArray(){$/;"	f	class:VertexArray
~VertexBuffer	VertexBuffer/VertexBuffer.cpp	/^VertexBuffer::~VertexBuffer(){$/;"	f	class:VertexBuffer
~VertexBufferLayout	VertexBufferLayout/VertexBufferLayout.cpp	/^VertexBufferLayout::~VertexBufferLayout() {}$/;"	f	class:VertexBufferLayout
